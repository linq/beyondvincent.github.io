<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS翻译 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iosfan-yi/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2013-11-21T21:29:17+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 7 教程：定制iOS 7中的导航栏和状态栏]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/"/>
    <updated>2013-11-03T22:55:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/03/120-customize-navigation-status-bar-ios-7</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/11/7.png" alt="" /></p>

<!--more-->


<p>注：本文译自<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/"><code>Customizing Navigation Bar and Status Bar in iOS 7</code></a></p>

<p>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。</p>

<p>之前我曾经写过一篇关于<a href="http://www.appcoda.com/customize-navigation-bar-back-butto/">如何定制导航栏</a>的文章。不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>

<ul>
<li><a href="#0">iOS 7中默认的导航栏</a></li>
<li><a href="#1">设置导航栏的背景颜色</a></li>
<li><a href="#2">在导航栏中使用背景图片</a></li>
<li><a href="#3">定制返回按钮的颜色</a></li>
<li><a href="#4">修改导航栏标题的字体</a></li>
<li><a href="#44">修改导航栏标题为图片</a></li>
<li><a href="#5">添加多个按钮</a></li>
<li><a href="#6">修改状态栏的风格</a></li>
<li><a href="#7">隐藏状态栏</a></li>
<li><a href="#8">总结</a></li>
</ul>


<p><img src="/images/2013/11/9.jpg" alt="" /></p>

<p>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>

<h3><a id="0"></a>iOS 7中默认的导航栏</h3>

<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用<code>Single View Controller</code>模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程</a>。</p>

<p>Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：</p>

<p><img src="/images/2013/11/10.jpg" alt="" /></p>

<p>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>

<h3><a id="1"></a>设置导航栏的背景颜色</h3>

<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在<code>AppDelegate.m</code>文件中的方法<code>didFinishLaunchingWithOptions:</code>里面添加如下代码来修改颜色：</p>

<p><code>objc
[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]];
</code></p>

<p>效果如下图所示：</p>

<p><img src="/images/2013/11/11.jpg" alt="" /></p>

<p>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：</p>

<p>```objc</p>

<h1>define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) >> 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) >> 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</h1>

<p>```</p>

<p>将上面这个宏放到<code>AppDelegate.m</code>文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：</p>

<p><code>objc
[[UINavigationBar appearance] setBarTintColor:UIColorFromRGB(0x067AB5)];
</code></p>

<p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：</p>

<p><img src="/images/2013/11/12.jpg" alt="" /></p>

<p>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>

<h3><a id="2"></a>在导航栏中使用背景图片</h3>

<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。</p>

<p>我们依然可以使用<code>setBackgroundImage:</code>方法为导航栏设置自定义图片。如下代码所示：</p>

<p><code>objc
[[UINavigationBar appearance] setBackgroundImage:[UIImage imageNamed:@"nav_bg.png"] forBarMetrics:UIBarMetricsDefault];
</code></p>

<p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：</p>

<p><img src="/images/2013/11/13.jpg" alt="" /></p>

<h3><a id="3"></a>定制返回按钮的颜</h3>

<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示"返回")。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：</p>

<p><code>objc
[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];
</code></p>

<p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。</p>

<p><img src="/images/2013/11/14.jpg" alt="" /></p>

<p>如果想要用自己的图片替换V型，可以设置图片的<code>backIndicatorImage</code>和<code>backIndicatorTransitionMaskImage</code>。如下代码所示：</p>

<p><code>objc
[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"back_btn.png"]];
[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"back_btn.png"]];
</code></p>

<p>图片的颜色是由tintColor属性控制的。</p>

<p><img src="/images/2013/11/15.jpg" alt="" /></p>

<h3><a id="4"></a>修改导航栏标题的字体</h3>

<p>跟iOS 6一样，我们可以使用导航栏的<code>titleTextAttributes</code>属性来定制导航栏的文字风格。在text attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：</p>

<ul>
<li>UITextAttributeFont – 字体key</li>
<li>UITextAttributeTextColor – 文字颜色key</li>
<li>UITextAttributeTextShadowColor – 文字阴影色key</li>
<li>UITextAttributeTextShadowOffset – 文字阴影偏移量key</li>
</ul>


<p>如下代码所示，对导航栏的标题风格做了修改：</p>

<p>```objc
NSShadow *shadow = [[NSShadow alloc] init];</p>

<pre><code>shadow.shadowColor = [UIColor colorWithRed:0.0 green:0.0 blue:0.0 alpha:0.8];
shadow.shadowOffset = CGSizeMake(0, 1);
[[UINavigationBar appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys:
                                                       [UIColor colorWithRed:245.0/255.0 green:245.0/255.0 blue:245.0/255.0 alpha:1.0], NSForegroundColorAttributeName,
                                                       shadow, NSShadowAttributeName,
                                                       [UIFont fontWithName:@"HelveticaNeue-CondensedBlack" size:21.0], NSFontAttributeName, nil]];
</code></pre>

<p>```</p>

<p>运行效果如下图所示：</p>

<p><img src="/images/2013/11/16.jpg" alt="" /></p>

<h3><a id="44"></a>修改导航栏标题为图片</h3>

<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：</p>

<p><code>objc
self.navigationItem.titleView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"appcoda-logo.png"]];
</code></p>

<p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。
注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。</p>

<p>具体效果如下图所示：</p>

<p><img src="/images/2013/11/17.jpg" alt="" /></p>

<h3><a id="5"></a>添加多个按钮</h3>

<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：</p>

<p>```objc</p>

<pre><code>UIBarButtonItem *shareItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemAction target:self action:nil];
UIBarButtonItem *cameraItem = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCamera target:self action:nil];

NSArray *actionButtonItems = @[shareItem, cameraItem];
self.navigationItem.rightBarButtonItems = actionButtonItems;
</code></pre>

<p>```</p>

<p>如下效果：</p>

<p><img src="/images/2013/11/18.jpg" alt="" /></p>

<h3><a id="6"></a>修改状态栏的风格</h3>

<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：</p>

<p><img src="/images/2013/11/19.jpg" alt="" /></p>

<p>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overriding<code>preferredStatusBarStyle:</code>方法，如下所示：</p>

<p>```objc
&ndash;(UIStatusBarStyle)preferredStatusBarStyle
{</p>

<pre><code>return UIStatusBarStyleLightContent; 
</code></pre>

<p>}
```</p>

<p>上面代码的效果如下图所示：</p>

<p><img src="/images/2013/11/20.jpg" alt="" /></p>

<p>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用<code>View controller-based status bar appearance</code>。在project target的Info tab中，插入一个新的key，名字为<code>View controller-based status bar appearance</code>，并将其值设置为NO。</p>

<p><img src="/images/2013/11/21.jpg" alt="" /></p>

<p>然后就可以使用下面的代码来设置状态栏风格了：</p>

<p><code>objc
[[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent];
</code></p>

<h3><a id="7"></a>隐藏状态栏</h3>

<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：</p>

<p>```objc
&ndash; (BOOL)prefersStatusBarHidden
{</p>

<pre><code>return YES;
</code></pre>

<p>}
```</p>

<h3><a id="8"></a>总结</h3>

<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。</p>

<p>这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程源码</a>。只需要取消相关代码注释即可进行测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：制作一个通用程序 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/02/119-sprite-kit-tutorial-making-a-universal-app-part-2/"/>
    <updated>2013-11-02T18:55:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/02/119-sprite-kit-tutorial-making-a-universal-app-part-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/25.png"></p>

<!--more-->


<p>注1：本文译自<a href="http://www.raywenderlich.com/49697/sprite-kit-tutorial-making-a-universal-app-part-2"><code>Sprite Kit Tutorial: Making a Universal App: Part 2</code></a></p>

<p>注2：我最近长时间在广西南宁出差，比较忙，跑步和篮球都歇着了，博客更新频率也有点慢。下周⑥又是某某人的生日，估计是回不去了%>_&lt;%，下半年还有一些重要的事情要做，时间太少！加油！</p>

<p>上周发现住的附近有一个公园，考察了一下，适合跑步，所以呢，我计划本周末去买点运动的衣服，重启跑步计划 :]</p>

<p>看吧，下图就是公园照的</p>

<p><img src="/images/2013/11/1.jpg" alt="南宁市人民公园" /></p>

<p>好啦，下面开始本文正题：</p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#dhkx">动画的定义：可行性</a></li>
<li><a href="#sxlb">属性列表</a></li>
<li><a href="#yxlj">添加游戏逻辑</a></li>
<li><a href="#tjyx">添加音效</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p><a href="http://beyondvincent.com/blog/2013/10/27/118-sprite-kit-tutorial-making-a-universal-app-part-1/">上一篇文章中</a>，创建了一个基本的游戏程序：一些可爱的鼹鼠从洞里面跳出来。并且为了能够让程序很好的运行在iPhone 3.5英寸，iPhone 4英寸，iPad和iPad Retina上，还花费了大量的篇幅介绍UI设计和坐标系相关知识。</p>

<p>本文，将给鼹鼠添加一些可爱的动画：笑和被打时的表情，并添加一种玩法：可以通过敲打鼹鼠来赚取点数，另外还会添加一些音效。</p>

<h3><a id="dhkx"></a>动画的定义：可行性</h3>

<p>为了让游戏更加有趣，我们将在游戏中给鼹鼠添加两个动画。首先，当鼹鼠从洞里面跳出来时是笑的动画，然后，当你敲打它们的时候，是一个被敲打的表情。</p>

<p>在开始之前，我们先来看看在代码里面定义动画的可行性。</p>

<p>鼹鼠笑的动画需要用到的图片和相关顺序是这样的：
mole_laugh1.png, mole_laugh2.png mole_laugh3.png, mole_laugh2.png, mole_laugh3.png, mole_laugh1.png。</p>

<p>我们可以通过硬编码的方式来配置我们的动画，如下代码所示：</p>

<p>```objc
[animFrames addObject:</p>

<pre><code>[SKTexture textureWithImageNamed:@"mole_laugh1.png"]];
</code></pre>

<p>[animFrames addObject:</p>

<pre><code>[SKTexture textureWithImageNamed:@"mole_laugh2.png"]];
</code></pre>

<p>[animFrames addObject:</p>

<pre><code>[SKTexture textureWithImageNamed:@"mole_laugh3.png"]];
</code></pre>

<p>[animFrames addObject:</p>

<pre><code>[SKTexture textureWithImageNamed:@"mole_laugh2.png"]];
</code></pre>

<p>// And so on&hellip;
```</p>

<p>不过，这很容易让我们的代码剧增。为了简洁一点，此处我们不用上面的代码来定义动画，而是使用属性列表来代替。</p>

<h3><a id="sxlb"></a>属性列表</h3>

<p>如果之前你没有用过属性列表，也没关系。属性列表就是一个特殊的文件，可以用Xcode创建，文件按照一定的格式包含数组、字典、字符串和数字，所以非常容易创建，并且在代码中叶能够方便的读取到这些值。</p>

<p>下面我们在Xcode中试试吧。右键单击ShackAMole，选择"New File…"，接着选择 “iOS\Resource\Property List”，然后单击"Next"。将文件命名为"laughAnim.plist"，最后单击创建。现在可以在Xcode中看到laughAnim.plist的可视化编辑界面，如下图所示：</p>

<p><img src="/images/2013/11/2.png" alt="南" /></p>

<p>每个属性列表都有一个root element。一般这是一个数组或者字典。在我们创建的这个文件中，将包含让鼹鼠笑起来所需动画的所有图片名称，是一个数组，所以点击root element的第二列(Type，当前为Dictionary)，将其修改为Array。</p>

<p>接着，单击Root单词右边的加号按钮，以在数组中添加一个新的entry。默认情况下，entry的类型是String(刚好是我们想要的).将这个entry的值修改为"mole_laugh1.png"。</p>

<p>继续点击加号按钮添加新的一条记录，直到所有的图片名称都添加进来了，如下图所示：</p>

<p><img src="/images/2013/11/3.png" alt="" /></p>

<p>接着添加一个鼹鼠被打击所需要图片的属性列表文件，跟上面的步骤一样，不过记得将文件命名为hitAnim.plist文件，如下所示：</p>

<p><img src="/images/2013/11/4.png" alt="" /></p>

<p>下面，我们就在代码中加载这些图片吧。打开MyScene.h文件，并为每个动画动作添加对应的属性，如下代码所示：</p>

<p><code>objc
// Inside @interface MyScene
@property (strong, nonatomic) SKAction *laughAnimation;
@property (strong, nonatomic) SKAction *hitAnimation;
</code></p>

<p>我们用上面这两个属性记录每个SKAction，这样可以在代码中方便的查找和重用。</p>

<p>接着在MyScene.m中添加一个方法，方法中的代码根据传入的属性列表创建并返回SKAction，如下所示：</p>

<p>```objc
&ndash; (SKAction <em>)animationFromPlist:(NSString </em>)animPlist
{</p>

<pre><code>NSString *plistPath = [[NSBundle mainBundle] pathForResource:animPlist ofType:@"plist"]; // 1
NSArray *animImages = [NSArray arrayWithContentsOfFile:plistPath]; // 2
NSMutableArray *animFrames = [NSMutableArray array]; // 3
for (NSString *imageName in animImages) { // 4
    [animFrames addObject:[SKTexture textureWithImageNamed:imageName]]; // 5
}

float framesOverOneSecond = 1.0f/(float)[animFrames count];

return [SKAction animateWithTextures:animFrames timePerFrame:framesOverOneSecond resize:NO restore:YES]; // 6
</code></pre>

<p>}
```</p>

<p>理解上面的代码很重要，我们一行一行的来看看吧：</p>

<ol>
<li>由于属性列表是包含在工程里面的，所以它应该在程序的"main bundle"中。这个helper方法计算出了属性列表文件在main bundle中的全路径。</li>
<li>这行代码是读取属性列表文件中的内容。NSArray中有一个名为arrayWithContentsOfFile的方法，此处将文件名传递进去，就可以将属性列表中的内容读取到数组中了。（注意，之所以可以这样，是因为属性列表中的root element设置为NSArray），如果是一个字典的话，可以使用[NSDictionary dictionaryWithContentsOfFile…]。</li>
<li>创建一个空的数组，用来存储动画的每一帧。</li>
<li>循环遍历数组获得每个图片名字。</li>
<li>获得每个图片的纹理，然后将其添加到数组中。</li>
<li>根据纹理数组返回一个SKAction。</li>
</ol>


<p>接下来，在init方法的尾部为每个动画调用上面这个helper方法，如下代码所示：</p>

<p><code>objc
self.laughAnimation = [self animationFromPlist:@"laughAnim"];
self.hitAnimation = [self animationFromPlist:@"hitAnim"];
</code></p>

<p>最后一步：使用动画(让鼹鼠笑起来)。修改popMole方法，如下代码所示：</p>

<p>```objc
&ndash; (void)popMole:(SKSpriteNode *)mole
{</p>

<pre><code>SKAction *easeMoveUp = [SKAction moveToY:mole.position.y + mole.size.height duration:0.2f];
easeMoveUp.timingMode = SKActionTimingEaseInEaseOut;
SKAction *easeMoveDown = [SKAction moveToY:mole.position.y duration:0.2f];
easeMoveDown.timingMode = SKActionTimingEaseInEaseOut;


SKAction *sequence = [SKAction sequence:@[easeMoveUp, self.laughAnimation, easeMoveDown]];
[mole runAction:sequence];
</code></pre>

<p>}
```</p>

<p>上面的代码与之前唯一不同的就是用laughAnimation action替代了pop down之前的延迟一秒。laughAnimation action会使用laughAnim.plist中的纹理，注意之前已经把restore设置为YES了，所以当动画播放完之后，鼹鼠会回到正常的表情。</p>

<p>现在编译并运行程序，可以看到鼹鼠跳出来，并笑了！如下图所示：</p>

<p><img src="/images/2013/11/5.png" alt="" /></p>

<p>下面我们来看看如何停止鼹鼠的<code>微笑</code>动画，并开始敲打它们。</p>

<h3><a id="yxlj"></a>添加游戏逻辑</h3>

<p>现在我们准备给游戏添加玩法，也就是游戏逻辑。基本想法就是会有一定数量的鼹鼠出现，当玩家打击到这些出现的鼹鼠时，就会获得相应的点数，玩家将尽力获得最多的点数。</p>

<p>因此，我们需要记录分数，并将分数显示在屏幕中。当鼹鼠显示完毕时候，我们将对用户做出提示。</p>

<p>先打开MyScene.h文件，并将下面这些实例变量添加到之前写的action后面：</p>

<p><code>objc
@property (strong, nonatomic) SKLabelNode *scoreLabel;
@property (nonatomic) NSInteger score;
@property (nonatomic) NSInteger totalSpawns;
@property (nonatomic) BOOL gameOver;
</code>
有一个用于显示分数的label，一个记录当前分数的变量，一个记录已经弹出了多少个鼹鼠，以及游戏是否结束。</p>

<p>接着，将下面的代码添加到文件MyScene.m文件中initWithSize:方法尾部：</p>

<p>```objc
// Add score label
float margin = 10;</p>

<p>self.scoreLabel = [SKLabelNode labelNodeWithFontNamed:@&ldquo;Chalkduster&rdquo;];
self.scoreLabel.text = @&ldquo;Score: 0&rdquo;;
self.scoreLabel.fontSize = [self convertFontSize:14];
self.scoreLabel.zPosition = 4;
self.scoreLabel.horizontalAlignmentMode = SKLabelHorizontalAlignmentModeLeft;
self.scoreLabel.position = CGPointMake(margin, margin);
[self addChild:self.scoreLabel];
```</p>

<p>上面的代码创建了一个用于分数显示的label。label位于屏幕的左下角，并且距离左下角的边距为10 point。并将label的属性horizontalAlignmentMode设置为SKLabelHorizontalAlignmentModeLeft，这样可以让label的文字从左侧对齐。</p>

<p>另外，此处并没有直接给label设置字体大小，而是先通过一个helper函数将字体大小做转换。这是因为在iPad和iPad retina上字体的尺寸要大一点。下面是convertFontSize方法的实现：</p>

<p>```objc
&ndash; (float)convertFontSize:(float)fontSize
{</p>

<pre><code>if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) {
    return fontSize * 2;
} else {
    return fontSize;
}
</code></pre>

<p>}
```</p>

<p>如上代码所示，如果是iPad和iPad retina，那么就将字体尺寸变为原来的两倍，否则保持原样。</p>

<p>接着，我们需要添加触摸检测的代码，用来判断是否打击了某个鼹鼠。不过在开始之前，我们需要给鼹鼠添加一个flag，以此知道鼹鼠当前是否可以点击(tappable)。只有当鼹鼠笑的时候才可以点击，而当它移动或者在底下时是不可以点击的，也就是“安全的”。</p>

<p>我们可以创建一个SKSpriteNode的子类来记录这个flag，不过在此我们只需要存储一个信息，因此我们可以使用SKSpriteNode中的userData属性来代替。如下，再次将popMole做修改：</p>

<p>```objc
&ndash; (void)popMole:(SKSpriteNode *)mole
{</p>

<pre><code>if (self.totalSpawns &gt; 50) return;
self.totalSpawns++;

// Reset texture of mole sprite
mole.texture = self.moleTexture;

SKAction *easeMoveUp = [SKAction moveToY:mole.position.y + mole.size.height duration:0.2f];
easeMoveUp.timingMode = SKActionTimingEaseInEaseOut;
SKAction *easeMoveDown = [SKAction moveToY:mole.position.y duration:0.2f];
easeMoveDown.timingMode = SKActionTimingEaseInEaseOut;

SKAction *setTappable = [SKAction runBlock:^{
    [mole.userData setObject:@1 forKey:@"tappable"];
}];

SKAction *unsetTappable = [SKAction runBlock:^{
    [mole.userData setObject:@0 forKey:@"tappable"];
}];


SKAction *sequence = [SKAction sequence:@[easeMoveUp, setTappable, self.laughAnimation, unsetTappable, easeMoveDown]];
[mole runAction:sequence completion:^{
    [mole removeAllActions];
}];
</code></pre>

<p>}
```</p>

<p>主要做了如下修改：</p>

<ul>
<li>如果显示的鼹鼠数量有50个，那么立即返回，也就是说，在游戏中，50是最大的上限。</li>
<li>在函数开头，重置一下鼹鼠的图片(&ldquo;mole_1.png&rdquo;)。这样做是因为如果鼹鼠在上一次显示的时候被击打了，它仍然显示被击打的图片，所以在这里显示之前，需要重置一下。</li>
<li>在鼹鼠笑之前，先运行一个action，该action会在block中运行一段代码。该block将userData字典中名为tappable的key值设置为1，这样就可以表示鼹鼠可以被击打了。</li>
<li>类似的，当鼹鼠笑过之后，同样运行一个action：将tappable的值设置为0.</li>
</ul>


<p>现在，鼹鼠有一个flag可以表示它是否可以被击中了。接着我们可以添加touchesBegan:方法了。将如下代码添加到文件中：</p>

<p>```objc
&ndash; (void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{</p>

<pre><code>UITouch *touch = [touches anyObject];
CGPoint touchLocation = [touch locationInNode:self];

SKNode *node = [self nodeAtPoint:touchLocation];
if ([node.name isEqualToString:@"Mole"]) {
    SKSpriteNode *mole = (SKSpriteNode *)node;

    if (![[mole.userData objectForKey:@"tappable"] boolValue]) return;

    self.score += 10;

    [mole.userData setObject:@0 forKey:@"tappable"];
    [mole removeAllActions];

    SKAction *easeMoveDown = [SKAction moveToY:(mole.position.y - mole.size.height) duration:0.2f];
    easeMoveDown.timingMode = SKActionTimingEaseInEaseOut;

    // Slow down the animation by half
    easeMoveDown.speed = 0.5;

    SKAction *sequence = [SKAction sequence:@[self.hitAnimation, easeMoveDown]];
    [mole runAction:sequence];
}
</code></pre>

<p>}
```</p>

<p>上面的touchesBegan:方法首先获得触摸的位置，然后找到触摸位置对于的SKNode，如果node的名字是Mole，那么会进一步判断这个鼹鼠的tappable。</p>

<p>如果鼹鼠被击中，会将该鼹鼠设置为不可再被击中，并把分数增加。然后停止所有运行的action，并播放被击中的动画，动画播放完毕之后，就立即把鼹鼠放回洞中。</p>

<p>最后一步：添加一些代码对分数进行更新，并且做一个级别完成条件的检查，如下代码所示：</p>

<p>```objc
if (self.gameOver) return;</p>

<p>if (self.totalSpawns >= 50) {</p>

<pre><code>SKLabelNode *gameOverLabel = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
gameOverLabel.text = @"Level Complete!";
gameOverLabel.fontSize = 48;
gameOverLabel.zPosition = 4;
gameOverLabel.position = CGPointMake(CGRectGetMidX(self.frame),
                                     CGRectGetMidY(self.frame));

[gameOverLabel setScale:0.1];

[self addChild:gameOverLabel];
[gameOverLabel runAction:[SKAction scaleTo:1.0 duration:0.5]];

self.gameOver = YES;
return;
</code></pre>

<p>}</p>

<p>[self.scoreLabel setText:[NSString stringWithFormat:@&ldquo;Score: %d&rdquo;, self.score]];
```</p>

<p>搞定！编译并运行程序，应该可以击打鼹鼠，并看到分数在增加！如下图所示：</p>

<p><img src="/images/2013/11/6.png" alt="" /></p>

<h3><a id="tjyx"></a>添加音效</h3>

<p>为了让程序更加有趣，下面我们给这游戏添加音效。先来这里下载<a href="http://cdn5.raywenderlich.com/downloads/WhackAMoleSKSounds.zip">音效</a>吧。加压出文件，并把声音资源拖拽到WhackAMole文件件中。确保勾选上<code>Copy items into destination group’s folder</code>，然后单击Finish。</p>

<p>将下面声明语句添加到MyScene.h文件顶部：</p>

<p>```objc</p>

<h1>import &lt;AVFoundation/AVFoundation.h></h1>

<p>```</p>

<p>接着将如下属性添加到@end前面：</p>

<p><code>objc
@property (strong, nonatomic) AVAudioPlayer *audioPlayer;
@property (strong, nonatomic) SKAction *laughSound;
@property (strong, nonatomic) SKAction *owSound;
</code></p>

<p>然后在MyScene.m文件中做如下修改：</p>

<p>```objc
// Add at the bottom of your initWithSize: method
// Preload whack sound effect
self.laughSound = [SKAction playSoundFileNamed:@&ldquo;laugh.caf&rdquo; waitForCompletion:NO];
self.owSound = [SKAction playSoundFileNamed:@&ldquo;ow.caf&rdquo; waitForCompletion:NO];</p>

<p>NSURL <em>url = [[NSBundle mainBundle] URLForResource:@&ldquo;whack&rdquo; withExtension:@&ldquo;caf&rdquo;];
NSError </em>error = nil;
self.audioPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:url error:&amp;error];</p>

<p>if (!self.audioPlayer) {</p>

<pre><code>NSLog(@"Error creating player: %@", error);
</code></pre>

<p>}</p>

<p>[self.audioPlayer play];</p>

<p>// Add at bottom of popMole method, change the sequence action to:
SKAction *sequence = [SKAction sequence:@[easeMoveUp, setTappable, self.laughSound, self.laughAnimation, unsetTappable, easeMoveDown]];</p>

<p>// Add inside touchesBegan: method, change the sequence action to:
SKAction *sequence = [SKAction sequence:@[self.owSound, self.hitAnimation, easeMoveDown]];
```</p>

<p>搞定！编译并运行程序试试吧！</p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn2.raywenderlich.com/downloads/WhackAMoleSK2.zip">这里</a>。</p>

<p>至此，关于如何制作通用程序的介绍到此结束！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：制作一个通用程序 1]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/27/118-sprite-kit-tutorial-making-a-universal-app-part-1/"/>
    <updated>2013-10-27T20:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/27/118-sprite-kit-tutorial-making-a-universal-app-part-1</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/24.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/49695/sprite-kit-tutorial-making-a-universal-app-part-1"><code>Sprite Kit Tutorial: Making a Universal App: Part 1</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#msgs">UI规划：概述</a></li>
<li><a href="#msxj">UI规划：小结</a></li>
<li><a href="#ks">开始</a></li>
<li><a href="#wltj">纹理图集</a></li>
<li><a href="#bjsb">背景设置</a></li>
<li><a href="#asfz">鼹鼠的放置</a></li>
<li><a href="#tcas">弹出鼹鼠</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p>本文将介绍如何制作一个通用程序(打鼹鼠的游戏)——可以在iPhone和iPad上运行(包括retina显示的支持。)</p>

<p>学习本文之前，需要掌握以下知识：</p>

<p><a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p><a href="http://beyondvincent.com/blog/2013/10/16/115-spritekit-tutorial-animations-and-texture-atlases-1/"><code>Sprite Kit教程：动画和纹理图集 1</code></a>
<a href="http://beyondvincent.com/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2/"><code>Sprite Kit教程：动画和纹理图集 2</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<p><a href="http://beyondvincent.com/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites/"><code>Sprite Kit教程：如何拖放Sprites</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/44270/sprite-kit-tutorial-how-to-drag-and-drop-sprites"><code>Sprite Kit Tutorial: How To Drag and Drop Sprites</code></a></p>

<p>如果还没有看上面的这些文章(或者相关的知识)，建议你先去看一下。</p>

<p>本文会有两篇文章。第一篇，会先创建一个基本的游戏——可爱的小鼹鼠聪洞里面弹出来。为了让游戏在iPhone和iPad(支持retina显示)上看起来很优美，本文还花了大量的时间来考虑如何做游戏的美术规划和坐标。</p>

<h3><a id="msgs"></a>UI规划：概述</h3>

<p>我们希望程序可以在iPhone 3.5英寸，4英寸(iPhone 5)和iPad上良好的运行，所以在开始之前，我们需要认真的做好UI规划。</p>

<p>为了搞明白需要什么样的UI尺寸，我们先来看看下面的相关内容：</p>

<ul>
<li>Retina显示</li>
<li>4英寸iPhone显示</li>
<li>iPad和iPhone长宽比</li>
</ul>


<p>下面开始吧！</p>

<h4><code>Retina显示</code></h4>

<p>在iPhone中，non-retina和retina在显示上的最大区别就是retina的分辨率是non-retina的2倍。所以在non-retina上面分辨率为 480 * 320(landscape)，而retina则是960 * 640.</p>

<p><img src="/images/2013/10/26.jpg" alt="" /></p>

<p>同样iPad也分为non-retina和retina，它们的分辨率相差也为2倍，non-retina显示的分辨率是1024 * 768像素，而retina上面则是2048 * 1536像素！</p>

<p><img src="/images/2013/10/27.jpg" alt="" /></p>

<p>稍等，你可能在想：双倍分辨率岂不是打乱了所有已经写好的程序，例如iPhone上的480 * 320和iPad的1024 * 768？这是有可能的，除非是在Sprite Kit中设置尺寸或者坐标，此时实际上是在UIKit中进行设置，并且设置的尺寸单位叫做<code>points</code>，而不是像素(pixels)。</p>

<p>在non-retina显示上，无论是iPhone火iPad，一个point代表一个pixel，而在retina上面，一个point代表2个pixels。所以将位置设置为(10,10)point时，non-retina上将是(10,10)，而retina上则是(20,20)，所以它们依然会显示在相同的偏移量上。不错吧！</p>

<p>当使用苹果提供的控件或者Core Graphics时，苹果已经写好了相关代码，让它们在retina显示起来很好看。</p>

<p>唯一需要注意的就是关于使用的图片。比如在iPhone或iPad程序中又一个200 * 200d 图片。如果什么事情都不做的话，在retina上面会自动的将这个图片放大两倍——这看起来不是太好，因为我们并没有提供相关分辨率的图片。</p>

<p><img src="/images/2013/10/28.jpg" alt="" /></p>

<p>因此针对retina显示我们需要提供所有图片的另外一个版本，也就是说需要一个普通的版本，以及另外2倍分辨率的一个版本。如果将2倍分辨率图片命名为"@2x"后缀，那么当利用[SKSpriteNode spriteNodeWithImageNamed:&hellip;]或者类似的APIs加载sprite时，它会自动的将@2x图片加载到retina显示上。</p>

<p>所以在开发针对retina显示的Sprite Kit游戏时也很简单——只需要添加@2x的图片，基本上就搞定了。</p>

<h4><code>4英寸iPhone显示</code></h4>

<p>iPhone 5设备在屏幕上显示的分辨率比以前的更大了，对于游戏显示上来说，这非常的好。本文中的处理很简单，只需要将背景图片做一个扩展延伸即可。</p>

<p>iPhone 5的分辨率是1136 * 640——宽高比为16:9。用point来衡量的话则是568 * 320.</p>

<h3><code>iPad和iPhone的宽高比</code></h3>

<p>上面我们已经看到要处理retina显示很容易，但是要想创建一个通用的程序呢(可以运行在iPhone和iPad设备上)。</p>

<p>其实要想创建一个通用的程序还真有一个麻烦的事情——iPhone和iPad的宽高比不一样！</p>

<p>iPhone的比例是1.5(480 * 320 或960 * 640)，而iPad是1.33(768 * 1024或1536 * 2048)。</p>

<p>由于比例不同，如果一副能够在non-retina iPad(768×1024)上完整显示，你希望将其在iPhone上重用，那么不会完整的匹配上，如果将其缩放，按照宽度进行适配(乘以0.9375)，会得到720×960的尺寸，这样就会把高度剪切掉一部分。</p>

<p><img src="/images/2013/10/29.jpg" alt="" /></p>

<p>发生这种情况会让人比较烦恼，我们不仅需要处理背景图片的问题，不同的宽高比导致不同设备间使用相同的坐标比较困难。</p>

<p>下面是我了解到的一些对应的处理方法：</p>

<ul>
<li>在3.5英寸的iPhone retina显示屏幕正中间确定一个<code>可玩区域</code>。这样剩下的区域可以用一个背景图片来覆盖，不要让玩家关注这一剩下的区域。这样一来在不同设备间进行左边的转换和重用要非常方便。本文将利用这种方法。</li>
<li>让iPad显示内容的宽高比设置为跟iPhone一样：左右留出32points的边距，上下留出64point的边距，此时在正中间的区域就是1024×768 points。这样只要让游戏程序的内容显示在这1024×768的范围内，就可以在每个设备间对图片进行缩放了。</li>
<li>由于pixel和point是有区别的。那么我们就创建出iPad retina显示的图片(536×2048 px)，然后将该图片除以2，这样也就可以用于non-retina iPad显示了！</li>
</ul>


<h3><code>iOS 模拟器选项</code></h3>

<p>下面这些模拟器可以运行iOS 7：</p>

<ul>
<li>iPhone Retina (3.5-inch) – iPhone 4 和 4S</li>
<li>iPhone Retina (4-inch) – iPhone 5, 5C, 和 5S</li>
<li>iPad – iPad 1, 2, 和 Mini</li>
<li>iPad Retina – iPad 3 和 4</li>
</ul>


<p>注意：这里并没有non-retina iPhone——因为没有任何一台no-retina iPhone或iPod touch可以运行iOS 7。</p>

<p>另外由于Sprite Kit是在iOS 7中才引入的，所以就不用考虑no-retina iPhone或iPod touch设备了。</p>

<h3><a id="msxj"></a>UI规划：小结</h3>

<p>基于上面的一些讨论，下面是本文的相关计划：</p>

<ul>
<li>UI设计的范围(可玩区域)在960×640范围内，在retina iPhone(3.5英寸)中全屏显示，4英寸iPhone，iPad和retina iPad中居中显示。</li>
<li>可用的UI元素放置在纹理图集文件中。@2x表示用于iPad retina显示的图片。</li>
<li>由于需要全屏显示，所以背景图片是一个特例。创建一个1024x768 point尺寸的图片，这样可以完全显示在iPad中。并且这个图片可以缩放显示在3.5英寸的iPhone上，只不过背景图中的有些内容不能显示出来，但是这关系并不太大。</li>
<li>4英寸的iPhone将通过代码来使用<code>-568</code>的纹理图集，并将其<code>可玩区域</code>居中。</li>
<li>iPad和iPad retina通过代码使用<code>-ipad</code>的纹理图集，并将其坐标转换到<code>可玩区域</code>中，另外在使用适当的字体大小等。</li>
</ul>


<p>来这里可以下载到本文的<a href="http://cdn4.raywenderlich.com/downloads/WhackAMoleSKArt.zip">UI资源</a>。解压出下载到的文件，可以看到如下一些内容：</p>

<ul>
<li>在TextureAtlases中又3个文件夹。每个文件夹中的UI元素针对不同的显示(3.5英寸iPhone, 4英寸iPhone, 和 iPad)。</li>
<li>iPad纹理图集文件夹中包含的图片是针对non-retina和retina iPad的。</li>
<li>在foreground文件夹中，有两个前景图片(下部和上部的图片)。被分为了两部分，这样可以将鼹鼠放置在下部和上部，看起来鼹鼠就像到地下了一样。</li>
<li>4英寸的iPhone是另外一个特列。因此在这里另外构建了新的前景图，以利用上更多的空间。</li>
<li>在background文件夹中，虽然iPad的宽高比是1.33，但这里做的背景图宽高比为一半,这样做是因为背景图片基本上可以忽略不计（只是3个鼹鼠洞）。所以不值得在这上面耗费，因为只需要用小纹理的图片替代即可，在需要放大的时候放大一下。</li>
<li>在sprite文件夹中，所有的sprite尺寸都适合显示在960×640大小的可玩区域中。注意，这里有一个鼹鼠和两个相关动画(鼹鼠笑和被打)。</li>
</ul>


<p>上面搞了这么多，现在终于可以开始了！</p>

<h3><a id="ks"></a>开始</h3>

<p>打开Xcode，选择File > New > Project…，然后选中Sprite Kit Game并单击Next。将工程命名为WhackAMole，devices选中universal，接着再单击Next。选择一个路径来保存工程，然后单击Create。</p>

<p>当工程打开之后，应该能看到Project Navigator中的工程文件已经被选中了，如果没有选中，那么将其选中，然后在target中选中WhackAModle，以及选中顶部的General，在Deployment info里面可以看到一些设备朝向的勾选框。在这里我们的游戏是landscape的，所以勾选上iPhone和iPad的Landscape Left和Landscape Right。</p>

<p><img src="/images/2013/10/30.png" alt="" /></p>

<p>另外，为了让朝向正确，还需要对代码做一些修改。打开ViewController.m文件并用下面的viewWillLayoutSubviews:方法替换viewDidLoad方法：</p>

<p>```objc
&ndash; (void)viewWillLayoutSubviews
{</p>

<pre><code>[super viewWillLayoutSubviews];

// Configure the view.
SKView * skView = (SKView *)self.view;
if (!skView.scene) {
    skView.showsFPS = YES;
    skView.showsNodeCount = YES;

    // Create and configure the scene.
    SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
    scene.scaleMode = SKSceneScaleModeAspectFill;

    // Present the scene.
    [skView presentScene:scene];
}
</code></pre>

<p>}
```</p>

<p>为什么要这样做呢？默认情况下View Controller views是以竖直的方式加载，所以横屏模式下，当viewDidLoad被调用的时候不能保证尺寸是正确的，不过当viewWillLayoutSubviews被调用的时候view的size将是正确的。如上代码所示，大多数代码与viewdidLoad中的相同。需要关注的就是if语句中关于skView.scene的配置。当然在这里需要判断一下skView.scene是否已经存在(viewWillLayoutSubviews方法可能会被多次调用)。</p>

<h3><a id="wltj"></a>纹理图集</h3>

<p>纹理图集的配置非常简单。首选创建一个文件夹并且文件名已<code>.atlas</code>结尾。接着将那些UI元素拷贝到这个文件夹里面。然后在Xcode工程中添加这个文件夹即可！</p>

<p>简单吧！当在编译程序的时候，Xcode会把<code>.atlas</code>结尾的文件夹中的图片生成纹理图集。</p>

<p>注意：添加到<code>.atlas</code>文件夹中的图片尺寸不能超过2048×2048 pixels，否则会出错——2048×2048 pixels是自动生成纹理图集的最大尺寸。</p>

<p>下面看看具体如何做。找到之前下载的压缩文件，在压缩文件中有一个名为TextureAtlases的文件夹。这个文件夹中包含了3中设备类型的UI元素(iPad, iPhone, 和 WidescreeniPhone)。这些文件家中都包含有<code>.atlas</code>文件夹。我们将TextureAtlases文件夹拖至工程中，确保勾选上<code>Copy items into destination group’s folder (if needed)</code>。</p>

<p><img src="/images/2013/10/31.png" alt="" /></p>

<p>本文中为了让一切变得简单点，我们为每种类型的设备准备了一套纹理图集(iPhone 3.5-inch, iPhone 4-inch 和 iPads)。在iPhone 4英寸中可以重用iPhone3.5英寸中的一些纹理图集，</p>

<h3><a id="bjsb"></a>背景设置</h3>

<p>在开始修改scene中显示内容之前，我们需要添加一个宏以及一个helper方法。打开MyScene.m文件，并在文件的头部添加如下一行代码(在#import下面)：</p>

<p>```objc</p>

<h1>define IS_WIDESCREEN ( fabs( ( double )[ [ UIScreen mainScreen ] bounds ].size.height &ndash; ( double )568 ) &lt; DBL_EPSILON )</h1>

<p>```</p>

<p>上面这个宏可以判断程序是否允许在4英寸的屏幕中，该宏将被用在helper方法中，如果要了解上面宏的详细内容，<a href="http://stackoverflow.com/questions/12446990/how-to-detect-iphone-5-widescreen-devices">看这里</a>。</p>

<p>接着添加一个helper方法——为运行程序的设备获取正确的SKTextureAtla。这个方法接收一个文件名，并在文件名尾部添加一个正确的标示符，然后返回正确的一个SKTextureAtla。</p>

<p>```objc
&ndash; (SKTextureAtlas <em>)textureAtlasNamed:(NSString </em>)fileName
{</p>

<pre><code>if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone) {

    if (IS_WIDESCREEN) {
        // iPhone Retina 4-inch
        fileName = [NSString stringWithFormat:@"%@-568", fileName];
    } else {
        // iPhone Retina 3.5-inch
        fileName = fileName;
    }

} else {
    fileName = [NSString stringWithFormat:@"%@-ipad", fileName];
}

SKTextureAtlas *textureAtlas = [SKTextureAtlas atlasNamed:fileName];

return textureAtlas;
</code></pre>

<p>}
```</p>

<p>上面的代码做了些什么？</p>

<ul>
<li>首选判断设备是否为一台iPhone。</li>
<li>如果是一台iPhone，然后利用之前定义的IS_WIDESCREEN宏判断是否为4英寸显示屏。如果是的话，就在文件名尾部添加<code>-568</code>。</li>
<li>如果设备是iPad或iPad retina，那么在文件尾部添加<code>-ipad</code>。</li>
<li>根据文件名创建并返回一个新的SKTextureAtlas。</li>
</ul>


<p>接着找到initWithSize:方法。移除掉设置背景颜色和创建Hell World lable的6行代码，然后用下面的代码替换之：</p>

<p>```objc
// Add background
SKTextureAtlas <em>backgroundAtlas = [self textureAtlasNamed:@&ldquo;background&rdquo;];
SKSpriteNode </em>dirt = [SKSpriteNode spriteNodeWithTexture:[backgroundAtlas textureNamed:@&ldquo;bg_dirt&rdquo;]];
dirt.scale = 2.0;
dirt.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame));
dirt.zPosition = 0;
[self addChild:dirt];</p>

<p>// Add foreground
SKTextureAtlas <em>foregroundAtlas = [self textureAtlasNamed:@&ldquo;foreground&rdquo;];
SKSpriteNode </em>upper = [SKSpriteNode spriteNodeWithTexture:[foregroundAtlas textureNamed:@&ldquo;grass_upper&rdquo;]];
upper.anchorPoint = CGPointMake(0.5, 0.0);
upper.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame));
upper.zPosition = 1;
[self addChild:upper];</p>

<p>SKSpriteNode *lower = [SKSpriteNode spriteNodeWithTexture:[foregroundAtlas textureNamed:@&ldquo;grass_lower&rdquo;]];
lower.anchorPoint = CGPointMake(0.5, 1.0);
lower.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame));
lower.zPosition = 3;
[self addChild:lower];</p>

<p>// Add more here later&hellip;
```
我们来看看上面的代码都做了什么。</p>

<ul>
<li><code>Add background</code> 这部分代码使用之前的helper方法创建一个背景纹理图集。接着从背景纹理图集中构建一个dirt sprite。最后将其缩小2倍，并将其添加到scene正中间。将其缩小的目的是为了节省空间。</li>
<li><code>Add foreground</code> 这部分代码跟上面background中的十分相似，只不过这两个foreground sprite在同一个纹理图集中罢了。这里用了一种方便的方法来放置图片：设置anchor point(顶部图片设置middle/bottom，底部图片设置middle/top)。这种方法不需要做复杂的数学运算，就能在所有的设备上做出正确的显示。另外需要注意的是iPhone上的背景图片有一部分将不会显示出来，不过在这里并没有太大的影响。另外需要留意的是设置了图片的zPosition值，这样可以确保图片的正确排序。</li>
<li><code>SKSpriteNode的zPosition属性</code> 这个数学用来决定每个sprite在scene所处层次的位置。可以将其看做一个蛋糕，其中dirt sprite处于最底层，所以使用最小的一个值。添加别的层时增加相应的值，所以上半部分前景图设置为1，而下半部分设置为3，那么2呢？这个值是留给鼹鼠的——因为鼹鼠将出现在上部前景图上面，而在下部前景图后面。</li>
</ul>


<p>在运行程序之前，再做一点清理工作。找到touchesBegan:方法，并将其删除掉。</p>

<p>编译并运行程序，现在可以看到屏幕上显示出了背景图和前景图！并且在iPhone和iPad模拟器中运行，也能正确的显示！如下图所示：</p>

<p><img src="/images/2013/10/32.png" alt="" /></p>

<h3><a id="asfz"></a>鼹鼠的放置</h3>

<p>在这个游戏中，我们将添加3个鼹鼠到scene中——上图中的每个洞放一个。鼹鼠默认是在地下的，偶尔会弹出来，当弹出来时，我们可以打击它们。</p>

<p>首先我们先将鼹鼠放到每个洞中。为了确保鼹鼠位置的正确，最好先把鼹鼠显示在最上面，等调好位置之后，在将其放到后台去。</p>

<p>打开MyScene.h文件，并按照如下代码进行修改：</p>

<p>```objc</p>

<h1>import &lt;SpriteKit/SpriteKit.h></h1>

<p>@interface MyScene : SKScene</p>

<p>@property (strong, nonatomic) NSMutableArray <em>moles;
@property (strong, nonatomic) SKTexture </em>moleTexture;</p>

<p>@end
```
上面的代码添加了一个SKTexture和一个数组。创建鼹鼠的时候会用到SKTexture，创建好的每个鼹鼠会被添加到数组中，这样方便之后循环获得每个鼹鼠。</p>

<p>在添加鼹鼠之前，首先定位到MyScene.m的顶部，并将下面这行代码添加到<code>@implementation MyScene</code>之前。</p>

<p><code>objc
const float kMoleHoleOffset = 155.0;
</code></p>

<p>这是一个float类型的常量，用来对鼹鼠进行定位。</p>

<p>接着，将如下代码添加到initWithSize:方法最后面：</p>

<p>```objc
// Load sprites
self.moles = [[NSMutableArray alloc] init];
SKTextureAtlas *spriteAtlas = [self textureAtlasNamed:@&ldquo;sprites&rdquo;];
self.moleTexture = [spriteAtlas textureNamed:@&ldquo;mole_1.png&rdquo;];</p>

<p>float center = 240.0;</p>

<p>if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone &amp;&amp; IS_WIDESCREEN) {</p>

<pre><code>center = 284.0;
</code></pre>

<p>}</p>

<p>SKSpriteNode *mole1 = [SKSpriteNode spriteNodeWithTexture:self.moleTexture];
mole1.position = [self convertPoint:CGPointMake(center &ndash; kMoleHoleOffset, 85.0)];
mole1.zPosition = 999;
mole1.name = @&ldquo;Mole&rdquo;;
mole1.userData = [[NSMutableDictionary alloc] init];
[self addChild:mole1];
[self.moles addObject:mole1];</p>

<p>SKSpriteNode *mole2 = [SKSpriteNode spriteNodeWithTexture:self.moleTexture];
mole2.position = [self convertPoint:CGPointMake(center, 85.0)];
mole2.zPosition = 999;
mole2.name = @&ldquo;Mole&rdquo;;
mole2.userData = [[NSMutableDictionary alloc] init];
[self addChild:mole2];
[self.moles addObject:mole2];</p>

<p>SKSpriteNode *mole3 = [SKSpriteNode spriteNodeWithTexture:self.moleTexture];
mole3.position = [self convertPoint:CGPointMake(center + kMoleHoleOffset, 85.0)];
mole3.zPosition = 999;
mole3.name = @&ldquo;Mole&rdquo;;
mole3.userData = [[NSMutableDictionary alloc] init];
[self addChild:mole3];
[self.moles addObject:mole3];
```</p>

<p>上面的代码首先创建并加载一个SKTextureAtlas。接着根据sprite纹理图集中的mole_1.png 创建一个SKTexture，这将用来创建3个鼹鼠。Texture的重用性可以让Sprite Kit处理和渲染sprite更加高效。</p>

<p>接下来的这个值用来设置center。如果设备是4英寸的iPhone，那么这个center值将反映出额外的尺寸。</p>

<p>接着为每个鼹鼠创建对应的sprite，并将它们放置到scene中，还把它们添加到鼹鼠数组中。注意，每个鼹鼠的位置是利用center位置和文件头部定义的常量决定的。针对iPhone 3.5英寸的设备，鼹鼠位置处在480×320的可玩区域，而如何是iPad，相关位置需要做转换，所以下面写了一个helper方法convertPoint。</p>

<p>将下面这个方法添加到initWithSize:方法后面：</p>

<p>```objc
&ndash; (CGPoint)convertPoint:(CGPoint)point
{</p>

<pre><code>if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad) {
    return CGPointMake(32 + point.x*2, 64 + point.y*2);
} else {
    return point;
}
</code></pre>

<p>}
```</p>

<p>上面这个方法将可玩区域的point转换到iPad上适当的位置。记住：</p>

<ul>
<li>iPad的屏幕尺寸更大，所有的point都是双倍。</li>
<li>由于是将960×640的区域转换为1024×786的iPad区域，所以需要将左右边距分别设置为32point，而上下边距则各位64。</li>
</ul>


<p>就这样，上面的方法就是简单的给出iPad中正确的位置。</p>

<p>编译并运行程序，可以看到scene中有3个鼹鼠，它们的位置已经设置正确！你最好在iPhone 3.5-inch, iPhone 4-inch, iPad, 和 iPad Retina设备上都运行一下，以确保位置的正确。</p>

<p><img src="/images/2013/10/33.png" alt="" /></p>

<h3><a id="tcas"></a>弹出鼹鼠</h3>

<p>至此，我们已经把鼹鼠放置好了，下面我们添加一些代码让鼹鼠从洞里面跳出来吧。</p>

<p>首先，将这些sprite(鼹鼠)的zPosition从999设置为2，这样就可以把鼹鼠藏起来了。</p>

<p>然后，将下面的代码添加到update:方法中：</p>

<p>```objc
for (SKSpriteNode *mole in self.moles) {</p>

<pre><code>if (arc4random() % 3 == 0) {
    if (!mole.hasActions) {
        [self popMole:mole];
    }
}
</code></pre>

<p>}
```
需要注意的是每帧的显示都会调用update方法。该方法被调用的时候我们都会尝试着弹出一些鼹鼠。在代码中循环遍历处理了每个鼹鼠，并给每个鼹鼠1/3的机会从洞中弹出来。不过记住我们只能弹出那么还没有弹出来的鼹鼠——很简单的一个判断方法就是检查一下sprite的属性hasActions返回的值，如果还有action在运行，那么hasActions将返回YES。</p>

<p>接着，实现一下popMole方法：</p>

<p>```objc
&ndash; (void)popMole:(SKSpriteNode *)mole
{</p>

<pre><code>SKAction *easeMoveUp = [SKAction moveToY:mole.position.y + mole.size.height duration:0.2f];
easeMoveUp.timingMode = SKActionTimingEaseInEaseOut;
SKAction *easeMoveDown = [SKAction moveToY:mole.position.y duration:0.2f];
easeMoveDown.timingMode = SKActionTimingEaseInEaseOut;
SKAction *delay = [SKAction waitForDuration:0.5f];

SKAction *sequence = [SKAction sequence:@[easeMoveUp, delay, easeMoveDown]];
[mole runAction:sequence];
</code></pre>

<p>}
```</p>

<p>上面的代码使用了Sprite Kit中的一些action，让鼹鼠弹出洞来，并暂停半秒钟，然后在弹回去。我们来细看一下上面代码的意思：</p>

<ol>
<li>创建一个action来将鼹鼠沿着Y轴移动鼹鼠高度的距离，这样就能将鼹鼠正好放置到洞上面。</li>
<li>为了让移动行为看起来更自然一点，将action的timingMode设置为SKActionTimingEaseInEaseOut。这样可以让action在开始和结束时速度慢一点，这样鼹鼠看起来会有加速和减速的效果，看起来就会更自然一点了。</li>
<li>创建一个action将鼹鼠移回原处，这个action跟上一个类似，只不过使用鼹鼠当前Y轴的位置。</li>
<li>创建一个action，该action会让鼹鼠停留在洞口半秒钟。</li>
<li>按顺序运行这些action：move up，delay和move down。</li>
</ol>


<p>搞定！编译并运行程序，可以看到鼹鼠会从它们的洞口弹出来！</p>

<p><img src="/images/2013/10/34.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn3.raywenderlich.com/downloads/WhackAMoleSK1.zip">这里</a>。</p>

<p>下一篇文章<code>Sprite Kit教程：制作一个通用程序 2</code>中会给鼹鼠添加一些可爱的动画(笑和被击中)，并添加一个玩法——打击鼹鼠，并赚取点数，并添加一些音效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：如何拖放Sprites]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites/"/>
    <updated>2013-10-20T23:44:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/14.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/44270/sprite-kit-tutorial-how-to-drag-and-drop-sprites"><code>Sprite Kit Tutorial: How To Drag and Drop Sprites</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#ks">开始</a></li>
<li><a href="#xzjs">用触摸的方式选中sprite</a></li>
<li><a href="#ydjl">用触摸的方式移动sprite和layer</a></li>
<li><a href="#sssb">在Sprite Kit中如何使用手势识别</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p>本文中，你可以学到如下内容：</p>

<ul>
<li>利用触摸来拖放sprite的基本知识</li>
<li>利用触摸滚动view</li>
<li>How to keep coordinates straight in your head</li>
<li>如何在Sprite Kit中使用手势识别</li>
</ul>


<p>为了让本文有趣一点，这里提供了一些可爱的动物图片。</p>

<p>本文假设你已经了解了Sprite Kit的一些基本知识。如果还不了解的话，先看看下面的文章吧：</p>

<p><a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>下面我们就开始吧。</p>

<h3><a id="ks"></a>开始</h3>

<p>在实现触摸处理之前，我们先来创建一个基本的Sprite Kit工程，并在scene中显示出一些sprite(动物)和背景。</p>

<p>打开Xcode，选择<code>File\New Project\Application\SpriteKit Game</code>，然后单击<code>Next</code>。</p>

<p><img src="/images/2013/10/15.png" alt="" /></p>

<p>将工程命名为<code>DragDrop</code>，devices选择<code>iPhone</code>，然后单击<code>Next</code>，把工程保存到磁盘中。</p>

<p><img src="/images/2013/10/16.png" alt="" /></p>

<p>跟<a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>一样，我们希望这个程序只支持横屏显示(landscape)。所以在<code>Project Navigator</code>中选中<code>DragDrop</code>工程，然后选择<code>DragDrop</code> target，在弹出的画面中，只需要勾选上<code>Landscape Left</code>和<code>Landscape Right</code>。如下图所示：</p>

<p><img src="/images/2013/10/17.png" alt="" /></p>

<p>打开<code>ViewController.m</code>文件，并用下面的代码替换<code>viewDidLoad</code>方法(代码跟之前的一样)：</p>

<p>```objc
&ndash; (void)viewWillLayoutSubviews
{</p>

<pre><code>[super viewWillLayoutSubviews];

// Configure the view.
SKView * skView = (SKView *)self.view;
if (!skView.scene) {
  skView.showsFPS = YES;
  skView.showsNodeCount = YES;

  // Create and configure the scene.
  SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
  scene.scaleMode = SKSceneScaleModeAspectFill;

  // Present the scene.
  [skView presentScene:scene];
}
</code></pre>

<p>}
```</p>

<p>接着来这里下载本文需要用到的<a href="http://d1xzuxjlafny7l.cloudfront.net/downloads/DragDropImages.zip">图片资源</a>。下载并解压之后，将所有的文件拖到工程中，其中把<code>Copy items into destination group’s folder (if needed)</code>勾选上，然后单击<code>Finish</code>。</p>

<p><img src="/images/2013/10/18.png" alt="" /></p>

<p>完成上面的步骤之后，打开<code>MyScene.m</code>文件，并在<code>@implementation</code>上面添加一个class extension，并声明两个属性，如下所示：</p>

<p>```objc
@interface MyScene ()</p>

<p>@property (nonatomic, strong) SKSpriteNode <em>background;
@property (nonatomic, strong) SKSpriteNode </em>selectedNode;</p>

<p>@end
```</p>

<p>稍后会用到上面的这两个属性来存储背景图片，已经当前选中的node/sprite。接着在@interface前面添加如下这行代码：</p>

<p><code>objc
static NSString * const kAnimalNodeName = @"movable";
</code></p>

<p>稍后将会用这个字符串来标示可移动的node。接着找到<code>initWithSize:</code>方法，并用下面的代码替换里面的内容：</p>

<p>```objc
&ndash; (id)initWithSize:(CGSize)size {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 1) Loading the background
    _background = [SKSpriteNode spriteNodeWithImageNamed:@"blue-shooting-stars"];
    [_background setName:@"background"];
    [_background setAnchorPoint:CGPointZero];
    [self addChild:_background];

    // 2) Loading the images
    NSArray *imageNames = @[@"bird", @"cat", @"dog", @"turtle"];
    for(int i = 0; i &lt; [imageNames count]; ++i) {
      NSString *imageName = [imageNames objectAtIndex:i];
      SKSpriteNode *sprite = [SKSpriteNode spriteNodeWithImageNamed:imageName];
      [sprite setName:kAnimalNodeName];

      float offsetFraction = ((float)(i + 1)) / ([imageNames count] + 1);
      [sprite setPosition:CGPointMake(size.width * offsetFraction, size.height / 2)];
      [_background addChild:sprite];
    }
}

return self;
</code></pre>

<p>}
```</p>

<p>我们来看看上面的代码都干了什么。</p>

<p>1) 加载背景图片</p>

<p>上面方法中的第一部分代码是为scene加载背景图片(blue-shooting-stars.png)。并将该note的anchor设置为图片的左下角(0, 0)。</p>

<p>在Sprite Kit中，设置一个node的位置时，实际上是设置它的anchor。默认情况下，node的anchor被设置为node的正中间。在此，将anchor设置为左下角。</p>

<p>方法中，并没有设置背景图片的position，所以背景图的的位置默认为(0,0)。最终，图片的左下角位置是(0,0)，并向右边延伸。</p>

<p>2) 加载小动物</p>

<p>函数中接下来的代码是循环遍历列表中的图片，并将其加载到scene中。为了好的布局，其中各个node根据屏幕的长度来定位，另外还将这些node的名字设置为<code>kAnimalNodeName</code>。</p>

<p>之后将创建好的node添加到<code>_background</code>中。</p>

<p>OK！编译并运行程序，会看到屏幕中已经显示出了一些可爱的动物了。</p>

<p><img src="/images/2013/10/19.png" alt="" /></p>

<h3><a id="xzjs"></a>用触摸的方式选中sprite</h3>

<p>下面我们来实现一下根据用户当前触摸的位置判断出哪个sprite应该被选中。</p>

<p>用下面的代码替换<code>touchesBegan:withEvent:</code>：</p>

<p>```objc
&ndash;(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>UITouch *touch = [touches anyObject];
CGPoint positionInScene = [touch locationInNode:self];
[self selectNodeForTouch:positionInScene];
</code></pre>

<p>}
```</p>

<p>首先从touches set中获得touch。然后将touch的位置转换到一个指定node中的位置，上面的代码中使用了scene。让后将获得的方法传递给<code>selectNodeForTouch:</code>方法，该方法是一个新方法，下面我们就来看看这个方法的实现。</p>

<p>```objc
&ndash; (void)selectNodeForTouch:(CGPoint)touchLocation {
   //1
   SKSpriteNode <em>touchedNode = (SKSpriteNode </em>)[self nodeAtPoint:touchLocation];</p>

<pre><code>  //2
if(![_selectedNode isEqual:touchedNode]) {
    [_selectedNode removeAllActions];
    [_selectedNode runAction:[SKAction rotateToAngle:0.0f duration:0.1]];

    _selectedNode = touchedNode;
    //3
    if([[touchedNode name] isEqualToString:kAnimalNodeName]) {
        SKAction *sequence = [SKAction sequence:@[[SKAction rotateByAngle:degToRad(-4.0f) duration:0.1],
                                                  [SKAction rotateByAngle:0.0 duration:0.1],
                                                  [SKAction rotateByAngle:degToRad(4.0f) duration:0.1]]];
        [_selectedNode runAction:[SKAction repeatActionForever:sequence]];
    }
}
</code></pre>

<p>}
```</p>

<p>这是一个helper方法，它主要做三件不同的事情：</p>

<ol>
<li>通过scene(self)获得touchLocation位置对应的node。</li>
<li>获得匹配的node之后，检查一下这个node与上一次选中的node是否相同，如果相同的话，在这里直接就返回了。如果是一个新选中的node，或者还没有选中过，这个node会有一点小小的挪动动画，以此可以看出哪个node被选中了。不过在开始动画之前，需要移除当前已经选中node上的所有running actions，并在这个node上运行一个action：<code>rotateToAngle:duration:</code>。这样可以确保只有一个node在做动画，而另外的node恢复到原样。</li>
<li>这个if语句用来判断一下选中的node是否可以进行动画(只需要检查一下node的name就可以做出判断——还记得在<code>initWithSize:</code>方法中设置的这个属性值吗？)。如果选中的node可以做动画处理，那么就创建一个sequence action——是一个动画效果，就像在主屏幕中重排/删除程序那样的效果，然后在选中的node上运行这个sequence。为了避免动画运行完毕之后会停止，在这里运行了一个一直重复的action。</li>
</ol>


<p>下面将helper函数<code>degToRad</code>添加到文件的底部：</p>

<p>```objc
float degToRad(float degree) {</p>

<pre><code>return degree / 180.0f * M_PI;
</code></pre>

<p>}
```</p>

<p>由于Sprite Kit是利用弧度来做旋转效果的，所以上面这个方法将角度转换为弧度。</p>

<p>编译并运行程序，现在可以在屏幕上tap一个动物，当选中某个动物时，该动物会做出相应的动画效果，以表示被选中！</p>

<p><img src="/images/2013/10/20.png" alt="" /></p>

<h3><a id="ydjl"></a>用触摸的方式移动sprite和layer</h3>

<p>下面来看看如何移动这些动物！基本思路是这样的：实现<code>touchesMoved:withEvent:</code>方法，计算出距离上一次触摸移动了多远，如果有动物被选中，动物将被移动相应的距离，如果没有选中动物，那么就移动整个layer，这样用户可以从左向右的滚动layer。</p>

<p>在添加代码之前，我们先来探讨一下在Sprite Kit中，一个node是如何滚动的。</p>

<p>看看下面的图片：</p>

<p><img src="/images/2013/10/21.png" alt="" /></p>

<p>如上图所示，我们已经初始化了一个背景，所以背景的anchor点是(0, 0)，并且向右边扩展。黑色框中的区域表示当前的可视区域(window的大小)。</p>

<p>如果希望将图片往右边滚动100 points，可以通过将整个node往左边移动100 points，如第二幅图看到的效果一样。</p>

<p>当然，也可能希望不要移动太远。例如，不应该让layer可以往右边移动，否则会看到空白的点。</p>

<p>下面来看看相应的代码！将如下方法添加到文件的底部：</p>

<p>```objc
&ndash; (CGPoint)boundLayerPos:(CGPoint)newPos {</p>

<pre><code>CGSize winSize = self.size;
CGPoint retval = newPos;
retval.x = MIN(retval.x, 0);
retval.x = MAX(retval.x, -[_background size].width+ winSize.width);
retval.y = [self position].y;
return retval;
</code></pre>

<p>}</p>

<ul>
<li>(void)panForTranslation:(CGPoint)translation {
  CGPoint position = [<em>selectedNode position];
  if([[</em>selectedNode name] isEqualToString:kAnimalNodeName]) {
      [<em>selectedNode setPosition:CGPointMake(position.x + translation.x, position.y + translation.y)];
  } else {
      CGPoint newPos = CGPointMake(position.x + translation.x, position.y + translation.y);
      [</em>background setPosition:[self boundLayerPos:newPos]];
  }
}
```</li>
</ul>


<p>第一个方法<code>boundLayerPos:</code>是为了确保不会将layer移动到背景图片范围之外。在这里传入一个需要移动到的位置，然后该方法会对位置做适当的判断处理，以确保不会移动太远。</p>

<p>接着方法<code>panForTranslation:</code>首先判断一下_selectedNode是否为动物node，如果是的话，根据传入的参数来为node设置新的位置。如果是background layer，同样也会设置一个新的位置，只不过新的位置需要调用<code>boundLayerPos:</code>方法获得。</p>

<p>完成上面之后，可以实现<code>touchesMoved:withEvent:</code>方法了：</p>

<p>```objc
&ndash; (void)touchesMoved:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>UITouch *touch = [touches anyObject];
CGPoint positionInScene = [touch locationInNode:self];
CGPoint previousPosition = [touch previousLocationInNode:self];

CGPoint translation = CGPointMake(positionInScene.x - previousPosition.x, positionInScene.y - previousPosition.y);

[self panForTranslation:translation];
</code></pre>

<p>}
```</p>

<p>跟<code>touchesBegan:withEvent:</code>一样，先获得touch，然后将它的位置转换为scene中的相应位置。为了计算出移动的距离，需要上一次触摸的位置。</p>

<p>通过当前位置减去上一次的位置就可以计算出需要移动的距离了。最后调用<code>panForTransaltion:</code>方法，并将移动距离传入即可。</p>

<p>搞定！编译并运行程序，现在可以通过拖放的方式移动sprite(以及layer)了！</p>

<p><img src="/images/2013/10/22.png" alt="" /></p>

<h3><a id="sssb"></a>在Sprite Kit中如何使用手势识别</h3>

<p>在Sprite Kit中还可以使用手势识别来处理触摸！</p>

<p>手势识别可以识别不同的手势，如tap，double tap，swipe或pan。</p>

<p>通过手势识别，我们可以不用写大量的代码来识别不同的手势（如tap，double tap，swipe或pan），只需要创建一个手势识别对象并将其添加到view中，即可进行手势识别。当有手势发生，会有一个回调。</p>

<p>下面就来看看如何在Sprite Kit中使用手势识别。</p>

<p>首先，注释掉触摸处理方法：<code>touchesBegan:withEvent:</code>和<code>touchesMoved:withEvent:</code>(因为要使用不同的处理方法啦)。</p>

<p>然后添加如下方法：</p>

<p>```objc
&ndash; (void)didMoveToView:(SKView *)view {</p>

<pre><code>UIPanGestureRecognizer *gestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanFrom:)];
[[self view] addGestureRecognizer:gestureRecognizer];
</code></pre>

<p>}
```</p>

<p>当scene第一次显示出来时会调用这个方法。在上面的方法中创建了一个pan手势识别器，并用当前的scene来对其做初始化，另外还传入一个callback：<code>handlePanFrom:</code>。接着把这个手势识别器添加到scene中的view里面。</p>

<p>注意：可能你会问为什么要在这里添加识别器，而不是在scene的init方法中。答案很简单：<code>SKScene</code>有一个view属性，保存着SKView——该view用来显示scene，不过只有scene显示到屏幕中时这个属性才会被初始化，所以在init方法被调用时该属性是nil的。此处的<code>didMoveToView:</code>类似于UIKit中的<code>viewDidAppear:</code>，当scene显示出来时，<code>didMoveToView:</code>会被调用。</p>

<p>接着，将下面的代码添加到<code>MyScene.m</code>文件底部：</p>

<p>```objc
&ndash; (void)handlePanFrom:(UIPanGestureRecognizer *)recognizer {</p>

<pre><code>if (recognizer.state == UIGestureRecognizerStateBegan) {

    CGPoint touchLocation = [recognizer locationInView:recognizer.view];

    touchLocation = [self convertPointFromView:touchLocation];

    [self selectNodeForTouch:touchLocation];


} else if (recognizer.state == UIGestureRecognizerStateChanged) {

    CGPoint translation = [recognizer translationInView:recognizer.view];
    translation = CGPointMake(translation.x, -translation.y);
    [self panForTranslation:translation];
    [recognizer setTranslation:CGPointZero inView:recognizer.view];

} else if (recognizer.state == UIGestureRecognizerStateEnded) {

    if (![[_selectedNode name] isEqualToString:kAnimalNodeName]) {
        float scrollDuration = 0.2;
        CGPoint velocity = [recognizer velocityInView:recognizer.view];
        CGPoint pos = [_selectedNode position];
        CGPoint p = mult(velocity, scrollDuration);

        CGPoint newPos = CGPointMake(pos.x + p.x, pos.y + p.y);
        newPos = [self boundLayerPos:newPos];
        [_selectedNode removeAllActions];

        SKAction *moveTo = [SKAction moveTo:newPos duration:scrollDuration];
        [moveTo setTimingMode:SKActionTimingEaseOut];
        [_selectedNode runAction:moveTo];
    }

}
</code></pre>

<p>}
```</p>

<p>当手势开始、改变(例如用户持续drag)，以及结束时，上面这个callback函数都会被调用。该方法会进入不同的case，以处理不同的情况。</p>

<p>当手势开始时，将坐标系统转换为node坐标系(注意这里没有便捷的方法，只能这样处理)。然后电泳之前写的helper方法<code>selectNodeForTouch:</code>。</p>

<p>当手势发生改变时，需要计算出手势移动的量。还在手势识别器已经为我们存储了手势移动的累计量(translation)！不过考虑到效果的差异，我们需要在UIKit坐标系和Sprite Kit坐标系中对坐标进行转换。</p>

<p>平移(pan)之后，需要把手势识别器上的translation设置为0，否则该值会继续被累加。</p>

<p>当手势结束之后，上面的函数中有一些有趣的代码！UIPanGestureRecognizer可以为我们提供一个移动的速度。通过这个速度可以对node做一个动画——滑动一小点，这样用户可以对node做一个快速的摇动，就像table view上的那种效果一样。</p>

<p>所以，在这里包含的代码用来计算基于速度移动的一个point，然后运行一个moveTo action(为了更加好看，附带<code>SKActionTimingEaseOut</code>效果)。</p>

<p>接着添加如下一个方法到文件中：</p>

<p>```objc
CGPoint mult(const CGPoint v, const CGFloat s) {</p>

<pre><code>return CGPointMake(v.x*s, v.y*s);
</code></pre>

<p>}
```</p>

<p>上面这个方法是将滚动的时间乘以速度。</p>

<p>编译并运行程序，现在应该可以用手势识别器滑动和移动动物了。</p>

<p><img src="/images/2013/10/23.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn2.raywenderlich.com/downloads/DragDropSpriteKit.zip">这里</a>。</p>

<p>至此，你应该知道如何在Sprite Kit程序中使用touch来移动node，以及如何在Sprite Kit中使用手势识别器。</p>

<p>现在，你也可以尝试利用别的手势识别器对上面的工程做扩展处理，例如pinch或rotate手势识别器——可以让猫长大哦！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：动画和纹理图集 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2/"/>
    <updated>2013-10-16T23:40:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/3.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>创建一个工程</li>
<li>纹理图集和熊</li>
<li>一个简单的动画</li>
<li><a href="#gbfx">改变动画运动的方向</a></li>
<li><a href="#ydx">在屏幕上让熊移动</a></li>
<li><a href="#hqhc">何去何从?</a></li>
</ul>


<h3><a id="gbfx"></a>改变动画运动的方向</h3>

<p>看起来不错哦！下面我们就来看看如何通过触摸屏幕上的点来控制熊的运动方向。在<code>MyScene.m</code>文件中做如下改动：</p>

<p>```objc
// Add these new methods
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{</p>

<pre><code>CGPoint location = [[touches anyObject] locationInNode:self];
CGFloat multiplierForDirection;

if (location.x &lt;= CGRectGetMidX(self.frame)) {
    //walk left
    multiplierForDirection = 1;
} else {
    //walk right
    multiplierForDirection = -1;
}

_bear.xScale = fabs(_bear.xScale) * multiplierForDirection;
[self walkingBear];
</code></pre>

<p>}</p>

<p>&ndash;(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{  <br/>
}
```</p>

<p>上面的代码会根据tap的位置，让<code>touchesEnded</code>方法判断tap处于屏幕正中间的左边还是右边。通过该方法，决定熊的朝向。熊的方向是通过Sprite Kit来改变的(通过负值乘以xScale就可以让熊朝向左边。)</p>

<p>编译并运行程序，一切正常的话，当你在屏幕上点击时，会发现熊的朝向发生了改变。</p>

<p><img src="/images/2013/10/12.png" alt="" /></p>

<h3><a id="ydx"></a>在屏幕上让熊移动</h3>

<p>下面我们让熊可以移动到屏幕的各个位置。</p>

<p>在<code>MyScene.m</code>文件中做如下改动：</p>

<p>```objc
// Comment out the call to start the bear walking
//[self walkingBear];</p>

<p>&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{</p>

<pre><code>//Stuff from below!
</code></pre>

<p>}</p>

<p>&ndash;(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{  <br/>
}</p>

<p>//add this method
&ndash;(void)bearMoveEnded
{</p>

<pre><code>[_bear removeAllActions];
</code></pre>

<p>}
```</p>

<p>如上所示，移除了<code>touchesEnded</code>方法中的所有代码。下面我们一步一步的往里面添加代码。</p>

<p>当想要停止动画的时可以调用方法<code>bearMoveEnded</code>。</p>

<p>下面就从<code>touchesEnded</code>方法开始吧：</p>

<p><code>1) 确定触摸的位置并定义一个变量代表熊的朝向</code></p>

<p><code>objc
CGPoint location = [[touches anyObject] locationInNode:self];
CGFloat multiplierForDirection;
</code></p>

<p>如上代码，利用常见的一个方法将触摸的位置转换为node坐标系中的位置。</p>

<p><code>2) 设置速度</code></p>

<p><code>objc
CGSize screenSize = self.frame.size;
float bearVelocity = screenSize.width / 3.0;
</code></p>

<p>如上，定义了熊移动的速度。可知熊从移动长度为屏幕宽度这么长时，需要3秒钟。由于不同设备的屏幕宽度可能会不同，所以在这里使用了self.frame.size，所以熊的速度应该是屏幕宽度/3秒。</p>

<p><code>3) 计算出熊在X和Y轴中移动的量</code></p>

<p><code>objc
 CGPoint moveDifference = CGPointMake(location.x - _bear.position.x, location.y - _bear.position.y);
</code></p>

<p>通过简单的利用触摸位置减去熊的位置，计算出熊在X和Y轴上应该移动的距离。</p>

<p><code>4) 计算出实际的移动距离</code></p>

<p><code>objc
float distanceToMove = sqrtf(moveDifference.x * moveDifference.x + moveDifference.y * moveDifference.y);
</code></p>

<p>上面的代码是计算出熊实际移动的直线距离(一个直角三角形的斜边：熊当前的位置和触摸位置)。关于游戏中涉及到的数学知识可以看看这本书：<a href="http://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1">Trigonometry for Game Programming</a>。</p>

<p><code>5) 计算出移动实际距离所需要花费的时间</code></p>

<p><code>objc
float moveDuration = distanceToMove / bearVelocity;
</code></p>

<p>通过移动的实际距离除以移动速度计算出需要花费的时间。</p>

<p><code>6) 需要的话对动画做翻转(Flip)处理</code></p>

<p>```objc
if (moveDifference.x &lt; 0) {</p>

<pre><code>multiplierForDirection = 1;
</code></pre>

<p>} else {</p>

<pre><code>multiplierForDirection = -1;
</code></pre>

<p>}
<em>bear.xScale = fabs(</em>bear.xScale) * multiplierForDirection;
```</p>

<p>上面的代码：确定熊往左还是往右移动。如果小于0，则往左移动，否则往右移动。</p>

<p>在这里，你的第一直觉可能是利用图片编辑器创建并使用对应另一个方向的图片。不过，之前我们学习过了如果通过乘法来改变sprite的xScale，进而改变sprite的方向。</p>

<p><code>7) 运行一些action</code></p>

<p>```objc
if ([_bear actionForKey:@&ldquo;bearMoving&rdquo;]) {</p>

<pre><code>//stop just the moving to a new location, but leave the walking legs movement running
[_bear removeActionForKey:@"bearMoving"];
</code></pre>

<p>} //1</p>

<p>if (![_bear actionForKey:@&ldquo;walkingInPlaceBear&rdquo;]) {</p>

<pre><code>//if legs are not moving go ahead and start them
[self walkingBear];  //start the bear walking
</code></pre>

<p>} //2</p>

<p>SKAction <em>moveAction = [SKAction moveTo:location duration:moveDuration];  //3
SKAction </em>doneAction = [SKAction runBlock:(dispatch_block_t)^() {</p>

<pre><code>    NSLog(@"Animation Completed");
    [self bearMoveEnded];
</code></pre>

<p>}]; //4</p>

<p>SKAction *moveActionWithDone = [SKAction sequence:@[moveAction,doneAction]]; //5</p>

<p>[_bear runAction:moveActionWithDone withKey:@&ldquo;bearMoving&rdquo;]; //6
```</p>

<ol>
<li>停止已有的移动action(因为要准备告诉熊移动到别的地方)。这里使用的key可以开始和停止以此命名的动画的运行。</li>
<li>如果熊还没有准备移动腿，那么就让熊的腿开始移动，否则它该如何走到新的位置呢。这里使用了我们之前使用过的方法，这个方法可以确保不启动一个已经运行着的动画(以key命名)。</li>
<li>创建一个移动action，并制定移动到何处，以及需要花费的时间。</li>
<li>创建一个done action，当熊到达目的地后，该action利用一个block调用一个方法来停止动画。</li>
<li>将上面的两个action设置为一个顺序action链，就是说让这两个action按照先后顺序运行(第一个运行完之后，再运行第二个)。</li>
<li>让熊开始运行action，并制定一个key为："bearMoving"。记住，这里的key用来判断熊是否需要移动到新的位置。</li>
</ol>


<p>注意：Sprite Kit支持两种action：<code>sequential</code>和<code>grouped</code>。<code>sequential</code> action表示action按照顺序执行。如果想要action同时运行，那么就使用<code>grouped</code>。</p>

<p>当然，也可以在sequential action中包含grouped action，反之亦然。更多相关内容请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043">Sprite Kit Programming Guide</a>中的<code>Adding Actions to Nodes</code>章节。</p>

<p>当动画执行完毕之后，<code>bearMoveEnded</code>会被调用，所有的动画都将被停止，并等待下一个移动方位。</p>

<p>搞定了！</p>

<p>现在编译并运行程序，一切正常的话，那么当点击屏幕时，熊会跟着移动。</p>

<p><img src="/images/2013/10/13.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从?</h3>

<p>这里是本文涉及到的<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/AnimatedBear.zip">工程示例</a>。</p>

<p>下面这些想法可以让动画更加有趣：</p>

<ul>
<li>尝试在方法<code>walkingBear</code>中增加或者减慢运动的速度，看看效果</li>
<li>试着在屏幕上同时显示多个熊。提示：创建多个sprite node，并赋予action。</li>
</ul>


<p>至此，你应该已经知道如何使用动画了。</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>

<p>……Sprite Kit教程：动画和纹理图集 2 结束……</p>
]]></content>
  </entry>
  
</feed>
