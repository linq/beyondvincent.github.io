<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS翻译 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iosfan-yi/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2013-09-29T00:26:14+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"/>
    <updated>2013-09-29T00:06:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/10.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Sprite Kit的优点和缺点</li>
<li>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</li>
<li>Hello, Sprite Kit!</li>
<li><a href="#hpxs">横屏显示</a></li>
<li><a href="#ydgs">移动怪兽</a></li>
<li><a href="#fspd">发射炮弹</a></li>
<li>碰撞检测: 概述</li>
<li>碰撞检测: 实现</li>
<li>收尾</li>
<li>何去何从?</li>
</ul>


<h3><a id="hpxs"></a>横屏显示</h3>

<p>首先，在Project Navigator中单击SpriteKitSimpleGame工程以打开target设置，选中SpriteKitSimpleGame target。然后在<code>Deployment Info</code>中，不要勾选<code>Portrait</code>，只选中<code>Landscape</code>和<code>Landscape Right</code>，如下所示：</p>

<p><img src="/images/2013/09/11.png"></p>

<p>编译并运行工程，会看到如下运行画面：</p>

<p><img src="/images/2013/09/12.png"></p>

<p>下面我们试着添加一个忍者(ninja)。</p>

<p>首先，下载此<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2015/01/SpriteKitSimpleGameResources.zip">工程的资源文件</a>，并将其拖拽到Xcode工程中。确保勾选上<code>“Copy items into destination group’s folder (if needed)”</code>和<code>SpriteKitSimpleGame target</code>。</p>

<p>接着，打开<code>MyScene.m</code>，并用下面的内容替换之：</p>

<p>```objc</p>

<h1>import &ldquo;MyScene.h&rdquo;</h1>

<p>// 1
@interface MyScene ()
@property (nonatomic) SKSpriteNode * player;
@end</p>

<p>@implementation MyScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 2
    NSLog(@"Size: %@", NSStringFromCGSize(size));

    // 3
    self.backgroundColor = [SKColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];

    // 4
    self.player = [SKSpriteNode spriteNodeWithImageNamed:@"player"];
    self.player.position = CGPointMake(100, 100);
    [self addChild:self.player];

}
return self;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>我们来看看上面的代码。</p>

<ol>
<li>为了给player(例如忍者)声明一个私有变量，在这里创建了一个私有的interface，之后可以把这个私有变量添加到场景中。</li>
<li>在这里打印出了场景的size，至于什么原因很快你就会看到了。</li>
<li>在Sprite Kit中设置一个场景的背景色非常简单——只需要设置<code>backgroundColor</code>属性，在这里将其设置位白色。</li>
<li>在Sprite Kit场景中添加一个精灵同样非常简单，只需要使用<code>spriteNodeWithImageNamed</code>方法，并把一副图片的名称传递进去就可以创建一个精灵。接着设置一下精灵的位置，然后调用<code>addChild</code>方法将该精灵添加到场景中。在代码中将忍者的位置设置为<code>(100, 100)</code>，该位置是从屏幕的左下角到右上角计算的。</li>
</ol>


<p>编译并运行，看看效果如何…</p>

<p><img src="/images/2013/09/13.png"></p>

<p>呀！屏幕是白色的，并没有看到忍者。这是为什么呢？你可能在想设计之初就是这样的，实际上这里有一个问题。</p>

<p>如果你观察一下控制台输出的内容，会看到如下内容</p>

<p><code>objc
SpriteKitSimpleGame[3139:907] Size: {320, 568}
</code>
可能你会认为场景的宽度是320，高度则是568——实际上刚好相反!</p>

<p>我们来看看具体发生了什么：定位到<code>ViewController.m</code>的<code>viewDidLoad</code>方法：</p>

<p>```objc
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];

// Configure the view.
SKView * skView = (SKView *)self.view;
skView.showsFPS = YES;
skView.showsNodeCount = YES;

// Create and configure the scene.
SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
scene.scaleMode = SKSceneScaleModeAspectFill;

// Present the scene.
[skView presentScene:scene];
</code></pre>

<p>}
```</p>

<p>上面的代码中利用view的边界size创建了场景。不过请注意，当<code>viewDidLoad</code>被调用的时候，在这之前view已经被添加到view层次结构中了，因此它还没有响应出布局的改变。所以view的边界可能还不正确，进而在viewDidLoad中并不是开启场景的最佳时机。</p>

<p><code>提醒</code>：要想了解更多相关内容，请看由Rob Mayoff带来的<a href="http://stackoverflow.com/questions/9539676/uiviewcontroller-returns-invalid-frame">最佳解释</a>。</p>

<p>解决方法就是将开启场景代码的过程再靠后一点。用下面的代码替换<code>viewDidLoad</code>:
```objc
&ndash; (void)viewWillLayoutSubviews
{</p>

<pre><code>[super viewWillLayoutSubviews];

// Configure the view.
SKView * skView = (SKView *)self.view;
if (!skView.scene) {
  skView.showsFPS = YES;
  skView.showsNodeCount = YES;

  // Create and configure the scene.
  SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
  scene.scaleMode = SKSceneScaleModeAspectFill;

  // Present the scene.
  [skView presentScene:scene];
}
</code></pre>

<p>}
```</p>

<p>编译并运行程序，可以看到，忍者已经显示在屏幕中了！</p>

<p><img src="/images/2013/09/14.png"></p>

<p>如上图所示，可以看到坐标系已经正确了，如果想要把忍者的位置设置为其中间靠左，那么在<code>MyScene.m</code>中用下面的代码来替换设置忍者位置相关的代码：</p>

<p>```objc</p>

<p>self.player.position = CGPointMake(self.player.size.width/2, self.frame.size.height/2);</p>

<p>```</p>

<h3><a id="ydgs"></a>移动怪兽</h3>

<p>接下来，我们希望在场景中添加一些怪兽，让忍者进行攻击。为了让游戏更有趣一点，希望怪兽能够移动——否则没有太大的挑战！OK，我们就在屏幕的右边，离屏的方式创建怪兽，并给怪兽设置一个动作：告诉它们往左边移动。</p>

<p>将下面这个方法添加到<code>MyScene.m</code>中：</p>

<p>```objc
&ndash; (void)addMonster {</p>

<pre><code>// Create sprite
SKSpriteNode * monster = [SKSpriteNode spriteNodeWithImageNamed:@"monster"];

// Determine where to spawn the monster along the Y axis
int minY = monster.size.height / 2;
int maxY = self.frame.size.height - monster.size.height / 2;
int rangeY = maxY - minY;
int actualY = (arc4random() % rangeY) + minY;

// Create the monster slightly off-screen along the right edge,
// and along a random position along the Y axis as calculated above
monster.position = CGPointMake(self.frame.size.width + monster.size.width/2, actualY);
[self addChild:monster];

// Determine speed of the monster
int minDuration = 2.0;
int maxDuration = 4.0;
int rangeDuration = maxDuration - minDuration;
int actualDuration = (arc4random() % rangeDuration) + minDuration;

// Create the actions
SKAction * actionMove = [SKAction moveTo:CGPointMake(-monster.size.width/2, actualY) duration:actualDuration];
SKAction * actionMoveDone = [SKAction removeFromParent];
[monster runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
</code></pre>

<p>}
```</p>

<p>在上面，我尽量让代码看起来容易理解。首先是通过一个简单的计算，确定怪兽出现的位置，并将该位置设置给怪兽，然后将其添加到场景中。</p>

<p>接着是添加动作(actions)。跟Cocos2D一样，Sprite Kit同样提供了很多方便的内置动作，例如移动动作、旋转动作、淡入淡出动作、动画动作等。在这里我们只需要在怪兽上使用3中动作即可：</p>

<ul>
<li><code>moveTo:duration:</code>使用这个动作可以把怪兽从屏幕外边移动到左边。移动过程中，我们可以指定移动持续的时间，上面的代码中，指定为2-4秒之间的一个随机数。</li>
<li><code>removeFromParent:</code>在Sprite Kit中，可以使用该方法，方便的将某个node从parent中移除，能有效的从场景中删除某个对象。此处，将不再需要显示的怪兽从场景中移除。这个功能非常的重要，否则当有源源不断的怪兽出现在场景中时，会耗尽设备的所有资源。</li>
<li><code>sequence:</code>sequence动作可以一次性就把一系列动作串联起来按照一定顺序执行。通过该方法我们就能让<code>moveTo:</code>方法先执行，当完成之后，在执行<code>removeFromParent:</code>动作。</li>
</ul>


<p>最后，我们需要做的事情就是调用上面这个方法<code>addMonster</code>，以实际的创建出怪兽！为了更加好玩，下面我们来让怪兽随着时间持续的出现在屏幕中。</p>

<p>在Sprite Kit中，并不能像Cocos2D一样，可以配置每隔X秒就回调一下update方法。同样也不支持将从上次更新到目前为止的时间差传入方法中。(非常令人吃惊！)。</p>

<p>不过，我们可以通过一小段代码来仿造这种行为。首先在<code>MyScene.m</code>的private interface中添加如下属性：</p>

<p><code>objc
@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;
@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;
</code>
通过<code>lastSpawnTimeInterval</code>可以记录着最近出现怪兽时的时间，而<code>lastUpdateTimeInterval</code>可以记录着上次更新时的时间。</p>

<p>接着，我们写一个方法，该方法在画面每一帧更新的时候都会被调用。记住，该方法不会被自动调用——需要另外写一个方法来调用它：</p>

<p>```objc
&ndash; (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {</p>

<pre><code>self.lastSpawnTimeInterval += timeSinceLast;
if (self.lastSpawnTimeInterval &gt; 1) {
    self.lastSpawnTimeInterval = 0;
    [self addMonster];
}
</code></pre>

<p>}
```</p>

<p>上面的代码中简单的将上次更新(update调用)的时间追加到<code>self.lastSpawnTimeInterval</code>中。一旦该时间大于1秒，就在场景中新增一个怪兽，并将<code>lastSpawnTimeInterval</code>重置。</p>

<p>最后，添加如下方法来调用上面的方法：</p>

<p>```objc
&ndash; (void)update:(NSTimeInterval)currentTime {</p>

<pre><code>// Handle time delta.
// If we drop below 60fps, we still want everything to move the same distance.
CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;
self.lastUpdateTimeInterval = currentTime;
if (timeSinceLast &gt; 1) { // more than a second since last update
    timeSinceLast = 1.0 / 60.0;
    self.lastUpdateTimeInterval = currentTime;
}

[self updateWithTimeSinceLastUpdate:timeSinceLast];
</code></pre>

<p>}
```</p>

<p>Sprite Kit在显示每帧时都会调用上面的<code>update:</code>方法。</p>

<p>上面的代码其实是来自苹果提供的Adventure示例中。该方法会传入当前的时间，在其中，会做一些计算，以确定出上一帧更新的时间。注意，在代码中做了一些合理性的检查，以避免从上一帧更新到现在已经过去了大量时间，并且将间隔重置为1/60秒，避免出现奇怪的行为。</p>

<p>现在编译并运行程序，可以看到许多怪兽从左边移动到屏幕右边并消失。</p>

<p><img src="/images/2013/09/15.png"></p>

<h3><a id="fspd"></a>发射炮弹</h3>

<p>现在我们开始给忍者添加一些动作，首先从发射炮弹开始！实际上有多种方法来实现炮弹的发射，不过，在这里要实现的方法时当用户tap屏幕时，从忍者的方位到tap的方位发射一颗炮弹。</p>

<p>由于本文是针对初级开发者，所以在这里我使用<code>moveTo:</code>动作来实现，不过这需要做一点点的数学运算——因为<code>moveTo:</code>方法需要指定炮弹的目的地，但是又不能直接使用touch point(因为touch point仅仅代表需要发射的方向)。实际上我们需要让炮弹穿过touch point，直到炮弹在屏幕中消失。</p>

<p>如下图，演示了上面的相关内容：</p>

<p><img src="/images/2013/09/16.jpg"></p>

<p>如图所示，我们可以通过origin point到touch point得到一个小的三角形。我们要做的就是根据这个小三角形的比例创建出一个大的三角形——而你知道你想要的一个端点是离开屏幕的地方。</p>

<p>为了做这个计算，如果有一些基本的矢量方法可供调用(例如矢量的加减法)，那么会非常有帮助，但很不幸的时Sprite Kit并没有提供相关方法，所以，我们必须自己实现。</p>

<p>不过很幸运的时这非常容易实现。将下面的方法添加到文件的顶部(implementation之前)：</p>

<p>```objc
static inline CGPoint rwAdd(CGPoint a, CGPoint b) {</p>

<pre><code>return CGPointMake(a.x + b.x, a.y + b.y);
</code></pre>

<p>}</p>

<p>static inline CGPoint rwSub(CGPoint a, CGPoint b) {</p>

<pre><code>return CGPointMake(a.x - b.x, a.y - b.y);
</code></pre>

<p>}</p>

<p>static inline CGPoint rwMult(CGPoint a, float b) {</p>

<pre><code>return CGPointMake(a.x * b, a.y * b);
</code></pre>

<p>}</p>

<p>static inline float rwLength(CGPoint a) {</p>

<pre><code>return sqrtf(a.x * a.x + a.y * a.y);
</code></pre>

<p>}</p>

<p>// Makes a vector have a length of 1
static inline CGPoint rwNormalize(CGPoint a) {</p>

<pre><code>float length = rwLength(a);
return CGPointMake(a.x / length, a.y / length);
</code></pre>

<p>}
```
上面实现了一些标准的矢量函数。如果你看得不是太明白，请看这里关于<a href="http://www.mathsisfun.com/algebra/vectors.html">矢量方法的解释</a>。</p>

<p>接着，在文件中添加一个新的方法：</p>

<p>```objc
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>// 1 - Choose one of the touches to work with
UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];

// 2 - Set up initial location of projectile
SKSpriteNode * projectile = [SKSpriteNode spriteNodeWithImageNamed:@"projectile"];
projectile.position = self.player.position;

// 3- Determine offset of location to projectile
CGPoint offset = rwSub(location, projectile.position);

// 4 - Bail out if you are shooting down or backwards
if (offset.x &lt;= 0) return;

// 5 - OK to add now - we've double checked position
[self addChild:projectile];

// 6 - Get the direction of where to shoot
CGPoint direction = rwNormalize(offset);

// 7 - Make it shoot far enough to be guaranteed off screen
CGPoint shootAmount = rwMult(direction, 1000);

// 8 - Add the shoot amount to the current position       
CGPoint realDest = rwAdd(shootAmount, projectile.position);

// 9 - Create the actions
float velocity = 480.0/1.0;
float realMoveDuration = self.size.width / velocity;
SKAction * actionMove = [SKAction moveTo:realDest duration:realMoveDuration];
SKAction * actionMoveDone = [SKAction removeFromParent];
[projectile runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
</code></pre>

<p>}
```</p>

<p>上面的代码中做了很多事情，我们来详细看看。</p>

<ol>
<li>SpriteKit为我们做了很棒的一件事情就是它提供了一个UITouch的category，该category中有<code>locationInNode:</code>和<code>previousLocationInNode:</code>方法。这两个方法可以帮助我们定位到在SKNode内部坐标系中touch的坐标位置。这样一来，我们就可以寻得到在场景坐标系中touch的位置。</li>
<li>然后创建一个炮弹，并将其放置到忍者的地方，以当做其开始位置。注意，现在还没有将其添加到场景中，因为还需要先做一个合理性的检查——该游戏不允许忍者向后发射。</li>
<li>接着利用touch位置减去炮弹的当前位置，这样就能获得一个从当前位置到touch位置的矢量。</li>
<li>如果X值小于0，就意味着忍者将要向后发射，由于在这里的游戏中是不允许的(真实中的忍者是不回头的！)，所以就return。</li>
<li>否则，将可以将炮弹添加到场景中。</li>
<li>调用方法<code>rwNormalize</code>，将offset转换为一个单位矢量(长度为1)。这样做可以让在相同方向上，根据确定的长度来构建一个矢量更加容易（因为1 * length = length）。</li>
<li>在单位矢量的方向上乘以1000。为什么是1000呢？因为着肯定足够超过屏幕边缘了 :]</li>
<li>将上一步中计算得到的位置与炮弹的位置相加，以获得炮弹最终结束的位置。</li>
<li>最后，参照之前构建怪物时的方法，创建<code>moveTo:</code>和<code>removeFromParent:</code>两个actions。</li>
</ol>


<p>编译并允许程序，现在忍者可以发射炮弹了！</p>

<p><img src="/images/2013/09/17.png"></p>

<p>……Sprite Kit初级教程(2)结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 1 ]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"/>
    <updated>2013-09-26T11:45:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/6.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><code>Sprite Kit的优点和缺点</code></li>
<li><code>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</code></li>
<li><code>Hello, Sprite Kit!</code></li>
<li>横屏显示</li>
<li>移动怪兽</li>
<li>发射炮弹</li>
<li>碰撞检测: 概述</li>
<li>碰撞检测: 实现</li>
<li>收尾</li>
<li>何去何从?</li>
</ul>


<p>在iOS 7中内置了一个新的Sprite Kit框架，该框架主要用来开发2D游戏。目前已经支持的内容包括：精灵、很酷的特效(例如视频、滤镜和遮罩)，并且还集成了物理库等许多东西。</p>

<p>iOS 7中附带了一个非常棒的Sprite Kit示例工程，名字叫做Adventure。不过这个示例工程稍微有点复杂，不太适合初学者。本文的目的就是做一个关于Sprite Kit使用的初级教程。</p>

<p>通过本文，你可以从头到尾的学习到如何为你的iPhone创建一个简单又有趣的2D游戏。如果你看过我们之前的教程:<a href="http://www.raywenderlich.com/25736/how-to-make-a-simple-iphone-game-with-cocos2d-2-x-tutorial">Simple Cocos2D game教程</a>，你会发现非常的相似。</p>

<p>在开始之前，请确保已经安装了最新版本的Xcode(5.X)，里面支持Sprite Kit以及iOS 7。</p>

<h3><strong> Sprite Kit的优点和缺点</strong></h3>

<p>首先，我想指出在iOS中开发2D游戏Sprite Kit并不是唯一的选择，下面我们先来看看Sprite Kit的一些优点和缺点。</p>

<p>Sprite Kit的优点：</p>

<p> 1、它是内置到iOS中的，因此并不需要下载额外的库或者其它一些外部依赖。并且它是由苹果开发的，所以对于它的支持和更新我们可以放心。</p>

<p> 2、它内置的工具支持纹理和粒子。</p>

<p> 3、它可以让你做一些其它框架很难做到的事情，例如把视频当做精灵一样处理，或者使用很酷的图形效果和遮罩。</p>

<p>Sprite Kit的缺点：</p>

<p> 1、如果使用了Sprite Kit，那么你将被iOS生态圈所绑架，导致你无法很容易对你开发的游戏移植到Android上。</p>

<p> 2、Sprite Kit现在还处于初始阶段，此时提供的功能还没有别的框架丰富，例如Cocos2D。最缺的东西应该是暂不支持写自定义的OpenGL代码。</p>

<h3><strong> Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</strong></h3>

<p>此时，你可能在想“我该选择使用哪个2D框架呢？”</p>

<p>这取决于你的实际情况，下面是我的一些想法：</p>

<p> 1、如果你是一个初学者，并且只关注于iOS，那么就使用内置的Sprite Kit吧，它非常容易学习，并且完全可以把工作做好。</p>

<p> 2、如果需要写自己的OpenGL代码，那么还是使用Cocos2D，或者其它框架吧，目前Sprite Kit并不支持自定义OpenGL代码。</p>

<p> 3、如果要进行跨平台开发，那么选择Cocos2D-X或者Unity。Cocos2D-X非常出色，可以用它来构建2D游戏。Unity则更加的灵活(例如，如果有需要的话，你可以在游戏中添加一些3D效果)。</p>

<p>看到这里，如果你还想要继续了解Sprite Kit的话，请继续往下读吧。</p>

<h3><strong> Hello，Sprite Kit！</strong></h3>

<p>下面我们就开始利用Xcode 5内置的Sprite Kit模板来构建一个简单的Hello World工程吧。</p>

<p>启动Xcode，选择<code>File\New\Project</code>，接着选中<code>iOS\Application\SpriteKit Game</code>模板，然后单击<code>Next</code>：</p>

<p><img src="/images/2013/09/7.png"></p>

<p>输入Product Name为<code>SpriteKitSimpleGame</code>，Devices选择iPhone，接着单击<code>Next</code>：</p>

<p><img src="/images/2013/09/8.png"></p>

<p>选择工程保存的路径，然后点击<code>Create</code>。然后点击Xcode中的播放按钮来运行工程。稍等片刻，可以看到如下运行画面：</p>

<p><img src="/images/2013/09/9.png"></p>

<p>跟Cocos2D类似，Sprite Kit也是按照<code>场景(scenes)</code>来构建的，这相当于游戏中的"levels"和"screens"。例如，你的游戏中可能会有一个主游戏区的场景，以及一个世界地图的一个场景。</p>

<p>如果你观察一下创建好的工程，会发现SpriteKit Game模板已经创建好了一个默认的场景<code>MyScene</code>。现在打开<code>MyScene.m</code>，里面已经包含了一些代码，其中将一个lable放到屏幕中，并且添加了：当tap屏幕时，会在屏幕上新增一个旋转的飞船。</p>

<p>在本教程中，我们主要在MyScene中写代码。不过在开始写代码之前，需要进行一个小调整——让程序以横屏的方式运行。</p>

<p>……Sprite Kit初级教程(1)结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7中的一些小修改]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/20/112-ios-7-additions-omg-finally/"/>
    <updated>2013-09-20T11:45:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/20/112-ios-7-additions-omg-finally</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/4.png"></p>

<h2><strong>小引</strong></h2>

<p>大家都知道iOS 7做了很大的调整，当然也有一些轻微的修改，我们来稍微看一下吧。</p>

<!--more-->


<p>注：本文译自<a href="http://www.doubleencore.com/2013/09/ios-7-additions-omg-finally/"><code>iOS 7 Additions: OMG Finally!</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Message UI Framework(在消息中添加文件)</li>
<li>Media Player Framework(MPVolumeView &ndash; 检测airplay和当前airplay的route)</li>
<li>AVFoundation(条码扫描)</li>
<li>更多</li>
</ul>


<h3><strong> Message UI Framework(在消息中添加文件)</strong></h3>

<p>在iOS 7之前我们可以使用<code>MFMessageComposeViewController</code>来撰写文本消息，但是要想添加文件是不可能做到的，不过在iOS 7中我们可以使用这个方法就能添加文件了：<code>- (BOOL)addAttachmentData:(NSData *)attachmentData typeIdentifier:(NSString *)uti filename:(NSString *)filename;</code>。如下代码示例所示：</p>

<p>```
if ([MFMessageComposeViewController canSendText] &amp;&amp; [MFMessageComposeViewController canSendAttachments] &amp;&amp; [MFMessageComposeViewController isSupportedAttachmentUTI:(NSString *)kUTTypePNG]) {</p>

<pre><code>MFMessageComposeViewController *vc = [[MFMessageComposeViewController alloc] init];
vc.messageComposeDelegate = self;
vc.recipients = @[@"Yawkey"];
UIImage *myImage = [UIImage imageNamed:@"Yawkey_business_dog.png"];
BOOL attached = [vc addAttachmentData:UIImagePNGRepresentation(myImage) typeIdentifier:(NSString*)kUTTypePNG filename:@"Yawkey_business_dog.png"];
if (attached) {
    NSLog(@"Attached (:");
}
else {
    NSLog(@"Not attached ):");
}
[self presentViewController:vc animated:YES completion:nil];
</code></pre>

<p>}
```
<img src="/images/2013/09/5.png"></p>

<h3><strong> Media Player Framework(MPVolumeView &ndash; 检测airplay和当前airplay的route)</strong></h3>

<p><code>MPVolumeView</code>可以帮助我们与AirPlay系统进行交互。不过，一直以来都是很难获得用户选择操作的信息。现在通过新增的两个属性和通知，我们可以更加深入的了解AirPlay系统了。
<code>
@property areWirelessRoutesAvailable;
@property isWirelessRouteActive;
</code>
这两个属性可以告诉我们是否有可用的AirPlay，以及是否以及被选中了。下面两个是通知：
<code>
NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification;
NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification;
</code>
通过这两个通知我们可以知道可用AirPlay发生了改变，以及用户修改了当前正在使用的AirPlay route。</p>

<h3><strong>AVFoundation(条码扫描)</strong></h3>

<p><code>AVFoundation</code>中现在已经内置支持一维和二维码的扫描。之前要想在iOS程序中读取条形码和QR码，则需要使用第三方库，例如ZXing和ZBar。在iOS 7中默认支持4中机器条码，需要做的就是将<code>AVCaptureMetadataOutput</code> hook up到<code>AVCaptureSession</code>。另外可以对<code>AVCaptureMetadataOutput</code>进行配置以检测如下这些任意机器可读的条码类型：
<code>
AVMetadataObjectTypeUPCECode
AVMetadataObjectTypeCode39Code
AVMetadataObjectTypeCode39Mod43Code
AVMetadataObjectTypeEAN13Code
AVMetadataObjectTypeEAN8Code
AVMetadataObjectTypeCode93Code
AVMetadataObjectTypeCode128Code
AVMetadataObjectTypePDF417Code
AVMetadataObjectTypeQRCode
AVMetadataObjectTypeAztecCode
</code></p>

<p>当配置好<code>AVCaptureMetadataOutputObjectsDelegate</code>，就可以响应<code>- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection;</code>检测到的所有条码。</p>

<h3><strong>更多</strong></h3>

<p>上面只是列出了少许新内容，你可以通过苹果提供的文档<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html">What’s New in iOS</a> 查阅更多相关内容。</p>

<p>注：本文是iOS 7开发者指南中的11篇中的第1篇。你可以在<a href="http://www.doubleencore.com/2013/09/essential-ios-7-developers-guide">这里</a>看到指南的全部内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 5中的Interface Builder更有利于团队协作开发]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/04/111-xcode-5-finally-makes-interface-builder-a-viable-option-for-teams/"/>
    <updated>2013-09-04T11:45:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/04/111-xcode-5-finally-makes-interface-builder-a-viable-option-for-teams</id>
    <content type="html"><![CDATA[<h2><strong>小引</strong></h2>

<p>在iOS开发中，开发者有各种理由选择用代码来构建界面，其中最多的理由就是Interface Builder绘制的代码不利于团队间协作(代码的可读性和合并)。虽然Interface Builder来绘制界面有诸多优势，但是由于致命的缺陷，许多开发团队不得不远离它，当然也有一些开发团队为了在协同开发时也使用IB来绘制界面，他们尽量确保同一时期只由一个人来操作某个xib文件，以此避免提交代码的时候需要合并xib文件。然而，在Xcode 5中，苹果的开发团队已经对xib文件格式做了大量的简化工作。本文就来简要的看看相关内容。</p>

<!--more-->


<p>注：本文译自<a href="http://nilsou.com/blog/2013/08/07/xcode-5-finally-makes-interface-builder-a-viable-option-for-teams/"><code>Xcode 5 Finally Makes Interface Builder a Viable Option for Teams</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Xcode 4中xib文件的格式</li>
<li>Xcode 5中xib文件的格式</li>
<li>小结</li>
</ul>


<p>上周我将代码merge到我的working branch时，注意到以前没曾见过的提示：</p>

<p><img src="/images/2013/09/1.png"></p>

<p>Git会自动合并<strong>xib文件</strong>！我在想，Xcode 5中肯定对xib文件的格式做了修改，所以我准备深入研究一下。</p>

<p>原来由Xcode 5生成的xib文件是一种全新的格式。看起来苹果这次对xib文件格式的变更将有助于开发团队开始考虑使用IB来绘制界面。</p>

<h3><strong>* Xcode 4中xib文件的格式</strong></h3>

<p>为了演示xib文件格式在Xcode 4和Xcode 5中的差异，我首先在Xcode 4中创建了一个新的xib文件，并添加了一些view进去：一个UIScrollView，该scrollview中包含一些UIButton、UILable和TextView等。</p>

<p><img src="/images/2013/09/2.png"></p>

<p>然后我在工程导航窗口中右键单击该文件，并选择<code>Open As &gt; Source Code</code>。下面的链接中是看到的内容：</p>

<p><a href="https://gist.github.com/nilsou/6057457">Xcode 4生成的.xib文件</a>(需要点击“File suppressed. Click to show.”)</p>

<p>可以看到，这么简单的一个view居然有<code>1108行</code>代码！这太多了。</p>

<p>对开发者来说它的可读性非常的糟糕。这是开发者为什么不喜欢xib文件的主要原因(由此放弃使用interface builder)。</p>

<p>更糟糕的是这个xib文件的格式还具有不确定性。也就是说如果我在Interface Builder创建相同的UI界面，但是我们看到的文件内容并不是相同的。这就导致xib文件的合并非常的困难，甚至不可能进行合并。这事开发者不使用xib文件的另外一个重要原因。</p>

<h3><strong>* Xcode 5中xib文件的格式</strong></h3>

<p>接着，我在Xcode 5中打开同一个工程。当在Xcode 5中打开用Xcode 4创建的xib文件时，会提示将文件升级到新的格式。这里需要注意的是升级之后的文件只能在Xcode 5中打开，这种新格式的文件不能在老版本中的Xcode中打开。所以，如果是团队协作开发，那么升级的时候，需要确保所有的开发者都使用Xcode 5。</p>

<p><img src="/images/2013/09/3.png"></p>

<p>我点击<code>Upgrade</code>，然后再次打开xib文件的source code，看看有什么变化。如下链接中所示：</p>

<p><a href="https://gist.github.com/nilsou/6057474">Xcode 5生成的.xib文件</a>(需要点击“File suppressed. Click to show.”)</p>

<p><code>133行</code>！这与Xcode 4中创建的xib文件相差约10倍。可见苹果的开发团队已经对xib文件格式做了大量的简化。</p>

<p>再看看里面的具体内容，可以看出它的可读性也加强了。xib文件中的源代码现在也能够反应出view的层次(Interface Builder左边看到的内容结构！)，等熟悉之后，开发者可以直接对这个xml代码进行编写。</p>

<p>最重要的一点，可以看出Xcode 5生成的xib文件内容源码位置是确定的。这非常利于文件的合并。</p>

<h3><strong>小结</strong></h3>

<p>这种新的格式带来的最大好处不仅仅是增强开发者对xib文件的可读性，另外在大多数情况下，git还可以对xib文件进行自动合并，不用开发者手动进行。</p>

<p>现在如果还有开发者告诉你他不想用xib文件，那么请把这篇文章发给他看看吧，我相信已经没有太多理由不使用xib文件了。</p>

<p>其实在Xcode 5中不仅对Interface Builder进行了改善，还有其它一些功能也做了改进，例如自动布局约束的设置已经没有以前痛苦了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Professional iOS Network Programming翻译第一章：iOS网络功能简介]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/08/09/109-introducing-ios-networking-capabilities/"/>
    <updated>2013-08-09T16:52:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/08/09/109-introducing-ios-networking-capabilities</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/07/simple_social_network.png" width="400" height="300"></p>

<h2><strong>小引</strong></h2>

<p>在iOS开发中，网络是非常重要的功能，针对iOS开发者来说，掌握好iOS中网络功能的开发也是必不可少的。最近在看一本书:<a href="http://www.amazon.com/Professional-iOS-Network-Programming-Connecting/dp/1118362403"><code>Professional iOS Network Programming</code></a>，网络编程方面介绍比较全面，非常适合iOS开发者去读一读，由于精力有限，我在这里可能会挑选一部分内容进行翻译，也有可能全书翻译。</p>

<!--more-->


<h3><strong>目录</strong></h3>

<ul>
<li>Professional iOS Network Programming介绍</li>
<li>第一章：iOS网络功能简介

<ul>
<li>了解网络框架</li>
<li>iOS网络APIs

<ul>
<li>NSURLConnection</li>
<li>Game Kit</li>
<li>Bonjour</li>
<li>NSStream</li>
<li>CFNetwork</li>
<li>BSD Sockets</li>
</ul>
</li>
<li>Run Loops

<ul>
<li>Run Loop模型</li>
</ul>
</li>
<li>小结</li>
</ul>
</li>
</ul>


<h2><strong>Professional iOS Network Programming介绍</strong></h2>

<p>这本书主要介绍在iOS中的网络编程知识，主要包含如下内容：</p>

<pre><code>在客户端和服务器端之间进行HTTP请求
管理客户端和服务器端之间进行的数据负载
处理HTTP请求中的错误
网络通信中的安全
加强网络通信的性能
socket级别的通信
推送通知的实现
同一设备中两个程序间的通信
不同设备中两个程序间的通信
</code></pre>

<h2>第一章：<strong>iOS网络功能简介</strong></h2>

<p>本章的内容</p>

<pre><code>了解iOS网络框架
开发者可用的重要网络APIs
在程序中有效的利用run Loop
</code></pre>

<p>优秀的iOS程序需要简单和直观的用户界面，同样，具有与web service通信功能的优秀程序需要一个良好架构的网络层。在设计应用程序架构时，必须考虑到程序的灵活性，以适应经常变化的需求，并能够正确的处理不断变化的网络条件，同时还需要保持核心设计原则：可维护性和可扩展性。</p>

<p>当在设计移动应用程序的架构时，必须熟悉一些相关的核心概念，例如run loop，可用的网络APIs，以及这些APIs是如何与run loop整合起来实现一个具有响应式的网络应用程序框架。本章详细的探讨了run loop，以及如何在程序中对其有效的使用。同样，也对关键的APIs做了一个概述，并且介绍了什么时候应该使用什么APIs。</p>

<h3><strong>了解网络框架</strong></h3>

<p>在开发iOS应用程序(与网络交互的程序)之前，首先必须理解Objective-C中的网络层是如何组成的，如图1-1所示：</p>

<p><img src="/images/2013/07/networking_layers_in_OC.jpg"></p>

<p>图1-1</p>

<p>如上图所示，每个iOS应用程序都都位于由四层组成的网络框架之上。最上面的是Cocoa层，该层包含了一些Objective-C写的APIs：<code>URl加载</code>，<code>Bonjour</code>和<code>Game Kit</code>。Cocoa之下是Core Foundation，该层包含了一组C语言写的APIs：<code>CFNetwork</code>，该层中的代码是大量应用层中网络代码的基础。CFNetwork在<code>CFStream</code>和<code>CFSocket</code>之上，提供了一个简单的网络接口。CFStream和CFSocket对BSD socket做了轻量级的封装，BSD是基于硬件上面的一层，它于无线通信相关硬件设备最接近。BSD socket是严格使用C实现的，通过BSD，开发者对网络中的任意通信(远程设备或者服务)拥有绝对控制权。</p>

<p>在上图中，越往下层走，会获得更高的控制权，但是相对于上一层来说易用性更差。苹果建议使用CFNetwork层以及之上的。在BSD层中的raw socket不能访问系统的VPN，也不能激活Wi-Fi或蜂窝无线模块，这些功能是由CFNetwork处理的。</p>

<p>在设计应用程序的网络层之前，开发者必须理解各种可用的APIs。下一节中会介绍iOS中关键的网络框架，并简短的解释一下如何使用它们。在本书后面的章节中，会详细介绍每个APi。</p>

<h3><strong>iOS网络APIs</strong></h3>

<p>在框架中的每层里面，都有一套关键的APIs提供给开发者相关的功能以及控制权。在图1-1中每层相对于下一层，会有更多的封装。不过封装之后，会失去一些控制权。本节就来大概的预览一下iOS中网络层关键的APIs，并探讨一下什么时候使用它们。</p>

<h5>NSURLConnection</h5>

<p>NSURLConnection是Cocoa中的一个API，它提供了一个简单的方法来请求URL，可以与web service进行交互，以获取一个图片或者视频，或者简单的获取一个HTML文档。NSURLConnection构建于NSStream之上，它支持4种通用的URI schemes：file，HTTP，HTTPS和FTP。虽然NSURLConnection限制了可以使用的协议，但是它封装了大量底层API必须要做的任务：对缓冲区进行读写，另外还内置支持认证(authentication)，并提供了一个健壮的缓存引擎。</p>

<p>实际上NSURLConnection本身提供的接口比较少，主要依赖于<code>NSURLConnectionDelegate</code>协议，通过该协议，应用程序可以与网络连接生命周期中的多个点进行交互。NSURLConnection的请求默认是异步的；不过也提供了一个同步请求方法。由于同步请求会阻塞当前调用的线程，所以必须根据具体情况来设计应用程序。在第三章(发起请求)中会详细介绍NSURLConnection，并提供了一些示例。</p>

<h6>Game Kit</h6>

<p>在iOS程序中，Game Kit提供了另外一种点对点(peer-to-peer)网络通讯的方法。在传统的网络配置中，Game Kit是构建于Bonjour之上的；不过Game Kit并不需要网络基础设施提供的功能。它可以创建ad-hoc Bluetooth Personal Area Networks(PAN)，通过该PAN可以让设备在邻近范围内或网络条件不允许的情况下，进行通讯，</p>

<p>Game Kit只需要一个会话id(session identifier)，显示的名称(display name)，以及配置网络时的连接模式。不需要配置socket，或其它任意底层网络通讯的连接。Game Kit使用GKSessionDelegate协议进行通讯。在第12章(利用Game Kit进行设备间的通讯)中介绍了将Game Kit集成到我们的程序中。</p>

<h6>Bonjour</h6>

<p><code>Bonjour</code>是苹果实现的零配置联网。Bonjour提供了这样一种机制：发现并连接到设备或者网络中的服务，这些过程中我们并不需要知道设备的网络地址，相反，Bonjour涉及到元祖名称，服务类型和域。Bonjour封装了底层网络接口需要的multicast DNS(mDNS)，以及基于DNS服务的发现(DNS-SD)。</p>

<p>在Cocoa层，NSNetService API提供了相关接口用来发布和解决Bonjour服务的地址信息。我们可以使用NSNetServiceBrowser API来发现网络中可用的服务。为了通信，发布一个Bonjour服务，即使是使用Cocoa层的API，也需要明白Core Foundation中对socket的配置。在第13章"Ad-Hoc Networking with Bonjour"中，深入介绍了零配置联网(Bonjour)，并给出了一个示例介绍如何实现一个基于Bonjour的服务。</p>

<h6>NSStream</h6>

<p><code>NSStream</code>是Cocoa层里面的API，构建于CFNetwork之上，是NSURLConnection的基础部分，并且还适用于较底层的网络任务。就像NSURLConnection，NSStream提供了一种与远程服务或者本地文件通信的机制。另外，还NSStream还可以在别的一些一些上进行通信，例如<code>telnet</code>，<code>SMTP</code>，NSURLConnection并不支持这些协议。</p>

<p>NSStream还提供了额外的一些控制功能，不过这是要付出代价的。NSStream并没有内置支持处理HTTP/S响应状态码的处理，也不支持认证功能。它是用C缓存器进行数据的发送和接收的，这跟Objective-C还有点区别。它也不能管理多个请求，如果需要相应的功能，需要在其子类中添加功能。NSStream是异步的，它通过NSStreamDelegate进行通信。在第8章中“Low-Level Networking”，以及第13章中“Ad-Hoc Networking with Bonjour”，都不同程度的实现了NSStream。</p>

<h6>CFNetwork</h6>

<p><code>CFNetwork API</code>构建于BSD socket之上，被用于NSStream、URL加载系统、Bonjour和Game Kit APIs的实现中。CFNetwork中默认支持一些上层协议，例如HTTP和FTP。CFNetwork和BSD socket最关键的区别就是集成了run loop。如果在程序中使用了CFNetwork，输入(input)和输出(output)事件会在线程的run loop中被调度。如果输入和输出事件发生于非主线程上，那么我们需要负责在这个线程中以适当的模式启动run loop。本章后面的“Run Loops”小节会有相关介绍。</p>

<p>CFNetwork提供的配置选项要比URL加载系统更多，这有好的一面，也有不好的一面。当利用CFNetwork创建一个HTTP请求时，这些配置选项是可见的。在创建请求的时候必须手动添加所有的HTTP header，以及cookies，然后与请求一起提交。而使用NSURLConnection时，标准的header和cookie jar中的任意cookies都自动的添加好了。</p>

<p>CFNetwork下面还有来自Core Foundation层中的CFSocket和CFStream APIs。CFNetwork中有一些用于特定协议的APIs，例如用于与FTP服务通讯的CFFTP，用于收发HTTP消息的CFHTTP，以及用于发布和浏览Bonjour服务的CFNetServices。第八章中将详细介绍CFNetwork，而在13章中会简要介绍一下Bonjour。</p>

<h6>BSD Sockets</h6>

<p>在网络架构中，<code>BSD Sockets</code>为网络通信提供了最基础的服务，也是最底层的一个APIs。BSD Socket是用C语言实现的，不过完全可以用在Objective-C代码中。一般不建议直接使用BSD Socket API，因为它在操作系统中没有任何hook。例如，BSD Socket既不走系统中的VPN通道，也没相关的API来自动激活已经关闭掉的Wi-Fi或蜂窝无线设备。苹果建议编程时使用CFNetwork或更高的层中的API。第8章中详细介绍了BSD Sockets以及CFNetwork，并提供了一个示例介绍了如何将它们集成到程序中。下一节将讨论run loop——从操作系统中检测网络事件，这些事件会被用于我们的程序中。</p>

<h3><strong>Run Loops</strong></h3>

<p>Run loop对应的类是<code>NSRunLoop</code>，它其实是线程中的一个基础组件，有了run loop之后，操作系统就能够唤醒休眠中的线程，以对即将到来的事件进行管理。一个run loop是一个循环配置的用来调度任务，并在一个时钟周期内处理即将到来的事件。在iOS程序中的每个线程中最多能有一个run loop。主线程中的run loop在程序启动的时候就默认开启了，并且当程序的delegate applicationDidFinishLaunchingWithOptions:被调用之后，我们就可以对其进行访问了。</p>

<p>在非主线程中，如果需要使用run loop，需要开发者明确的开启run loop。在非主线程中启动之前，必须添加一个输入源(input source)或者timer；否则run loop会立即退出。run loop给开发者提供了与线程交互的能力，不过并不是总是需要它的。例如有时候线程在处理大量数据时，并不不需要进行任何交互，此时就不需要启动run loop了。如果线程需要跟网络进行交互，此时就需要启动run loop。</p>

<p>Run loop接收的事件有两种源类型：输入源<code>(input sources)</code>和<code>计时器(timers)</code>。在输入源中一般要么是基于端口的，要么就是自定义的，这些事件通过异步的方式派发到程序中。这两种类型源的最大区别就是基于端口的内核信号源是自动的，而自定义的源必须在不同线程中手动管理相关信号。在创建自定义输入源时，可以通过CFRunLoopSourceRef实现多个回调函数。</p>

<p>计时器则是这样一种机制：基于时间进行通知应用程序在未来某个特定时间点执行某个特定的任务的。计时器事件也是通过异步的方式派发到程序中的，不过它还与特定的模式相关(下一节将介绍相关模式)。如果并不是当前监听的特定模式，这个计时器时间会被忽略，而线程也不会受到通知，直到run llop运行在相应的模式中。</p>

<p>翻译比较辛苦，下面给大家留点作业，让大家感受一下翻译吧。</p>

<p>You can configure timers to fire once or repeatedly. Rescheduling is based on the scheduled fire time, not the actual fire time. If a timer fires while the run loop is executing an application handler method, it waits until the next pass through the run loop to call the timer handler, typically set via @selector(). If firing the handler is delayed to the point in which the next invocation occurs, the timer fires only one event with the delayed event being suppressed.
Run loops can also have observers, which are not monitored and provide a way for objects to receive callbacks as certain activities in the run loop execution occur. These activities include when the run loop is entered or exited, as the run loop goes to sleep or wakes up, and before the run loop processes an input source or timer. They are documented in the CFRunLoopActivity enumeration. Observers can be configured to fire once, which removes the observer after ithas been fired, or repeatedly. To add a run loop observer, use the Core Foundation function CFRunLoopObserverRef().</p>

<h4>Run Loop模型</h4>

<p>Each pass through the run loop is run in a specific mode specified by you. Run loop modes are a convention used by the operating system to filter the sources that are monitored and allowed to deliver events, such as calling a delegate method. Modes include the input sources and timers that should be monitored as well as any observers that should be notified of run loop events.
There are two predefined run loop modes in iOS. NSDefaultRunLoopMode (kCFRunLoopDefaultMode in Core Foundation) is the system default and should typicallybe used when starting run loops and configuring input sources.
NSRunLoopCommonModes (kCFRunLoopCommonModes in Core Foundation) is a collection of modes that is configurable. Assigning NSRunLoopCommonModes to an input source by calling a method such as scheduleInRunLoop:forMode: on an input source instance associates it with all modes currently in the group.
Although NSRunLoopCommonModes is configurable, it is a low-level process that requires calling the Core Foundation function CFRunLoopAddCommonMode(). This automatically registers input sources, timers, and observers with the new mode instead of manually adding them to each new mode. You can define custom run loop modes by specifying a custom string such as @&ldquo;CustomRunLoopMode&rdquo;. For your custom run loop to be effective, you must add at least one input source, timer, or observer.
Although this provides an overview of run loops, Apple provides several in-depth resources onrun loop management that you should review if you develop advanced, network-based, and multi- threaded applications. The developer documentation is available at <a href="https://developer.apple">https://developer.apple</a> .com/library/mac/#documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/ RunLoopManagement.html. Networking techniques that benefit from run loop integration are discussed in their respective chapters such as Chapter 8, “Low-Level Networking” and Chapter 13, “Ad-Hoc Networking with Bonjour.</p>

<p>相关更多资料请看这里：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html"><code>RunLoopManagement</code></a></p>

<h3><strong>小结</strong></h3>

<p>对于iOS开发者来说，理解iOS网络框架中的各层，以及应用程序如何与run loop交互是非常重要的。一个优秀的网络架构层会给应用程序提供难以置信的灵活度。如果网络架构层的设计非常糟糕，那么这是很难获得成功和扩展能力的。</p>

<p>本章预览了一下各个网络APIs，并做了一些比较。在这里只是简单的介绍了一下，在后续章节中，会深入讨论。</p>
]]></content>
  </entry>
  
</feed>
