<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS翻译 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iosfan-yi/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2013-10-14T21:54:43+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 3]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"/>
    <updated>2013-10-12T00:06:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/18.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Sprite Kit的优点和缺点</li>
<li>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</li>
<li>Hello, Sprite Kit!</li>
<li>横屏显示</li>
<li>移动怪兽</li>
<li>发射炮弹</li>
<li><a href="#pzjcgs">碰撞检测和物理特性: 概述</a></li>
<li><a href="#pzjcsx">碰撞检测和物理特性: 实现</a></li>
<li><a href="#sw">收尾</a></li>
<li><a href="#hqhc">何去何从?</a></li>
</ul>


<h3><a id="pzjcgs"></a>碰撞检测和物理特性: 概述</h3>

<p>至此我们已经可以让炮弹任意的发射了——现在我们要让忍者利用炮弹来消灭这些怪物。下面就添加一些代码来给炮弹与怪物相交做检测。</p>

<p>Sprite Kit内置了一个物理引擎，这非常的棒！该物理引擎不仅可以模拟现实运动，还能进行碰撞检测。</p>

<p>下面我们就在游戏中使用Sprite Kit的物理引擎来检测炮弹与怪物的碰撞。首先，我们来看看需要做些神马事情：</p>

<ul>
<li><code>物理世界的配置</code>。物理世界是一个模拟的空间，用来进行物理计算。默认情况下，在场景(scene)中已经创建好了一个，我们可以对其做一些属性配置，例如重力感应。</li>
<li><code>为精灵(sprite)创建对应的物体(physics bodies)</code>。在Sprite Kit中，为了碰撞检测，我们可以为每个精灵创建一个相应的形状，并设置一些属性,这就称为<code>物体(physics body)</code>。注意：图文的形状不一定跟精灵的外形一模一样。一般情况，这个形状都是简单的、大概的(而不用精确到像素级别)——毕竟这已经足以够大多数游戏使用了。</li>
<li><code>将精灵分类</code>。在物体(physics body)上可以设置的一个属性是<code>category</code>，该属性是一个位掩码(bitmask)。通过该属性可以将精灵分类。在本文的游戏中，有两个类别——一类是炮弹，另一类则是怪物。设置之后，当两种物体相互碰撞时，就可以很容易的通过类别对精灵做出相应的处理。</li>
<li><code>设置一个contact(触点) delegate</code>。还记得上面提到的物理世界吗？我们可以在物理世界上设置一个<code>contact delegate</code>，通过该delegate，当两个物体碰撞时，可以收到通知。收到通知后，我们可以通过代码检查物体的类别，如果是怪物和炮弹，那么就做出相应的动作！</li>
</ul>


<p>上面大致介绍了一下游戏策略，下面就来看看如何实现！</p>

<h3><a id="pzjcsx"></a>碰撞检测和物理特性: 实现</h3>

<p>首先在<code>MyScene.m</code>文件顶部添加如下两个常量：</p>

<p>```objc</p>

<p>static const uint32_t projectileCategory     =  0x1 &lt;&lt; 0;
static const uint32_t monsterCategory        =  0x1 &lt;&lt; 1;</p>

<p>```</p>

<p>上面设置了两个类别，记住需要用位(bit)的方式表达——一个用于炮弹，另一个则是怪物。</p>

<p><code>注意:</code>看到上面的语法你可能感到奇怪。在Sprite Kit中category是一个32位整数，当做一个位掩码(bitmask)。这种表达方法比较奇特：在一个32位整数中的每一位表示一种类别(因此最多也就只能有32类)。在这里，第一位表示炮弹，下一位表示怪兽。</p>

<p>接着，在<code>initWithSize</code>中，将下面的代码添加到位置：添加player到场景涉及代码的后面。</p>

<p><code>objc
self.physicsWorld.gravity = CGVectorMake(0,0);
self.physicsWorld.contactDelegate = self;
</code>
上面的代码将物理世界的重力感应设置为0，并将场景设置位物理世界的代理（当有两个物体碰撞时，会受到通知）。</p>

<p>在<code>addMonster</code>方法中，将如下代码添加创建怪兽相关代码后面：</p>

<p><code>objc
monster.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:monster.size]; // 1
monster.physicsBody.dynamic = YES; // 2
monster.physicsBody.categoryBitMask = monsterCategory; // 3
monster.physicsBody.contactTestBitMask = projectileCategory; // 4
monster.physicsBody.collisionBitMask = 0; // 5
</code>
来看看上面代码意思：</p>

<ol>
<li>为怪兽创建一个对应的物体。此处，物体被定义为一个与怪兽相同尺寸的矩形(这样与怪兽形状比较接近)。</li>
<li>将怪兽设置位<code>dynamic</code>。这意味着物理引擎将不再控制这个怪兽的运动——我们自己已经写好相关运动的代码了。</li>
<li>将categoryBitMask设置为之前定义好的<code>monsterCategory</code>。</li>
<li><code>contactTestBitMask</code>表示与什么类型对象碰撞时，应该通知contact代理。在这里选择炮弹类型。</li>
<li><code>collisionBitMask</code>表示物理引擎需要处理的碰撞事件。在此处我们不希望炮弹和怪物被相互弹开——所以再次将其设置为0。</li>
</ol>


<p>接着在<code>touchesEnded:withEvent:</code>方法中设置炮弹位置的代码后面添加如下代码。</p>

<p>```objc</p>

<p>projectile.physicsBody = [SKPhysicsBody bodyWithCircleOfRadius:projectile.size.width/2];
projectile.physicsBody.dynamic = YES;
projectile.physicsBody.categoryBitMask = projectileCategory;
projectile.physicsBody.contactTestBitMask = monsterCategory;
projectile.physicsBody.collisionBitMask = 0;
projectile.physicsBody.usesPreciseCollisionDetection = YES;</p>

<p>```</p>

<p>在上面的代码中跟之前的类似，只不过有些不同，我们来看看：
1. 为了更好的效果，炮弹的形状是圆形的。
2. <code>usesPreciseCollisionDetection</code>属性设置为YES。这对于快速移动的物体非常重要(例如炮弹)，如果不这样设置的话，有可能快速移动的两个物体会直接相互穿过去，而不会检测到碰撞的发生。</p>

<p>接着，添加如下方法，当炮弹与怪物发生碰撞时，会被调用。注意这个方法是不会被自动调用，稍后会看到我们如何调用它。</p>

<p>```objc
&ndash; (void)projectile:(SKSpriteNode <em>)projectile didCollideWithMonster:(SKSpriteNode </em>)monster {</p>

<pre><code>NSLog(@"Hit");
[projectile removeFromParent];
[monster removeFromParent];
</code></pre>

<p>}
```</p>

<p>当怪物和炮弹发生碰撞，上面的代码会将他们从场景中移除。很简单吧！</p>

<p>下面该实现contact delegate方法了。将如下方法添加到文件中：</p>

<p>```objc
&ndash; (void)didBeginContact:(SKPhysicsContact *)contact
{</p>

<pre><code>// 1
SKPhysicsBody *firstBody, *secondBody;

if (contact.bodyA.categoryBitMask &lt; contact.bodyB.categoryBitMask)
{
    firstBody = contact.bodyA;
    secondBody = contact.bodyB;
}
else
{
    firstBody = contact.bodyB;
    secondBody = contact.bodyA;
}

// 2
if ((firstBody.categoryBitMask &amp; projectileCategory) != 0 &amp;&amp;
    (secondBody.categoryBitMask &amp; monsterCategory) != 0)
{
    [self projectile:(SKSpriteNode *) firstBody.node didCollideWithMonster:(SKSpriteNode *) secondBody.node];
}
</code></pre>

<p>}
```</p>

<p>还记得之前给物理世界设置的<code>contactDelegate</code>吗？当两个物体发生碰撞之后，就会调用上面的方法。</p>

<p>在上面的方法中，可以分为两部分来理解：</p>

<ol>
<li>该方法会传递给你发生碰撞的两个物体，但是并不一定符合特定的顺序(如炮弹在前，或者炮弹在后)。所以这里的代码是通过物体的category bit mask来对其进行排序，以便后续做出正确的判断。注意，这里的代码来自苹果提供的Adventure示例。</li>
<li>最后，检测一下这两个碰撞的物体是否就是炮弹和怪物，如果是的话就调用之前的方法。</li>
</ol>


<p>最后一步，为了编译器没有警告，确保private interface 中添加一下<code>SKPhysicsContactDelegate</code>：
<code>objc
@interface MyScene () &lt;SKPhysicsContactDelegate&gt;
</code>
现在编译并运行程序，可以发现，当炮弹与怪物接触时，他们就会消失！</p>

<h3><a id="sw"></a>收尾</h3>

<p>现在，本文的游戏快完成了。接下来我们就来为游戏添加音效和音乐，以及一些简单的游戏逻辑吧。</p>

<p>苹果提供的Sprite Kit里面并没有音频引擎(Cocos2D中是有的)，不过我们可以通过action来播放音效，并且可以使用AVFoundation播放后台音乐。</p>

<p>在工程中我已经准备好了一些音效和很酷的后台音乐，在本文开头已经将resources添加到工程中了，现在只需要播放它们即可！</p>

<p>首先在<code>ViewController.m</code>文件顶部添加如下import：</p>

<p><code>objc
@import AVFoundation;
</code></p>

<p>上面的语法是iOS 7中新的modules功能 —— 只需要使用新的关键字@import，就可以框架的头文件和库文件添加到工程中，这功能非常方便。要了解更多相关内容，请看到<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS 7 by Tutorials</a>中的第十章内容中的：What’s New with Objective-C and Foundation。</p>

<p>接着添加一个新的属性和private interface：</p>

<p><code>objc
@interface ViewController ()
@property (nonatomic) AVAudioPlayer * backgroundMusicPlayer;
@end
</code>
接着将下面的代码添加到<code>viewWillLayoutSubviews</code>方法中(在<code>[super viewWillLayoutSubviews]</code>后面)：</p>

<p><code>objc
NSError *error;
NSURL * backgroundMusicURL = [[NSBundle mainBundle] URLForResource:@"background-music-aac" withExtension:@"caf"];
self.backgroundMusicPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:backgroundMusicURL error:&amp;error];
self.backgroundMusicPlayer.numberOfLoops = -1;
[self.backgroundMusicPlayer prepareToPlay];
[self.backgroundMusicPlayer play];
</code></p>

<p>上面的代码会开始无限循环的播放后台音乐。</p>

<p>下面我们来看看如何处理音效。切换到<code>MyScene.m</code>文件中，并将下面这行代码添加到<code>touchesEnded:withEvent:</code>方法的顶部：</p>

<p>```objc
[self runAction:[SKAction playSoundFileNamed:@&ldquo;pew-pew-lei.caf&rdquo; waitForCompletion:NO]];</p>

<p>```</p>

<p>如上，一行代码就可以播放音效了，很简单吧！</p>

<p>下面，我们创建一个新的创建和layer，用来显示<code>你赢了(You Win)</code>或<code>你输了(You Lose)</code>。用模板<code>iOS\Cocoa Touch\Objective-C class</code>创建一个新的文件，将其命名为<code>GameOverScene</code>，并让其继承自<code>SKScene</code>，然后点击<code>Next</code>和<code>Create</code>。</p>

<p>接着用如下代码替换<code>GameOverScene.h</code>中的内容：</p>

<p>```objc</p>

<h1>import &lt;SpriteKit/SpriteKit.h></h1>

<p>@interface GameOverScene : SKScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size won:(BOOL)won;</p>

<p>@end
```</p>

<p>在上面的代码中导入了Sprite Kit头文件，并声明了一个特定的初始化方法，该方法的第一个参数用来定位显示的位置，第二个参数won用来判断用户是否赢了。</p>

<p>接着用下面的代码替换<code>GameOverLayer.m</code>中的内容：</p>

<p>```objc</p>

<h1>import &ldquo;GameOverScene.h&rdquo;</h1>

<h1>import &ldquo;MyScene.h&rdquo;</h1>

<p>@implementation GameOverScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size won:(BOOL)won {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 1
    self.backgroundColor = [SKColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];

    // 2
    NSString * message;
    if (won) {
        message = @"You Won!";
    } else {
        message = @"You Lose :[";
    }

    // 3
    SKLabelNode *label = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
    label.text = message;
    label.fontSize = 40;
    label.fontColor = [SKColor blackColor];
    label.position = CGPointMake(self.size.width/2, self.size.height/2);
    [self addChild:label];

    // 4
    [self runAction:
        [SKAction sequence:@[
            [SKAction waitForDuration:3.0],
            [SKAction runBlock:^{
                // 5
                SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
                SKScene * myScene = [[MyScene alloc] initWithSize:self.size];
                [self.view presentScene:myScene transition: reveal];
            }]
        ]]
    ];

}
return self;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>上面的代码可以分为4部分内容，我们来分别看看：</p>

<ol>
<li>将背景色设置为白色(与主场景一样颜色)。</li>
<li>根据<code>won</code>参数，将信息设置为"You Won"或"You Lose"。</li>
<li>这里的代码是利用Sprite Kit将一个文本标签显示到屏幕中。如代码所示，只需要选择一个字体，并设置少量的参数即可，也非常简单。</li>
<li>设置并运行有个有两个action的sequence。为了看起来方便，此处我将它们放到一块(而不是为每个action创建单独的一个变量)。首先是等待3秒，然后是利用<code>runBlock</code>action来运行一些代码。</li>
<li>演示了在Sprite Kit中如何过渡到新的场景。首先可以选择任意的一种不同的动画过渡效果，用于场景的显示，在这里选择了翻转效果(持续0.5秒)。然后是创建一个想要显示的场景，接着使用self.view的方法<code>presentScene:transition:</code>来显示出场景。</li>
</ol>


<p>OK，万事俱备，只欠东风了！现在只需要在主场景中，适当的情况下加载game over scene就可以了。</p>

<p>首先，在<code>MyScene.m</code>中导入新的场景：</p>

<p>```objc</p>

<h1>import &ldquo;GameOverScene.h&rdquo;</h1>

<p>```</p>

<p>然后，在<code>addMonster</code>中，用下面的代码替换最后一行在怪物上运行action的代码：</p>

<p>```objc
SKAction * loseAction = [SKAction runBlock:^{</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * gameOverScene = [[GameOverScene alloc] initWithSize:self.size won:NO];
[self.view presentScene:gameOverScene transition: reveal];
</code></pre>

<p>}];
[monster runAction:[SKAction sequence:@[actionMove, loseAction, actionMoveDone]]];
```</p>

<p>上面创建了一个"lose action"，当怪物离开屏幕时，显示game over场景。</p>

<p>在这里为什么<code>loseAction</code>要在<code>actionMoveDone</code>之前运行呢？
原因在于如果将一个精灵从场景中移除了，那么它就不在处于场景的层次结构中了，也就不会有action了。所以需要过渡到lose场景之后，才能将精灵移除。不过，实际上actionMoveDone永远都不会被调用——因为此时已经过渡到新的场景中了，留在这里就是为了达到教学的目的。</p>

<p>现在，需要处理一下赢了的情况。在private interface中添加一个新的属性：</p>

<p><code>objc
@property (nonatomic) int monstersDestroyed;
</code></p>

<p>然后将如下代码添加到<code>projectile:didCollideWithMonster:</code>的底部：</p>

<p>```objc
self.monstersDestroyed++;
if (self.monstersDestroyed > 30) {</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * gameOverScene = [[GameOverScene alloc] initWithSize:self.size won:YES];
[self.view presentScene:gameOverScene transition: reveal];
</code></pre>

<p>}
```</p>

<p>编译并运行程序，尝试一下赢了和输了会看到的画面！</p>

<h3><a id="hqhc"></a>何去何从?</h3>

<p>至此<code>Sprite Kit教程：初学者</code>结束！这里可以下到<a href="http://cdn2.raywenderlich.com/downloads/SpriteKitSimpleGame2.zip">完整的代码</a>。</p>

<p>希望本文能帮助你学习Sprite Kit，并写出你自己的游戏！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>

<p>……Sprite Kit教程：初学者 3 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"/>
    <updated>2013-09-29T00:06:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/10.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>感谢<a href="http://answerhuang.duapp.com/">answer哥</a>对本文翻译问题的提出。(2013-10-14)</p>

<h3><strong>目录</strong></h3>

<ul>
<li>Sprite Kit的优点和缺点</li>
<li>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</li>
<li>Hello, Sprite Kit!</li>
<li><a href="#hpxs">横屏显示</a></li>
<li><a href="#ydgs">移动怪兽</a></li>
<li><a href="#fspd">发射炮弹</a></li>
<li>碰撞检测: 概述</li>
<li>碰撞检测: 实现</li>
<li>收尾</li>
<li>何去何从?</li>
</ul>


<h3><a id="hpxs"></a>横屏显示</h3>

<p>首先，在Project Navigator中单击SpriteKitSimpleGame工程以打开target设置，选中SpriteKitSimpleGame target。然后在<code>Deployment Info</code>中，不要勾选<code>Portrait</code>，只选中<code>Landscape</code>和<code>Landscape Right</code>，如下所示：</p>

<p><img src="/images/2013/09/11.png"></p>

<p>编译并运行工程，会看到如下运行画面：</p>

<p><img src="/images/2013/09/12.png"></p>

<p>下面我们试着添加一个忍者(ninja)。</p>

<p>首先，下载此<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2015/01/SpriteKitSimpleGameResources.zip">工程的资源文件</a>，并将其拖拽到Xcode工程中。确保勾选上<code>“Copy items into destination group’s folder (if needed)”</code>和<code>SpriteKitSimpleGame target</code>。</p>

<p>接着，打开<code>MyScene.m</code>，并用下面的内容替换之：</p>

<p>```objc</p>

<h1>import &ldquo;MyScene.h&rdquo;</h1>

<p>// 1
@interface MyScene ()
@property (nonatomic) SKSpriteNode * player;
@end</p>

<p>@implementation MyScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 2
    NSLog(@"Size: %@", NSStringFromCGSize(size));

    // 3
    self.backgroundColor = [SKColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];

    // 4
    self.player = [SKSpriteNode spriteNodeWithImageNamed:@"player"];
    self.player.position = CGPointMake(100, 100);
    [self addChild:self.player];

}
return self;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>我们来看看上面的代码。</p>

<ol>
<li>为了给player(例如忍者)声明一个私有变量，在这里创建了一个私有的interface，之后可以把这个私有变量添加到场景中。</li>
<li>在这里打印出了场景的size，至于什么原因很快你就会看到了。</li>
<li>在Sprite Kit中设置一个场景的背景色非常简单——只需要设置<code>backgroundColor</code>属性，在这里将其设置位白色。</li>
<li>在Sprite Kit场景中添加一个精灵同样非常简单，只需要使用<code>spriteNodeWithImageNamed</code>方法，并把一副图片的名称传递进去就可以创建一个精灵。接着设置一下精灵的位置，然后调用<code>addChild</code>方法将该精灵添加到场景中。在代码中将忍者的位置设置为<code>(100, 100)</code>，该位置是从屏幕的左下角到右上角计算的。</li>
</ol>


<p>编译并运行，看看效果如何…</p>

<p><img src="/images/2013/09/13.png"></p>

<p>呀！屏幕是白色的，并没有看到忍者。这是为什么呢？你可能在想设计之初就是这样的，实际上这里有一个问题。</p>

<p>如果你观察一下控制台输出的内容，会看到如下内容</p>

<p><code>objc
SpriteKitSimpleGame[3139:907] Size: {320, 568}
</code>
scene认为自己的宽度是320，高度则是568——实际上刚好相反!</p>

<p>我们来看看具体发生了什么：定位到<code>ViewController.m</code>的<code>viewDidLoad</code>方法：</p>

<p>```objc
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];

// Configure the view.
SKView * skView = (SKView *)self.view;
skView.showsFPS = YES;
skView.showsNodeCount = YES;

// Create and configure the scene.
SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
scene.scaleMode = SKSceneScaleModeAspectFill;

// Present the scene.
[skView presentScene:scene];
</code></pre>

<p>}
```</p>

<p>上面的代码中利用view的边界size创建了场景。不过请注意，当<code>viewDidLoad</code>被调用的时候，view还没被添加到view层级结构中，因此它还没有响应出布局的改变。所以view的边界可能还不正确，进而在viewDidLoad中并不是开启场景的最佳时机。</p>

<p><code>提醒</code>：要想了解更多相关内容，请看由Rob Mayoff带来的<a href="http://stackoverflow.com/questions/9539676/uiviewcontroller-returns-invalid-frame">最佳解释</a>。</p>

<p>解决方法就是将开启场景代码的过程再靠后一点。用下面的代码替换<code>viewDidLoad</code>:
```objc
&ndash; (void)viewWillLayoutSubviews
{</p>

<pre><code>[super viewWillLayoutSubviews];

// Configure the view.
SKView * skView = (SKView *)self.view;
if (!skView.scene) {
  skView.showsFPS = YES;
  skView.showsNodeCount = YES;

  // Create and configure the scene.
  SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
  scene.scaleMode = SKSceneScaleModeAspectFill;

  // Present the scene.
  [skView presentScene:scene];
}
</code></pre>

<p>}
```</p>

<p>编译并运行程序，可以看到，忍者已经显示在屏幕中了！</p>

<p><img src="/images/2013/09/14.png"></p>

<p>如上图所示，可以看到坐标系已经正确了，如果想要把忍者的位置设置为其中间靠左，那么在<code>MyScene.m</code>中用下面的代码来替换设置忍者位置相关的代码：</p>

<p>```objc</p>

<p>self.player.position = CGPointMake(self.player.size.width/2, self.frame.size.height/2);</p>

<p>```</p>

<h3><a id="ydgs"></a>移动怪兽</h3>

<p>接下来，我们希望在场景中添加一些怪兽，让忍者进行攻击。为了让游戏更有趣一点，希望怪兽能够移动——否则没有太大的挑战！OK，我们就在屏幕的右边，离屏的方式创建怪兽，并给怪兽设置一个动作：告诉它们往左边移动。</p>

<p>将下面这个方法添加到<code>MyScene.m</code>中：</p>

<p>```objc
&ndash; (void)addMonster {</p>

<pre><code>// Create sprite
SKSpriteNode * monster = [SKSpriteNode spriteNodeWithImageNamed:@"monster"];

// Determine where to spawn the monster along the Y axis
int minY = monster.size.height / 2;
int maxY = self.frame.size.height - monster.size.height / 2;
int rangeY = maxY - minY;
int actualY = (arc4random() % rangeY) + minY;

// Create the monster slightly off-screen along the right edge,
// and along a random position along the Y axis as calculated above
monster.position = CGPointMake(self.frame.size.width + monster.size.width/2, actualY);
[self addChild:monster];

// Determine speed of the monster
int minDuration = 2.0;
int maxDuration = 4.0;
int rangeDuration = maxDuration - minDuration;
int actualDuration = (arc4random() % rangeDuration) + minDuration;

// Create the actions
SKAction * actionMove = [SKAction moveTo:CGPointMake(-monster.size.width/2, actualY) duration:actualDuration];
SKAction * actionMoveDone = [SKAction removeFromParent];
[monster runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
</code></pre>

<p>}
```</p>

<p>在上面，我尽量让代码看起来容易理解。首先是通过一个简单的计算，确定怪兽出现的位置，并将该位置设置给怪兽，然后将其添加到场景中。</p>

<p>接着是添加动作(actions)。跟Cocos2D一样，Sprite Kit同样提供了很多方便的内置动作，例如移动动作、旋转动作、淡入淡出动作、动画动作等。在这里我们只需要在怪兽上使用3中动作即可：</p>

<ul>
<li><code>moveTo:duration:</code>使用这个动作可以把怪兽从屏幕外边移动到左边。移动过程中，我们可以指定移动持续的时间，上面的代码中，指定为2-4秒之间的一个随机数。</li>
<li><code>removeFromParent:</code>在Sprite Kit中，可以使用该方法，方便的将某个node从parent中移除，能有效的从场景中删除某个对象。此处，将不再需要显示的怪兽从场景中移除。这个功能非常的重要，否则当有源源不断的怪兽出现在场景中时，会耗尽设备的所有资源。</li>
<li><code>sequence:</code>sequence动作可以一次性就把一系列动作串联起来按照一定顺序执行。通过该方法我们就能让<code>moveTo:</code>方法先执行，当完成之后，在执行<code>removeFromParent:</code>动作。</li>
</ul>


<p>最后，我们需要做的事情就是调用上面这个方法<code>addMonster</code>，以实际的创建出怪兽！为了更加好玩，下面我们来让怪兽随着时间持续的出现在屏幕中。</p>

<p>在Sprite Kit中，并不能像Cocos2D一样，可以配置每隔X秒就回调一下update方法。同样也不支持将从上次更新到目前为止的时间差传入方法中。(非常令人吃惊！)。</p>

<p>不过，我们可以通过一小段代码来仿造这种行为。首先在<code>MyScene.m</code>的private interface中添加如下属性：</p>

<p><code>objc
@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;
@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;
</code>
通过<code>lastSpawnTimeInterval</code>可以记录着最近出现怪兽时的时间，而<code>lastUpdateTimeInterval</code>可以记录着上次更新时的时间。</p>

<p>接着，我们写一个方法，该方法在画面每一帧更新的时候都会被调用。记住，该方法不会被自动调用——需要另外写一个方法来调用它：</p>

<p>```objc
&ndash; (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {</p>

<pre><code>self.lastSpawnTimeInterval += timeSinceLast;
if (self.lastSpawnTimeInterval &gt; 1) {
    self.lastSpawnTimeInterval = 0;
    [self addMonster];
}
</code></pre>

<p>}
```</p>

<p>上面的代码中简单的将上次更新(update调用)的时间追加到<code>self.lastSpawnTimeInterval</code>中。一旦该时间大于1秒，就在场景中新增一个怪兽，并将<code>lastSpawnTimeInterval</code>重置。</p>

<p>最后，添加如下方法来调用上面的方法：</p>

<p>```objc
&ndash; (void)update:(NSTimeInterval)currentTime {</p>

<pre><code>// Handle time delta.
// If we drop below 60fps, we still want everything to move the same distance.
CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;
self.lastUpdateTimeInterval = currentTime;
if (timeSinceLast &gt; 1) { // more than a second since last update
    timeSinceLast = 1.0 / 60.0;
    self.lastUpdateTimeInterval = currentTime;
}

[self updateWithTimeSinceLastUpdate:timeSinceLast];
</code></pre>

<p>}
```</p>

<p>Sprite Kit在显示每帧时都会调用上面的<code>update:</code>方法。</p>

<p>上面的代码其实是来自苹果提供的Adventure示例中。该方法会传入当前的时间，在其中，会做一些计算，以确定出上一帧更新的时间。注意，在代码中做了一些合理性的检查，以避免从上一帧更新到现在已经过去了大量时间，并且将间隔重置为1/60秒，避免出现奇怪的行为。</p>

<p>现在编译并运行程序，可以看到许多怪兽从左边移动到屏幕右边并消失。</p>

<p><img src="/images/2013/09/15.png"></p>

<h3><a id="fspd"></a>发射炮弹</h3>

<p>现在我们开始给忍者添加一些动作，首先从发射炮弹开始！实际上有多种方法来实现炮弹的发射，不过，在这里要实现的方法时当用户tap屏幕时，从忍者的方位到tap的方位发射一颗炮弹。</p>

<p>由于本文是针对初级开发者，所以在这里我使用<code>moveTo:</code>动作来实现，不过这需要做一点点的数学运算——因为<code>moveTo:</code>方法需要指定炮弹的目的地，但是又不能直接使用touch point(因为touch point仅仅代表需要发射的方向)。实际上我们需要让炮弹穿过touch point，直到炮弹在屏幕中消失。</p>

<p>如下图，演示了上面的相关内容：</p>

<p><img src="/images/2013/09/16.jpg"></p>

<p>如图所示，我们可以通过origin point到touch point得到一个小的三角形。我们要做的就是根据这个小三角形的比例创建出一个大的三角形——而你知道你想要的一个端点是离开屏幕的地方。</p>

<p>为了做这个计算，如果有一些基本的矢量方法可供调用(例如矢量的加减法)，那么会非常有帮助，但很不幸的时Sprite Kit并没有提供相关方法，所以，我们必须自己实现。</p>

<p>不过很幸运的时这非常容易实现。将下面的方法添加到文件的顶部(implementation之前)：</p>

<p>```objc
static inline CGPoint rwAdd(CGPoint a, CGPoint b) {</p>

<pre><code>return CGPointMake(a.x + b.x, a.y + b.y);
</code></pre>

<p>}</p>

<p>static inline CGPoint rwSub(CGPoint a, CGPoint b) {</p>

<pre><code>return CGPointMake(a.x - b.x, a.y - b.y);
</code></pre>

<p>}</p>

<p>static inline CGPoint rwMult(CGPoint a, float b) {</p>

<pre><code>return CGPointMake(a.x * b, a.y * b);
</code></pre>

<p>}</p>

<p>static inline float rwLength(CGPoint a) {</p>

<pre><code>return sqrtf(a.x * a.x + a.y * a.y);
</code></pre>

<p>}</p>

<p>// Makes a vector have a length of 1
static inline CGPoint rwNormalize(CGPoint a) {</p>

<pre><code>float length = rwLength(a);
return CGPointMake(a.x / length, a.y / length);
</code></pre>

<p>}
```
上面实现了一些标准的矢量函数。如果你看得不是太明白，请看这里关于<a href="http://www.mathsisfun.com/algebra/vectors.html">矢量方法的解释</a>。</p>

<p>接着，在文件中添加一个新的方法：</p>

<p>```objc
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>// 1 - Choose one of the touches to work with
UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];

// 2 - Set up initial location of projectile
SKSpriteNode * projectile = [SKSpriteNode spriteNodeWithImageNamed:@"projectile"];
projectile.position = self.player.position;

// 3- Determine offset of location to projectile
CGPoint offset = rwSub(location, projectile.position);

// 4 - Bail out if you are shooting down or backwards
if (offset.x &lt;= 0) return;

// 5 - OK to add now - we've double checked position
[self addChild:projectile];

// 6 - Get the direction of where to shoot
CGPoint direction = rwNormalize(offset);

// 7 - Make it shoot far enough to be guaranteed off screen
CGPoint shootAmount = rwMult(direction, 1000);

// 8 - Add the shoot amount to the current position       
CGPoint realDest = rwAdd(shootAmount, projectile.position);

// 9 - Create the actions
float velocity = 480.0/1.0;
float realMoveDuration = self.size.width / velocity;
SKAction * actionMove = [SKAction moveTo:realDest duration:realMoveDuration];
SKAction * actionMoveDone = [SKAction removeFromParent];
[projectile runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
</code></pre>

<p>}
```</p>

<p>上面的代码中做了很多事情，我们来详细看看。</p>

<ol>
<li>SpriteKit为我们做了很棒的一件事情就是它提供了一个UITouch的category，该category中有<code>locationInNode:</code>和<code>previousLocationInNode:</code>方法。这两个方法可以帮助我们定位到在SKNode内部坐标系中touch的坐标位置。这样一来，我们就可以寻得到在场景坐标系中touch的位置。</li>
<li>然后创建一个炮弹，并将其放置到忍者的地方，以当做其开始位置。注意，现在还没有将其添加到场景中，因为还需要先做一个合理性的检查——该游戏不允许忍者向后发射。</li>
<li>接着利用touch位置减去炮弹的当前位置，这样就能获得一个从当前位置到touch位置的矢量。</li>
<li>如果X值小于0，就意味着忍者将要向后发射，由于在这里的游戏中是不允许的(真实中的忍者是不回头的！)，所以就return。</li>
<li>否则，将可以将炮弹添加到场景中。</li>
<li>调用方法<code>rwNormalize</code>，将offset转换为一个单位矢量(长度为1)。这样做可以让在相同方向上，根据确定的长度来构建一个矢量更加容易（因为1 * length = length）。</li>
<li>在单位矢量的方向上乘以1000。为什么是1000呢？因为着肯定足够超过屏幕边缘了 :]</li>
<li>将上一步中计算得到的位置与炮弹的位置相加，以获得炮弹最终结束的位置。</li>
<li>最后，参照之前构建怪物时的方法，创建<code>moveTo:</code>和<code>removeFromParent:</code>两个actions。</li>
</ol>


<p>编译并运行程序，现在忍者可以发射炮弹了！</p>

<p><img src="/images/2013/09/17.png"></p>

<p>……Sprite Kit教程：初学者 2 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 1 ]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"/>
    <updated>2013-09-26T11:45:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/6.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><code>Sprite Kit的优点和缺点</code></li>
<li><code>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</code></li>
<li><code>Hello, Sprite Kit!</code></li>
<li>横屏显示</li>
<li>移动怪兽</li>
<li>发射炮弹</li>
<li>碰撞检测: 概述</li>
<li>碰撞检测: 实现</li>
<li>收尾</li>
<li>何去何从?</li>
</ul>


<p>在iOS 7中内置了一个新的Sprite Kit框架，该框架主要用来开发2D游戏。目前已经支持的内容包括：精灵、很酷的特效(例如视频、滤镜和遮罩)，并且还集成了物理库等许多东西。</p>

<p>iOS 7中附带了一个非常棒的Sprite Kit示例工程，名字叫做Adventure。不过这个示例工程稍微有点复杂，不太适合初学者。本文的目的就是做一个关于Sprite Kit使用的初级教程。</p>

<p>通过本文，你可以从头到尾的学习到如何为你的iPhone创建一个简单又有趣的2D游戏。如果你看过我们之前的教程:<a href="http://www.raywenderlich.com/25736/how-to-make-a-simple-iphone-game-with-cocos2d-2-x-tutorial">Simple Cocos2D game教程</a>，你会发现非常的相似。</p>

<p>在开始之前，请确保已经安装了最新版本的Xcode(5.X)，里面支持Sprite Kit以及iOS 7。</p>

<h3><strong> Sprite Kit的优点和缺点</strong></h3>

<p>首先，我想指出在iOS中开发2D游戏Sprite Kit并不是唯一的选择，下面我们先来看看Sprite Kit的一些优点和缺点。</p>

<p>Sprite Kit的优点：</p>

<p> 1、它是内置到iOS中的，因此并不需要下载额外的库或者其它一些外部依赖。并且它是由苹果开发的，所以对于它的支持和更新我们可以放心。</p>

<p> 2、它内置的工具支持纹理和粒子。</p>

<p> 3、它可以让你做一些其它框架很难做到的事情，例如把视频当做精灵一样处理，或者使用很酷的图形效果和遮罩。</p>

<p>Sprite Kit的缺点：</p>

<p> 1、如果使用了Sprite Kit，那么你将被iOS生态圈所绑架，导致你无法很容易对你开发的游戏移植到Android上。</p>

<p> 2、Sprite Kit现在还处于初始阶段，此时提供的功能还没有别的框架丰富，例如Cocos2D。最缺的东西应该是暂不支持写自定义的OpenGL代码。</p>

<h3><strong> Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</strong></h3>

<p>此时，你可能在想“我该选择使用哪个2D框架呢？”</p>

<p>这取决于你的实际情况，下面是我的一些想法：</p>

<p> 1、如果你是一个初学者，并且只关注于iOS，那么就使用内置的Sprite Kit吧，它非常容易学习，并且完全可以把工作做好。</p>

<p> 2、如果需要写自己的OpenGL代码，那么还是使用Cocos2D，或者其它框架吧，目前Sprite Kit并不支持自定义OpenGL代码。</p>

<p> 3、如果要进行跨平台开发，那么选择Cocos2D-X或者Unity。Cocos2D-X非常出色，可以用它来构建2D游戏。Unity则更加的灵活(例如，如果有需要的话，你可以在游戏中添加一些3D效果)。</p>

<p>看到这里，如果你还想要继续了解Sprite Kit的话，请继续往下读吧。</p>

<h3><strong> Hello，Sprite Kit！</strong></h3>

<p>下面我们就开始利用Xcode 5内置的Sprite Kit模板来构建一个简单的Hello World工程吧。</p>

<p>启动Xcode，选择<code>File\New\Project</code>，接着选中<code>iOS\Application\SpriteKit Game</code>模板，然后单击<code>Next</code>：</p>

<p><img src="/images/2013/09/7.png"></p>

<p>输入Product Name为<code>SpriteKitSimpleGame</code>，Devices选择iPhone，接着单击<code>Next</code>：</p>

<p><img src="/images/2013/09/8.png"></p>

<p>选择工程保存的路径，然后点击<code>Create</code>。然后点击Xcode中的播放按钮来运行工程。稍等片刻，可以看到如下运行画面：</p>

<p><img src="/images/2013/09/9.png"></p>

<p>跟Cocos2D类似，Sprite Kit也是按照<code>场景(scenes)</code>来构建的，这相当于游戏中的"levels"和"screens"。例如，你的游戏中可能会有一个主游戏区的场景，以及一个世界地图的一个场景。</p>

<p>如果你观察一下创建好的工程，会发现SpriteKit Game模板已经创建好了一个默认的场景<code>MyScene</code>。现在打开<code>MyScene.m</code>，里面已经包含了一些代码，其中将一个lable放到屏幕中，并且添加了：当tap屏幕时，会在屏幕上新增一个旋转的飞船。</p>

<p>在本教程中，我们主要在MyScene中写代码。不过在开始写代码之前，需要进行一个小调整——让程序以横屏的方式运行。</p>

<p>……Sprite Kit教程：初学者 1 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7中的一些小修改]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/20/112-ios-7-additions-omg-finally/"/>
    <updated>2013-09-20T11:45:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/20/112-ios-7-additions-omg-finally</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/4.png"></p>

<h2><strong>小引</strong></h2>

<p>大家都知道iOS 7做了很大的调整，当然也有一些轻微的修改，我们来稍微看一下吧。</p>

<!--more-->


<p>注：本文译自<a href="http://www.doubleencore.com/2013/09/ios-7-additions-omg-finally/"><code>iOS 7 Additions: OMG Finally!</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Message UI Framework(在消息中添加文件)</li>
<li>Media Player Framework(MPVolumeView &ndash; 检测airplay和当前airplay的route)</li>
<li>AVFoundation(条码扫描)</li>
<li>更多</li>
</ul>


<h3><strong> Message UI Framework(在消息中添加文件)</strong></h3>

<p>在iOS 7之前我们可以使用<code>MFMessageComposeViewController</code>来撰写文本消息，但是要想添加文件是不可能做到的，不过在iOS 7中我们可以使用这个方法就能添加文件了：<code>- (BOOL)addAttachmentData:(NSData *)attachmentData typeIdentifier:(NSString *)uti filename:(NSString *)filename;</code>。如下代码示例所示：</p>

<p>```
if ([MFMessageComposeViewController canSendText] &amp;&amp; [MFMessageComposeViewController canSendAttachments] &amp;&amp; [MFMessageComposeViewController isSupportedAttachmentUTI:(NSString *)kUTTypePNG]) {</p>

<pre><code>MFMessageComposeViewController *vc = [[MFMessageComposeViewController alloc] init];
vc.messageComposeDelegate = self;
vc.recipients = @[@"Yawkey"];
UIImage *myImage = [UIImage imageNamed:@"Yawkey_business_dog.png"];
BOOL attached = [vc addAttachmentData:UIImagePNGRepresentation(myImage) typeIdentifier:(NSString*)kUTTypePNG filename:@"Yawkey_business_dog.png"];
if (attached) {
    NSLog(@"Attached (:");
}
else {
    NSLog(@"Not attached ):");
}
[self presentViewController:vc animated:YES completion:nil];
</code></pre>

<p>}
```
<img src="/images/2013/09/5.png"></p>

<h3><strong> Media Player Framework(MPVolumeView &ndash; 检测airplay和当前airplay的route)</strong></h3>

<p><code>MPVolumeView</code>可以帮助我们与AirPlay系统进行交互。不过，一直以来都是很难获得用户选择操作的信息。现在通过新增的两个属性和通知，我们可以更加深入的了解AirPlay系统了。
<code>
@property areWirelessRoutesAvailable;
@property isWirelessRouteActive;
</code>
这两个属性可以告诉我们是否有可用的AirPlay，以及是否以及被选中了。下面两个是通知：
<code>
NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification;
NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification;
</code>
通过这两个通知我们可以知道可用AirPlay发生了改变，以及用户修改了当前正在使用的AirPlay route。</p>

<h3><strong>AVFoundation(条码扫描)</strong></h3>

<p><code>AVFoundation</code>中现在已经内置支持一维和二维码的扫描。之前要想在iOS程序中读取条形码和QR码，则需要使用第三方库，例如ZXing和ZBar。在iOS 7中默认支持4中机器条码，需要做的就是将<code>AVCaptureMetadataOutput</code> hook up到<code>AVCaptureSession</code>。另外可以对<code>AVCaptureMetadataOutput</code>进行配置以检测如下这些任意机器可读的条码类型：
<code>
AVMetadataObjectTypeUPCECode
AVMetadataObjectTypeCode39Code
AVMetadataObjectTypeCode39Mod43Code
AVMetadataObjectTypeEAN13Code
AVMetadataObjectTypeEAN8Code
AVMetadataObjectTypeCode93Code
AVMetadataObjectTypeCode128Code
AVMetadataObjectTypePDF417Code
AVMetadataObjectTypeQRCode
AVMetadataObjectTypeAztecCode
</code></p>

<p>当配置好<code>AVCaptureMetadataOutputObjectsDelegate</code>，就可以响应<code>- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection;</code>检测到的所有条码。</p>

<h3><strong>更多</strong></h3>

<p>上面只是列出了少许新内容，你可以通过苹果提供的文档<a href="https://developer.apple.com/library/prerelease/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html">What’s New in iOS</a> 查阅更多相关内容。</p>

<p>注：本文是iOS 7开发者指南中的11篇中的第1篇。你可以在<a href="http://www.doubleencore.com/2013/09/essential-ios-7-developers-guide">这里</a>看到指南的全部内容。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 5中的Interface Builder更有利于团队协作开发]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/04/111-xcode-5-finally-makes-interface-builder-a-viable-option-for-teams/"/>
    <updated>2013-09-04T11:45:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/04/111-xcode-5-finally-makes-interface-builder-a-viable-option-for-teams</id>
    <content type="html"><![CDATA[<h2><strong>小引</strong></h2>

<p>在iOS开发中，开发者有各种理由选择用代码来构建界面，其中最多的理由就是Interface Builder绘制的代码不利于团队间协作(代码的可读性和合并)。虽然Interface Builder来绘制界面有诸多优势，但是由于致命的缺陷，许多开发团队不得不远离它，当然也有一些开发团队为了在协同开发时也使用IB来绘制界面，他们尽量确保同一时期只由一个人来操作某个xib文件，以此避免提交代码的时候需要合并xib文件。然而，在Xcode 5中，苹果的开发团队已经对xib文件格式做了大量的简化工作。本文就来简要的看看相关内容。</p>

<!--more-->


<p>注：本文译自<a href="http://nilsou.com/blog/2013/08/07/xcode-5-finally-makes-interface-builder-a-viable-option-for-teams/"><code>Xcode 5 Finally Makes Interface Builder a Viable Option for Teams</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Xcode 4中xib文件的格式</li>
<li>Xcode 5中xib文件的格式</li>
<li>小结</li>
</ul>


<p>上周我将代码merge到我的working branch时，注意到以前没曾见过的提示：</p>

<p><img src="/images/2013/09/1.png"></p>

<p>Git会自动合并<strong>xib文件</strong>！我在想，Xcode 5中肯定对xib文件的格式做了修改，所以我准备深入研究一下。</p>

<p>原来由Xcode 5生成的xib文件是一种全新的格式。看起来苹果这次对xib文件格式的变更将有助于开发团队开始考虑使用IB来绘制界面。</p>

<h3><strong>* Xcode 4中xib文件的格式</strong></h3>

<p>为了演示xib文件格式在Xcode 4和Xcode 5中的差异，我首先在Xcode 4中创建了一个新的xib文件，并添加了一些view进去：一个UIScrollView，该scrollview中包含一些UIButton、UILable和TextView等。</p>

<p><img src="/images/2013/09/2.png"></p>

<p>然后我在工程导航窗口中右键单击该文件，并选择<code>Open As &gt; Source Code</code>。下面的链接中是看到的内容：</p>

<p><a href="https://gist.github.com/nilsou/6057457">Xcode 4生成的.xib文件</a>(需要点击“File suppressed. Click to show.”)</p>

<p>可以看到，这么简单的一个view居然有<code>1108行</code>代码！这太多了。</p>

<p>对开发者来说它的可读性非常的糟糕。这是开发者为什么不喜欢xib文件的主要原因(由此放弃使用interface builder)。</p>

<p>更糟糕的是这个xib文件的格式还具有不确定性。也就是说如果我在Interface Builder创建相同的UI界面，但是我们看到的文件内容并不是相同的。这就导致xib文件的合并非常的困难，甚至不可能进行合并。这事开发者不使用xib文件的另外一个重要原因。</p>

<h3><strong>* Xcode 5中xib文件的格式</strong></h3>

<p>接着，我在Xcode 5中打开同一个工程。当在Xcode 5中打开用Xcode 4创建的xib文件时，会提示将文件升级到新的格式。这里需要注意的是升级之后的文件只能在Xcode 5中打开，这种新格式的文件不能在老版本中的Xcode中打开。所以，如果是团队协作开发，那么升级的时候，需要确保所有的开发者都使用Xcode 5。</p>

<p><img src="/images/2013/09/3.png"></p>

<p>我点击<code>Upgrade</code>，然后再次打开xib文件的source code，看看有什么变化。如下链接中所示：</p>

<p><a href="https://gist.github.com/nilsou/6057474">Xcode 5生成的.xib文件</a>(需要点击“File suppressed. Click to show.”)</p>

<p><code>133行</code>！这与Xcode 4中创建的xib文件相差约10倍。可见苹果的开发团队已经对xib文件格式做了大量的简化。</p>

<p>再看看里面的具体内容，可以看出它的可读性也加强了。xib文件中的源代码现在也能够反应出view的层次(Interface Builder左边看到的内容结构！)，等熟悉之后，开发者可以直接对这个xml代码进行编写。</p>

<p>最重要的一点，可以看出Xcode 5生成的xib文件内容源码位置是确定的。这非常利于文件的合并。</p>

<h3><strong>小结</strong></h3>

<p>这种新的格式带来的最大好处不仅仅是增强开发者对xib文件的可读性，另外在大多数情况下，git还可以对xib文件进行自动合并，不用开发者手动进行。</p>

<p>现在如果还有开发者告诉你他不想用xib文件，那么请把这篇文章发给他看看吧，我相信已经没有太多理由不使用xib文件了。</p>

<p>其实在Xcode 5中不仅对Interface Builder进行了改善，还有其它一些功能也做了改进，例如自动布局约束的设置已经没有以前痛苦了。</p>
]]></content>
  </entry>
  
</feed>
