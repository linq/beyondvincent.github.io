<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS翻译 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iosfan-yi/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2013-10-19T23:50:21+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：如何拖放Sprites]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites/"/>
    <updated>2013-10-20T23:44:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/14.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/44270/sprite-kit-tutorial-how-to-drag-and-drop-sprites"><code>Sprite Kit Tutorial: How To Drag and Drop Sprites</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#ks">开始</a></li>
<li><a href="#xzjs">用触摸的方式选中sprite</a></li>
<li><a href="#ydjl">用触摸的方式移动sprite和layer</a></li>
<li><a href="#sssb">在Sprite Kit中如何使用手势识别</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p>本文中，你可以学到如下内容：</p>

<ul>
<li>利用触摸来拖放sprite的基本知识</li>
<li>利用触摸滚动view</li>
<li>How to keep coordinates straight in your head</li>
<li>如何在Sprite Kit中使用手势识别</li>
</ul>


<p>为了让本文有趣一点，这里提供了一些可爱的动物图片。</p>

<p>本文假设你已经了解了Sprite Kit的一些基本知识。如果还不了解的话，先看看下面的文章吧：</p>

<p><a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>下面我们就开始吧。</p>

<h3><a id="ks"></a>开始</h3>

<p>在实现触摸处理之前，我们先来创建一个基本的Sprite Kit工程，并在scene中显示出一些sprite(动物)和背景。</p>

<p>打开Xcode，选择<code>File\New Project\Application\SpriteKit Game</code>，然后单击<code>Next</code>。</p>

<p><img src="/images/2013/10/15.png" alt="" /></p>

<p>将工程命名为<code>DragDrop</code>，devices选择<code>iPhone</code>，然后单击<code>Next</code>，把工程保存到磁盘中。</p>

<p><img src="/images/2013/10/16.png" alt="" /></p>

<p>跟<a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>一样，我们希望这个程序只支持横屏显示(landscape)。所以在<code>Project Navigator</code>中选中<code>DragDrop</code>工程，然后选择<code>DragDrop</code> target，在弹出的画面中，只需要勾选上<code>Landscape Left</code>和<code>Landscape Right</code>。如下图所示：</p>

<p><img src="/images/2013/10/17.png" alt="" /></p>

<p>打开<code>ViewController.m</code>文件，并用下面的代码替换<code>viewDidLoad</code>方法(代码跟之前的一样)：</p>

<p>```objc
&ndash; (void)viewWillLayoutSubviews
{</p>

<pre><code>[super viewWillLayoutSubviews];

// Configure the view.
SKView * skView = (SKView *)self.view;
if (!skView.scene) {
  skView.showsFPS = YES;
  skView.showsNodeCount = YES;

  // Create and configure the scene.
  SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
  scene.scaleMode = SKSceneScaleModeAspectFill;

  // Present the scene.
  [skView presentScene:scene];
}
</code></pre>

<p>}
```</p>

<p>接着来这里下载本文需要用到的<a href="http://d1xzuxjlafny7l.cloudfront.net/downloads/DragDropImages.zip">图片资源</a>。下载并解压之后，将所有的文件拖到工程中，其中把<code>Copy items into destination group’s folder (if needed)</code>勾选上，然后单击<code>Finish</code>。</p>

<p><img src="/images/2013/10/18.png" alt="" /></p>

<p>完成上面的步骤之后，打开<code>MyScene.m</code>文件，并在<code>@implementation</code>上面添加一个class extension，并声明两个属性，如下所示：</p>

<p>```objc
@interface MyScene ()</p>

<p>@property (nonatomic, strong) SKSpriteNode <em>background;
@property (nonatomic, strong) SKSpriteNode </em>selectedNode;</p>

<p>@end
```</p>

<p>稍后会用到上面的这两个属性来存储背景图片，已经当前选中的node/sprite。接着在@interface前面添加如下这行代码：</p>

<p><code>objc
static NSString * const kAnimalNodeName = @"movable";
</code></p>

<p>稍后将会用这个字符串来标示可移动的node。接着找到<code>initWithSize:</code>方法，并用下面的代码替换里面的内容：</p>

<p>```objc
&ndash; (id)initWithSize:(CGSize)size {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 1) Loading the background
    _background = [SKSpriteNode spriteNodeWithImageNamed:@"blue-shooting-stars"];
    [_background setName:@"background"];
    [_background setAnchorPoint:CGPointZero];
    [self addChild:_background];

    // 2) Loading the images
    NSArray *imageNames = @[@"bird", @"cat", @"dog", @"turtle"];
    for(int i = 0; i &lt; [imageNames count]; ++i) {
      NSString *imageName = [imageNames objectAtIndex:i];
      SKSpriteNode *sprite = [SKSpriteNode spriteNodeWithImageNamed:imageName];
      [sprite setName:kAnimalNodeName];

      float offsetFraction = ((float)(i + 1)) / ([imageNames count] + 1);
      [sprite setPosition:CGPointMake(size.width * offsetFraction, size.height / 2)];
      [_background addChild:sprite];
    }
}

return self;
</code></pre>

<p>}
```</p>

<p>我们来看看上面的代码都干了什么。</p>

<p>1) 加载背景图片</p>

<p>上面方法中的第一部分代码是为scene加载背景图片(blue-shooting-stars.png)。并将该note的anchor设置为图片的左下角(0, 0)。</p>

<p>在Sprite Kit中，设置一个node的位置时，实际上是设置它的anchor。默认情况下，node的anchor被设置为node的正中间。在此，将anchor设置为左下角。</p>

<p>方法中，并没有设置背景图片的position，所以背景图的的位置默认为(0,0)。最终，图片的左下角位置是(0,0)，并向右边延伸。</p>

<p>2) 加载小动物</p>

<p>函数中接下来的代码是循环遍历列表中的图片，并将其加载到scene中。为了好的布局，其中各个node根据屏幕的长度来定位，另外还将这些node的名字设置为<code>kAnimalNodeName</code>。</p>

<p>之后将创建好的node添加到<code>_background</code>中。</p>

<p>OK！编译并运行程序，会看到屏幕中已经显示出了一些可爱的动物了。</p>

<p><img src="/images/2013/10/19.png" alt="" /></p>

<h3><a id="xzjs"></a>用触摸的方式选中sprite</h3>

<p>下面我们来实现一下根据用户当前触摸的位置判断出哪个sprite应该被选中。</p>

<p>用下面的代码替换<code>touchesBegan:withEvent:</code>：</p>

<p>```objc
&ndash;(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>UITouch *touch = [touches anyObject];
CGPoint positionInScene = [touch locationInNode:self];
[self selectNodeForTouch:positionInScene];
</code></pre>

<p>}
```</p>

<p>首先从touches set中获得touch。然后将touch的位置转换到一个指定node中的位置，上面的代码中使用了scene。让后将获得的方法传递给<code>selectNodeForTouch:</code>方法，该方法是一个新方法，下面我们就来看看这个方法的实现。</p>

<p>```objc
&ndash; (void)selectNodeForTouch:(CGPoint)touchLocation {
   //1
   SKSpriteNode <em>touchedNode = (SKSpriteNode </em>)[self nodeAtPoint:touchLocation];</p>

<pre><code>  //2
if(![_selectedNode isEqual:touchedNode]) {
    [_selectedNode removeAllActions];
    [_selectedNode runAction:[SKAction rotateToAngle:0.0f duration:0.1]];

    _selectedNode = touchedNode;
    //3
    if([[touchedNode name] isEqualToString:kAnimalNodeName]) {
        SKAction *sequence = [SKAction sequence:@[[SKAction rotateByAngle:degToRad(-4.0f) duration:0.1],
                                                  [SKAction rotateByAngle:0.0 duration:0.1],
                                                  [SKAction rotateByAngle:degToRad(4.0f) duration:0.1]]];
        [_selectedNode runAction:[SKAction repeatActionForever:sequence]];
    }
}
</code></pre>

<p>}
```</p>

<p>这是一个helper方法，它主要做三件不同的事情：</p>

<ol>
<li>通过scene(self)获得touchLocation位置对应的node。</li>
<li>获得匹配的node之后，检查一下这个node与上一次选中的node是否相同，如果相同的话，在这里直接就返回了。如果是一个新选中的node，或者还没有选中过，这个node会有一点小小的挪动动画，以此可以看出哪个node被选中了。不过在开始动画之前，需要移除当前已经选中node上的所有running actions，并在这个node上运行一个action：<code>rotateToAngle:duration:</code>。这样可以确保只有一个node在做动画，而另外的node恢复到原样。</li>
<li>这个if语句用来判断一下选中的node是否可以进行动画(只需要检查一下node的name就可以做出判断——还记得在<code>initWithSize:</code>方法中设置的这个属性值吗？)。如果选中的node可以做动画处理，那么就创建一个sequence action——是一个动画效果，就像在主屏幕中重排/删除程序那样的效果，然后在选中的node上运行这个sequence。为了避免动画运行完毕之后会停止，在这里运行了一个一直重复的action。</li>
</ol>


<p>下面将helper函数<code>degToRad</code>添加到文件的底部：</p>

<p>```objc
float degToRad(float degree) {</p>

<pre><code>return degree / 180.0f * M_PI;
</code></pre>

<p>}
```</p>

<p>由于Sprite Kit是利用弧度来做旋转效果的，所以上面这个方法将角度转换为弧度。</p>

<p>编译并运行程序，现在可以在屏幕上tap一个动物，当选中某个动物时，该动物会做出相应的动画效果，以表示被选中！</p>

<p><img src="/images/2013/10/20.png" alt="" /></p>

<h3><a id="ydjl"></a>用触摸的方式移动sprite和layer</h3>

<p>下面来看看如何移动这些动物！基本思路是这样的：实现<code>touchesMoved:withEvent:</code>方法，计算出距离上一次触摸移动了多远，如果有动物被选中，动物将被移动相应的距离，如果没有选中动物，那么就移动整个layer，这样用户可以从左向右的滚动layer。</p>

<p>在添加代码之前，我们先来探讨一下在Sprite Kit中，一个node是如何滚动的。</p>

<p>看看下面的图片：</p>

<p><img src="/images/2013/10/21.png" alt="" /></p>

<p>如上图所示，我们已经初始化了一个背景，所以背景的anchor点是(0, 0)，并且向右边扩展。黑色框中的区域表示当前的可视区域(window的大小)。</p>

<p>如果希望将图片往右边滚动100 points，可以通过将整个node往左边移动100 points，如第二幅图看到的效果一样。</p>

<p>当然，也可能希望不要移动太远。例如，不应该让layer可以往右边移动，否则会看到空白的点。</p>

<p>下面来看看相应的代码！将如下方法添加到文件的底部：</p>

<p>```objc
&ndash; (CGPoint)boundLayerPos:(CGPoint)newPos {</p>

<pre><code>CGSize winSize = self.size;
CGPoint retval = newPos;
retval.x = MIN(retval.x, 0);
retval.x = MAX(retval.x, -[_background size].width+ winSize.width);
retval.y = [self position].y;
return retval;
</code></pre>

<p>}</p>

<ul>
<li>(void)panForTranslation:(CGPoint)translation {
  CGPoint position = [<em>selectedNode position];
  if([[</em>selectedNode name] isEqualToString:kAnimalNodeName]) {
      [<em>selectedNode setPosition:CGPointMake(position.x + translation.x, position.y + translation.y)];
  } else {
      CGPoint newPos = CGPointMake(position.x + translation.x, position.y + translation.y);
      [</em>background setPosition:[self boundLayerPos:newPos]];
  }
}
```</li>
</ul>


<p>第一个方法<code>boundLayerPos:</code>是为了确保不会将layer移动到背景图片范围之外。在这里传入一个需要移动到的位置，然后该方法会对位置做适当的判断处理，以确保不会移动太远。</p>

<p>接着方法<code>panForTranslation:</code>首先判断一下_selectedNode是否为动物node，如果是的话，根据传入的参数来为node设置新的位置。如果是background layer，同样也会设置一个新的位置，只不过新的位置需要调用<code>boundLayerPos:</code>方法获得。</p>

<p>完成上面之后，可以实现<code>touchesMoved:withEvent:</code>方法了：</p>

<p>```objc
&ndash; (void)touchesMoved:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>UITouch *touch = [touches anyObject];
CGPoint positionInScene = [touch locationInNode:self];
CGPoint previousPosition = [touch previousLocationInNode:self];

CGPoint translation = CGPointMake(positionInScene.x - previousPosition.x, positionInScene.y - previousPosition.y);

[self panForTranslation:translation];
</code></pre>

<p>}
```</p>

<p>跟<code>touchesBegan:withEvent:</code>一样，先获得touch，然后将它的位置转换为scene中的相应位置。为了计算出移动的距离，需要上一次触摸的位置。</p>

<p>通过当前位置减去上一次的位置就可以计算出需要移动的距离了。最后调用<code>panForTransaltion:</code>方法，并将移动距离传入即可。</p>

<p>搞定！编译并运行程序，现在可以通过拖放的方式移动sprite(以及layer)了！</p>

<p><img src="/images/2013/10/22.png" alt="" /></p>

<h3><a id="sssb"></a>在Sprite Kit中如何使用手势识别</h3>

<p>在Sprite Kit中还可以使用手势识别来处理触摸！</p>

<p>手势识别可以识别不同的手势，如tap，double tap，swipe或pan。</p>

<p>通过手势识别，我们可以不用写大量的代码来识别不同的手势（如tap，double tap，swipe或pan），只需要创建一个手势识别对象并将其添加到view中，即可进行手势识别。当有手势发生，会有一个回调。</p>

<p>下面就来看看如何在Sprite Kit中使用手势识别。</p>

<p>首先，注释掉触摸处理方法：<code>touchesBegan:withEvent:</code>和<code>touchesMoved:withEvent:</code>(因为要使用不同的处理方法啦)。</p>

<p>然后添加如下方法：</p>

<p>```objc
&ndash; (void)didMoveToView:(SKView *)view {</p>

<pre><code>UIPanGestureRecognizer *gestureRecognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handlePanFrom:)];
[[self view] addGestureRecognizer:gestureRecognizer];
</code></pre>

<p>}
```</p>

<p>当scene第一次显示出来时会调用这个方法。在上面的方法中创建了一个pan手势识别器，并用当前的scene来对其做初始化，另外还传入一个callback：<code>handlePanFrom:</code>。接着把这个手势识别器添加到scene中的view里面。</p>

<p>注意：可能你会问为什么要在这里添加识别器，而不是在scene的init方法中。答案很简单：<code>SKScene</code>有一个view属性，保存着SKView——该view用来显示scene，不过只有scene显示到屏幕中时这个属性才会被初始化，所以在init方法被调用时该属性是nil的。此处的<code>didMoveToView:</code>类似于UIKit中的<code>viewDidAppear:</code>，当scene显示出来时，<code>didMoveToView:</code>会被调用。</p>

<p>接着，将下面的代码添加到<code>MyScene.m</code>文件底部：</p>

<p>```objc
&ndash; (void)handlePanFrom:(UIPanGestureRecognizer *)recognizer {</p>

<pre><code>if (recognizer.state == UIGestureRecognizerStateBegan) {

    CGPoint touchLocation = [recognizer locationInView:recognizer.view];

    touchLocation = [self convertPointFromView:touchLocation];

    [self selectNodeForTouch:touchLocation];


} else if (recognizer.state == UIGestureRecognizerStateChanged) {

    CGPoint translation = [recognizer translationInView:recognizer.view];
    translation = CGPointMake(translation.x, -translation.y);
    [self panForTranslation:translation];
    [recognizer setTranslation:CGPointZero inView:recognizer.view];

} else if (recognizer.state == UIGestureRecognizerStateEnded) {

    if (![[_selectedNode name] isEqualToString:kAnimalNodeName]) {
        float scrollDuration = 0.2;
        CGPoint velocity = [recognizer velocityInView:recognizer.view];
        CGPoint pos = [_selectedNode position];
        CGPoint p = mult(velocity, scrollDuration);

        CGPoint newPos = CGPointMake(pos.x + p.x, pos.y + p.y);
        newPos = [self boundLayerPos:newPos];
        [_selectedNode removeAllActions];

        SKAction *moveTo = [SKAction moveTo:newPos duration:scrollDuration];
        [moveTo setTimingMode:SKActionTimingEaseOut];
        [_selectedNode runAction:moveTo];
    }

}
</code></pre>

<p>}
```</p>

<p>当手势开始、改变(例如用户持续drag)，以及结束时，上面这个callback函数都会被调用。该方法会进入不同的case，以处理不同的情况。</p>

<p>当手势开始时，将坐标系统转换为node坐标系(注意这里没有便捷的方法，只能这样处理)。然后电泳之前写的helper方法<code>selectNodeForTouch:</code>。</p>

<p>当手势发生改变时，需要计算出手势移动的量。还在手势识别器已经为我们存储了手势移动的累计量(translation)！不过考虑到效果的差异，我们需要在UIKit坐标系和Sprite Kit坐标系中对坐标进行转换。</p>

<p>平移(pan)之后，需要把手势识别器上的translation设置为0，否则该值会继续被累加。</p>

<p>当手势结束之后，上面的函数中有一些有趣的代码！UIPanGestureRecognizer可以为我们提供一个移动的速度。通过这个速度可以对node做一个动画——滑动一小点，这样用户可以对node做一个快速的摇动，就像table view上的那种效果一样。</p>

<p>所以，在这里包含的代码用来计算基于速度移动的一个point，然后运行一个moveTo action(为了更加好看，附带<code>SKActionTimingEaseOut</code>效果)。</p>

<p>接着添加如下一个方法到文件中：</p>

<p>```objc
CGPoint mult(const CGPoint v, const CGFloat s) {</p>

<pre><code>return CGPointMake(v.x*s, v.y*s);
</code></pre>

<p>}
```</p>

<p>上面这个方法是将滚动的时间乘以速度。</p>

<p>编译并运行程序，现在应该可以用手势识别器滑动和移动动物了。</p>

<p><img src="/images/2013/10/23.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn2.raywenderlich.com/downloads/DragDropSpriteKit.zip">这里</a>。</p>

<p>至此，你应该知道如何在Sprite Kit程序中使用touch来移动node，以及如何在Sprite Kit中使用手势识别器。</p>

<p>现在，你也可以尝试利用别的手势识别器对上面的工程做扩展处理，例如pinch或rotate手势识别器——可以让猫长大哦！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：动画和纹理图集 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2/"/>
    <updated>2013-10-16T23:40:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/3.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>创建一个工程</li>
<li>纹理图集和熊</li>
<li>一个简单的动画</li>
<li><a href="#gbfx">改变动画运动的方向</a></li>
<li><a href="#ydx">在屏幕上让熊移动</a></li>
<li><a href="#hqhc">何去何从?</a></li>
</ul>


<h3><a id="gbfx"></a>改变动画运动的方向</h3>

<p>看起来不错哦！下面我们就来看看如何通过触摸屏幕上的点来控制熊的运动方向。在<code>MyScene.m</code>文件中做如下改动：</p>

<p>```objc
// Add these new methods
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{</p>

<pre><code>CGPoint location = [[touches anyObject] locationInNode:self];
CGFloat multiplierForDirection;

if (location.x &lt;= CGRectGetMidX(self.frame)) {
    //walk left
    multiplierForDirection = 1;
} else {
    //walk right
    multiplierForDirection = -1;
}

_bear.xScale = fabs(_bear.xScale) * multiplierForDirection;
[self walkingBear];
</code></pre>

<p>}</p>

<p>&ndash;(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{  <br/>
}
```</p>

<p>上面的代码会根据tap的位置，让<code>touchesEnded</code>方法判断tap处于屏幕正中间的左边还是右边。通过该方法，决定熊的朝向。熊的方向是通过Sprite Kit来改变的(通过负值乘以xScale就可以让熊朝向左边。)</p>

<p>编译并运行程序，一切正常的话，当你在屏幕上点击时，会发现熊的朝向发生了改变。</p>

<p><img src="/images/2013/10/12.png" alt="" /></p>

<h3><a id="ydx"></a>在屏幕上让熊移动</h3>

<p>下面我们让熊可以移动到屏幕的各个位置。</p>

<p>在<code>MyScene.m</code>文件中做如下改动：</p>

<p>```objc
// Comment out the call to start the bear walking
//[self walkingBear];</p>

<p>&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{</p>

<pre><code>//Stuff from below!
</code></pre>

<p>}</p>

<p>&ndash;(void)touchesBegan:(NSSet <em>)touches withEvent:(UIEvent </em>)event
{  <br/>
}</p>

<p>//add this method
&ndash;(void)bearMoveEnded
{</p>

<pre><code>[_bear removeAllActions];
</code></pre>

<p>}
```</p>

<p>如上所示，移除了<code>touchesEnded</code>方法中的所有代码。下面我们一步一步的往里面添加代码。</p>

<p>当想要停止动画的时可以调用方法<code>bearMoveEnded</code>。</p>

<p>下面就从<code>touchesEnded</code>方法开始吧：</p>

<p><code>1) 确定触摸的位置并定义一个变量代表熊的朝向</code></p>

<p><code>objc
CGPoint location = [[touches anyObject] locationInNode:self];
CGFloat multiplierForDirection;
</code></p>

<p>如上代码，利用常见的一个方法将触摸的位置转换为node坐标系中的位置。</p>

<p><code>2) 设置速度</code></p>

<p><code>objc
CGSize screenSize = self.frame.size;
float bearVelocity = screenSize.width / 3.0;
</code></p>

<p>如上，定义了熊移动的速度。可知熊从移动长度为屏幕宽度这么长时，需要3秒钟。由于不同设备的屏幕宽度可能会不同，所以在这里使用了self.frame.size，所以熊的速度应该是屏幕宽度/3秒。</p>

<p><code>3) 计算出熊在X和Y轴中移动的量</code></p>

<p><code>objc
 CGPoint moveDifference = CGPointMake(location.x - _bear.position.x, location.y - _bear.position.y);
</code></p>

<p>通过简单的利用触摸位置减去熊的位置，计算出熊在X和Y轴上应该移动的距离。</p>

<p><code>4) 计算出实际的移动距离</code></p>

<p><code>objc
float distanceToMove = sqrtf(moveDifference.x * moveDifference.x + moveDifference.y * moveDifference.y);
</code></p>

<p>上面的代码是计算出熊实际移动的直线距离(一个直角三角形的斜边：熊当前的位置和触摸位置)。关于游戏中涉及到的数学知识可以看看这本书：<a href="http://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1">Trigonometry for Game Programming</a>。</p>

<p><code>5) 计算出移动实际距离所需要花费的时间</code></p>

<p><code>objc
float moveDuration = distanceToMove / bearVelocity;
</code></p>

<p>通过移动的实际距离除以移动速度计算出需要花费的时间。</p>

<p><code>6) 需要的话对动画做翻转(Flip)处理</code></p>

<p>```objc
if (moveDifference.x &lt; 0) {</p>

<pre><code>multiplierForDirection = 1;
</code></pre>

<p>} else {</p>

<pre><code>multiplierForDirection = -1;
</code></pre>

<p>}
<em>bear.xScale = fabs(</em>bear.xScale) * multiplierForDirection;
```</p>

<p>上面的代码：确定熊往左还是往右移动。如果小于0，则往左移动，否则往右移动。</p>

<p>在这里，你的第一直觉可能是利用图片编辑器创建并使用对应另一个方向的图片。不过，之前我们学习过了如果通过乘法来改变sprite的xScale，进而改变sprite的方向。</p>

<p><code>7) 运行一些action</code></p>

<p>```objc
if ([_bear actionForKey:@&ldquo;bearMoving&rdquo;]) {</p>

<pre><code>//stop just the moving to a new location, but leave the walking legs movement running
[_bear removeActionForKey:@"bearMoving"];
</code></pre>

<p>} //1</p>

<p>if (![_bear actionForKey:@&ldquo;walkingInPlaceBear&rdquo;]) {</p>

<pre><code>//if legs are not moving go ahead and start them
[self walkingBear];  //start the bear walking
</code></pre>

<p>} //2</p>

<p>SKAction <em>moveAction = [SKAction moveTo:location duration:moveDuration];  //3
SKAction </em>doneAction = [SKAction runBlock:(dispatch_block_t)^() {</p>

<pre><code>    NSLog(@"Animation Completed");
    [self bearMoveEnded];
</code></pre>

<p>}]; //4</p>

<p>SKAction *moveActionWithDone = [SKAction sequence:@[moveAction,doneAction]]; //5</p>

<p>[_bear runAction:moveActionWithDone withKey:@&ldquo;bearMoving&rdquo;]; //6
```</p>

<ol>
<li>停止已有的移动action(因为要准备告诉熊移动到别的地方)。这里使用的key可以开始和停止以此命名的动画的运行。</li>
<li>如果熊还没有准备移动腿，那么就让熊的腿开始移动，否则它该如何走到新的位置呢。这里使用了我们之前使用过的方法，这个方法可以确保不启动一个已经运行着的动画(以key命名)。</li>
<li>创建一个移动action，并制定移动到何处，以及需要花费的时间。</li>
<li>创建一个done action，当熊到达目的地后，该action利用一个block调用一个方法来停止动画。</li>
<li>将上面的两个action设置为一个顺序action链，就是说让这两个action按照先后顺序运行(第一个运行完之后，再运行第二个)。</li>
<li>让熊开始运行action，并制定一个key为："bearMoving"。记住，这里的key用来判断熊是否需要移动到新的位置。</li>
</ol>


<p>注意：Sprite Kit支持两种action：<code>sequential</code>和<code>grouped</code>。<code>sequential</code> action表示action按照顺序执行。如果想要action同时运行，那么就使用<code>grouped</code>。</p>

<p>当然，也可以在sequential action中包含grouped action，反之亦然。更多相关内容请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043">Sprite Kit Programming Guide</a>中的<code>Adding Actions to Nodes</code>章节。</p>

<p>当动画执行完毕之后，<code>bearMoveEnded</code>会被调用，所有的动画都将被停止，并等待下一个移动方位。</p>

<p>搞定了！</p>

<p>现在编译并运行程序，一切正常的话，那么当点击屏幕时，熊会跟着移动。</p>

<p><img src="/images/2013/10/13.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从?</h3>

<p>这里是本文涉及到的<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/AnimatedBear.zip">工程示例</a>。</p>

<p>下面这些想法可以让动画更加有趣：</p>

<ul>
<li>尝试在方法<code>walkingBear</code>中增加或者减慢运动的速度，看看效果</li>
<li>试着在屏幕上同时显示多个熊。提示：创建多个sprite node，并赋予action。</li>
</ul>


<p>至此，你应该已经知道如何使用动画了。</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>

<p>……Sprite Kit教程：动画和纹理图集 2 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：动画和纹理图集 1]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/16/115-spritekit-tutorial-animations-and-texture-atlases-1/"/>
    <updated>2013-10-16T12:40:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/16/115-spritekit-tutorial-animations-and-texture-atlases-1</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/10/2.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#cjgc">创建一个工程</a></li>
<li><a href="#wltj">纹理图集和熊</a></li>
<li><a href="#jddh">一个简单的动画</a></li>
<li>改变动画运动的方向</li>
<li>在屏幕上让熊移动</li>
<li>何去何从?</li>
</ul>


<p>从本文，可以学习到如何使用iOS 7中的Sprite Kit框架创建一个简单的动画：在屏幕上行走的熊。</p>

<p>另外还可以学习到如何使用纹理图集来制作动画效果，如何在触摸事件发生时让熊移动，以及改变熊运动的方向。</p>

<p>学习本文之前，最好先看看下面的文章：
<a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>下面我们就开始吧。</p>

<h3><a id="cjgc"></a>创建一个工程</h3>

<p>我们先创建好一个工程架子——选择<code>File\New Project…</code>，在<code>iOS Application</code>中选择<code>Sprite Kit Game</code>，如下图所示：</p>

<p><img src="/images/2013/10/4.png"></p>

<p>选择<code>Next</code>，并将工程命名为<code>AnimatedBear</code>，把Class Prefix中的内容清除掉，并将Devices选择为<code>iPad</code>，如下图所示：</p>

<p><img src="/images/2013/10/5.png"></p>

<p>接着选择<code>Next</code>，将工程保存到磁盘中。</p>

<p>现在编译并运行程序的话，当点击屏幕时，可以看到在屏幕中有一个自动旋转的飞船。如下图所示：</p>

<p><img src="/images/2013/10/6.png"></p>

<p>这样工程架子就准备好了，下面我们去寻找一些熊的动画资源——从这里下载即可：<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/BearImages.zip">BearImages Art</a>。如下图所示：</p>

<p><img src="/images/2013/10/7.jpg" alt="熊的示例图片" /></p>

<p>上面下载到的图片有所需要的最大分辨率——iPad retina显示(2X)和non-retina版本(1x)。这些文件的命名方式为bear1..n@2x~ipad和bear1..n~ipad.png。</p>

<p>在这里，构建一个动画，你可以只需要将这些图片直接添加到Sprite Kit工程中即可。不过，还有另外一种更加方便的方法来构建动画——使用纹理图集。</p>

<h3><a id="wltj"></a>纹理图集和熊</h3>

<p>如果之前你没使用过纹理图集，那你可以把它想象为一副很大的图片，其中包括动画中需要使用到的各种图片。这个图集可以看做是一个文件，它指定了每个sprite的边界范围，当在代码中需要使用时，可以将这些sprite取出来。</p>

<p>使用纹理图集是因为Sprite Kit和图形引擎会对其做相应的优化处理。<code>后面这段话暂时不知道什么意思:</code></p>

<p>```</p>

<pre><code>If you use sprites within a texture atlas properly, rather than making one OpenGL ES draw call per sprite it just makes one per texture atlas sheet.
</code></pre>

<p>```</p>

<p>简而言之——使用纹理图集会非常的快，特别是有大量sprite的时候！</p>

<p>Xcode会自动的生成这个纹理图集文件，并指定好每个sprite的边界范围，这样当在代码中需要用到某个sprite的时候，可以方便取出来。这一切都会自动处理，开发者不用亲力为之。</p>

<p><code>
注意：当纹理图集有问题时(例如错误的图片等)，那么建议clean一下工程(Product\Clean)——这样可以强制让纹理图集重新构建。
</code></p>

<p>为纹理图集创建一个文件夹，并将图片文件放置到该文件夹中，然后在文件夹名称尾部添加<code>.atlas</code>。这样Xcode就能识别出.atlas扩展名，进而自动的将图片合并为一个纹理图集。</p>

<p>之前下载的图片资源中有一个名为<code>BearImages.atlas</code>的文件夹，里面包含了各种分辨率的图片(是其它两个文件夹中的图片合集)。</p>

<p>将名为<code>BearImages.atlas</code>的文件夹拖拽到程序中，如下图所示：</p>

<p><img src="/images/2013/10/8.png" alt="" /></p>

<p>当释放鼠标时，会看到如下图片中的对话框：是关于如何添加到工程中的。确保选中这三项：<code>Copy items into destination group’s folder</code>, <code>Create groups for any added folder</code>, 和 <code>the AnimatedBear</code>，然后点击<code>Finish</code>：</p>

<p><img src="/images/2013/10/9.png" alt="" /></p>

<p>在Xcode中展开这个文件夹<code>BearImages.atlas</code>，会看到如下内容：</p>

<p><img src="/images/2013/10/10.png" alt="" /></p>

<p>下面，是时候让熊动起来了！</p>

<h3><a id="jddh"></a>一个简单的动画</h3>

<p>这里我们先把熊显示在屏幕中间，并开启永久循环动画。</p>

<p>此处主要都是在<code>MyScene.m</code>中写代码。打开这个文件，并用下面的代码替换之：</p>

<p>```objc</p>

<h1>import &lt;AVFoundation/AVFoundation.h></h1>

<h1>import &ldquo;MyScene.h&rdquo;</h1>

<p>@implementation MyScene
{</p>

<pre><code>SKSpriteNode *_bear;
NSArray *_bearWalkingFrames;
</code></pre>

<p>}</p>

<p>&ndash;(id)initWithSize:(CGSize)size
{</p>

<pre><code>if (self = [super initWithSize:size]) {
    /* Setup your scene here */

    self.backgroundColor = [SKColor blackColor];

    // TODO...

}
return self;
</code></pre>

<p>}</p>

<p>&ndash;(void)update:(CFTimeInterval)currentTime {</p>

<pre><code>/* Called before each frame is rendered */
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>上面的代码很简单，只是定义了几个稍后会用到的变量。编译并运行一下，确保没有错误——会看到屏幕是黑色的。</p>

<p>接下来要让熊动起来，有5步需要处理，我们就来看看吧。</p>

<p>记得将下面的代码添加到<code>initWithSize</code>方法的<code>TODO</code>位置。</p>

<p><code>1) 构建一个用于保存行走帧(walking frame)</code></p>

<p><code>objc
NSMutableArray *walkFrames = [NSMutableArray array];
</code>
<code>2) 加载纹理图集</code></p>

<p><code>objc
SKTextureAtlas *bearAnimatedAtlas = [SKTextureAtlas atlasNamed:@"BearImages"];
</code>
上面的代码会从程序bundle的数据区中创建一个图集。Sprite Kit会根据设备的寻找对应分辨率的图片文件，在iPad retina上会使用BearImages@2x~ipad.png。</p>

<p><code>3) 构建帧列表</code></p>

<p>```objc
int numImages = bearAnimatedAtlas.textureNames.count;
for (int i=1; i &lt;= numImages/2; i++) {</p>

<pre><code>NSString *textureName = [NSString stringWithFormat:@"bear%d", i];
SKTexture *temp = [bearAnimatedAtlas textureNamed:textureName];
[walkFrames addObject:temp];
</code></pre>

<p>}
_bearWalkingFrames = walkFrames;
```</p>

<p>上面的代码根据图片名称从图集中循环获取到一个帧列表(这些图片的命名为bear1.png->bear8.png)，注意到<code>numImages</code>这个变量了吗？它为啥要除以2呢？</p>

<p>这是因为：纹理图集包含了所有分辨率的图片文件(non-retina和retina)。共有16个文件，每种分辨率有8个文件。要想加载某种分辨率的图片，就需要除以2。这样通过名称和计数器，就能获取到正确的分辨率图片。</p>

<p><code>4) 创建sprite，并将其位置设置为屏幕中间，然后将其添加到场景中</code></p>

<p><code>objc
SKTexture *temp = _bearWalkingFrames[0];
_bear = [SKSpriteNode spriteNodeWithTexture:temp];
_bear.position = CGPointMake(CGRectGetMidX(self.frame), CGRectGetMidY(self.frame));
[self addChild:_bear];
[self walkingBear];
</code></p>

<p>利用帧列表的第一帧构建一个sprite，然后将其放置到屏幕正中间。最后调用walkingBear方法，让熊开始走动。</p>

<p><code>5) 在initWithSize方法后面添加一个新的方法walkingBear</code></p>

<p>```objc
&ndash;(void)walkingBear
{</p>

<pre><code>//This is our general runAction method to make our bear walk.
[_bear runAction:[SKAction repeatActionForever:
                  [SKAction animateWithTextures:_bearWalkingFrames
                                   timePerFrame:0.1f
                                         resize:NO
                                        restore:YES]] withKey:@"walkingInPlaceBear"];
return;
</code></pre>

<p>}
```</p>

<p>上面的这个action会以0.1秒的间隔开始播放各帧。如果你的代码再次调用这个方法使动画重新开始的话，<code>walkingInPlaceBear</code>这个key会强制移除动画。这对于确保动画不相互干扰非常重要。<code>withKey</code>参数还提供了一个钟方法对动画进行检查，来判断其是否通过名称运行的。</p>

<p>这个action是永久重复的，内部的actionan <code>imateWithTextures</code>会按顺序动画播放帧列表中的图片。</p>

<p><code>完工!</code></p>

<p>现在编译并运行程序，一切正常的话，会在屏幕中看到一个会动的熊，如下图所示：</p>

<p><img src="/images/2013/10/11.png" alt="" /></p>

<p>……Sprite Kit教程：动画和纹理图集 1 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 3]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"/>
    <updated>2013-10-12T00:06:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/18.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>Sprite Kit的优点和缺点</li>
<li>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</li>
<li>Hello, Sprite Kit!</li>
<li>横屏显示</li>
<li>移动怪兽</li>
<li>发射炮弹</li>
<li><a href="#pzjcgs">碰撞检测和物理特性: 概述</a></li>
<li><a href="#pzjcsx">碰撞检测和物理特性: 实现</a></li>
<li><a href="#sw">收尾</a></li>
<li><a href="#hqhc">何去何从?</a></li>
</ul>


<h3><a id="pzjcgs"></a>碰撞检测和物理特性: 概述</h3>

<p>至此我们已经可以让炮弹任意的发射了——现在我们要让忍者利用炮弹来消灭这些怪物。下面就添加一些代码来给炮弹与怪物相交做检测。</p>

<p>Sprite Kit内置了一个物理引擎，这非常的棒！该物理引擎不仅可以模拟现实运动，还能进行碰撞检测。</p>

<p>下面我们就在游戏中使用Sprite Kit的物理引擎来检测炮弹与怪物的碰撞。首先，我们来看看需要做些神马事情：</p>

<ul>
<li><code>物理世界的配置</code>。物理世界是一个模拟的空间，用来进行物理计算。默认情况下，在场景(scene)中已经创建好了一个，我们可以对其做一些属性配置，例如重力感应。</li>
<li><code>为精灵(sprite)创建对应的物体(physics bodies)</code>。在Sprite Kit中，为了碰撞检测，我们可以为每个精灵创建一个相应的形状，并设置一些属性,这就称为<code>物体(physics body)</code>。注意：图文的形状不一定跟精灵的外形一模一样。一般情况，这个形状都是简单的、大概的(而不用精确到像素级别)——毕竟这已经足以够大多数游戏使用了。</li>
<li><code>将精灵分类</code>。在物体(physics body)上可以设置的一个属性是<code>category</code>，该属性是一个位掩码(bitmask)。通过该属性可以将精灵分类。在本文的游戏中，有两个类别——一类是炮弹，另一类则是怪物。设置之后，当两种物体相互碰撞时，就可以很容易的通过类别对精灵做出相应的处理。</li>
<li><code>设置一个contact(触点) delegate</code>。还记得上面提到的物理世界吗？我们可以在物理世界上设置一个<code>contact delegate</code>，通过该delegate，当两个物体碰撞时，可以收到通知。收到通知后，我们可以通过代码检查物体的类别，如果是怪物和炮弹，那么就做出相应的动作！</li>
</ul>


<p>上面大致介绍了一下游戏策略，下面就来看看如何实现！</p>

<h3><a id="pzjcsx"></a>碰撞检测和物理特性: 实现</h3>

<p>首先在<code>MyScene.m</code>文件顶部添加如下两个常量：</p>

<p>```objc</p>

<p>static const uint32_t projectileCategory     =  0x1 &lt;&lt; 0;
static const uint32_t monsterCategory        =  0x1 &lt;&lt; 1;</p>

<p>```</p>

<p>上面设置了两个类别，记住需要用位(bit)的方式表达——一个用于炮弹，另一个则是怪物。</p>

<p><code>注意:</code>看到上面的语法你可能感到奇怪。在Sprite Kit中category是一个32位整数，当做一个位掩码(bitmask)。这种表达方法比较奇特：在一个32位整数中的每一位表示一种类别(因此最多也就只能有32类)。在这里，第一位表示炮弹，下一位表示怪兽。</p>

<p>接着，在<code>initWithSize</code>中，将下面的代码添加到位置：添加player到场景涉及代码的后面。</p>

<p><code>objc
self.physicsWorld.gravity = CGVectorMake(0,0);
self.physicsWorld.contactDelegate = self;
</code>
上面的代码将物理世界的重力感应设置为0，并将场景设置位物理世界的代理（当有两个物体碰撞时，会受到通知）。</p>

<p>在<code>addMonster</code>方法中，将如下代码添加创建怪兽相关代码后面：</p>

<p><code>objc
monster.physicsBody = [SKPhysicsBody bodyWithRectangleOfSize:monster.size]; // 1
monster.physicsBody.dynamic = YES; // 2
monster.physicsBody.categoryBitMask = monsterCategory; // 3
monster.physicsBody.contactTestBitMask = projectileCategory; // 4
monster.physicsBody.collisionBitMask = 0; // 5
</code>
来看看上面代码意思：</p>

<ol>
<li>为怪兽创建一个对应的物体。此处，物体被定义为一个与怪兽相同尺寸的矩形(这样与怪兽形状比较接近)。</li>
<li>将怪兽设置位<code>dynamic</code>。这意味着物理引擎将不再控制这个怪兽的运动——我们自己已经写好相关运动的代码了。</li>
<li>将categoryBitMask设置为之前定义好的<code>monsterCategory</code>。</li>
<li><code>contactTestBitMask</code>表示与什么类型对象碰撞时，应该通知contact代理。在这里选择炮弹类型。</li>
<li><code>collisionBitMask</code>表示物理引擎需要处理的碰撞事件。在此处我们不希望炮弹和怪物被相互弹开——所以再次将其设置为0。</li>
</ol>


<p>接着在<code>touchesEnded:withEvent:</code>方法中设置炮弹位置的代码后面添加如下代码。</p>

<p>```objc</p>

<p>projectile.physicsBody = [SKPhysicsBody bodyWithCircleOfRadius:projectile.size.width/2];
projectile.physicsBody.dynamic = YES;
projectile.physicsBody.categoryBitMask = projectileCategory;
projectile.physicsBody.contactTestBitMask = monsterCategory;
projectile.physicsBody.collisionBitMask = 0;
projectile.physicsBody.usesPreciseCollisionDetection = YES;</p>

<p>```</p>

<p>在上面的代码中跟之前的类似，只不过有些不同，我们来看看：
1. 为了更好的效果，炮弹的形状是圆形的。
2. <code>usesPreciseCollisionDetection</code>属性设置为YES。这对于快速移动的物体非常重要(例如炮弹)，如果不这样设置的话，有可能快速移动的两个物体会直接相互穿过去，而不会检测到碰撞的发生。</p>

<p>接着，添加如下方法，当炮弹与怪物发生碰撞时，会被调用。注意这个方法是不会被自动调用，稍后会看到我们如何调用它。</p>

<p>```objc
&ndash; (void)projectile:(SKSpriteNode <em>)projectile didCollideWithMonster:(SKSpriteNode </em>)monster {</p>

<pre><code>NSLog(@"Hit");
[projectile removeFromParent];
[monster removeFromParent];
</code></pre>

<p>}
```</p>

<p>当怪物和炮弹发生碰撞，上面的代码会将他们从场景中移除。很简单吧！</p>

<p>下面该实现contact delegate方法了。将如下方法添加到文件中：</p>

<p>```objc
&ndash; (void)didBeginContact:(SKPhysicsContact *)contact
{</p>

<pre><code>// 1
SKPhysicsBody *firstBody, *secondBody;

if (contact.bodyA.categoryBitMask &lt; contact.bodyB.categoryBitMask)
{
    firstBody = contact.bodyA;
    secondBody = contact.bodyB;
}
else
{
    firstBody = contact.bodyB;
    secondBody = contact.bodyA;
}

// 2
if ((firstBody.categoryBitMask &amp; projectileCategory) != 0 &amp;&amp;
    (secondBody.categoryBitMask &amp; monsterCategory) != 0)
{
    [self projectile:(SKSpriteNode *) firstBody.node didCollideWithMonster:(SKSpriteNode *) secondBody.node];
}
</code></pre>

<p>}
```</p>

<p>还记得之前给物理世界设置的<code>contactDelegate</code>吗？当两个物体发生碰撞之后，就会调用上面的方法。</p>

<p>在上面的方法中，可以分为两部分来理解：</p>

<ol>
<li>该方法会传递给你发生碰撞的两个物体，但是并不一定符合特定的顺序(如炮弹在前，或者炮弹在后)。所以这里的代码是通过物体的category bit mask来对其进行排序，以便后续做出正确的判断。注意，这里的代码来自苹果提供的Adventure示例。</li>
<li>最后，检测一下这两个碰撞的物体是否就是炮弹和怪物，如果是的话就调用之前的方法。</li>
</ol>


<p>最后一步，为了编译器没有警告，确保private interface 中添加一下<code>SKPhysicsContactDelegate</code>：
<code>objc
@interface MyScene () &lt;SKPhysicsContactDelegate&gt;
</code>
现在编译并运行程序，可以发现，当炮弹与怪物接触时，他们就会消失！</p>

<h3><a id="sw"></a>收尾</h3>

<p>现在，本文的游戏快完成了。接下来我们就来为游戏添加音效和音乐，以及一些简单的游戏逻辑吧。</p>

<p>苹果提供的Sprite Kit里面并没有音频引擎(Cocos2D中是有的)，不过我们可以通过action来播放音效，并且可以使用AVFoundation播放后台音乐。</p>

<p>在工程中我已经准备好了一些音效和很酷的后台音乐，在本文开头已经将resources添加到工程中了，现在只需要播放它们即可！</p>

<p>首先在<code>ViewController.m</code>文件顶部添加如下import：</p>

<p><code>objc
@import AVFoundation;
</code></p>

<p>上面的语法是iOS 7中新的modules功能 —— 只需要使用新的关键字@import，就可以框架的头文件和库文件添加到工程中，这功能非常方便。要了解更多相关内容，请看到<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS 7 by Tutorials</a>中的第十章内容中的：What’s New with Objective-C and Foundation。</p>

<p>接着添加一个新的属性和private interface：</p>

<p><code>objc
@interface ViewController ()
@property (nonatomic) AVAudioPlayer * backgroundMusicPlayer;
@end
</code>
接着将下面的代码添加到<code>viewWillLayoutSubviews</code>方法中(在<code>[super viewWillLayoutSubviews]</code>后面)：</p>

<p><code>objc
NSError *error;
NSURL * backgroundMusicURL = [[NSBundle mainBundle] URLForResource:@"background-music-aac" withExtension:@"caf"];
self.backgroundMusicPlayer = [[AVAudioPlayer alloc] initWithContentsOfURL:backgroundMusicURL error:&amp;error];
self.backgroundMusicPlayer.numberOfLoops = -1;
[self.backgroundMusicPlayer prepareToPlay];
[self.backgroundMusicPlayer play];
</code></p>

<p>上面的代码会开始无限循环的播放后台音乐。</p>

<p>下面我们来看看如何处理音效。切换到<code>MyScene.m</code>文件中，并将下面这行代码添加到<code>touchesEnded:withEvent:</code>方法的顶部：</p>

<p>```objc
[self runAction:[SKAction playSoundFileNamed:@&ldquo;pew-pew-lei.caf&rdquo; waitForCompletion:NO]];</p>

<p>```</p>

<p>如上，一行代码就可以播放音效了，很简单吧！</p>

<p>下面，我们创建一个新的创建和layer，用来显示<code>你赢了(You Win)</code>或<code>你输了(You Lose)</code>。用模板<code>iOS\Cocoa Touch\Objective-C class</code>创建一个新的文件，将其命名为<code>GameOverScene</code>，并让其继承自<code>SKScene</code>，然后点击<code>Next</code>和<code>Create</code>。</p>

<p>接着用如下代码替换<code>GameOverScene.h</code>中的内容：</p>

<p>```objc</p>

<h1>import &lt;SpriteKit/SpriteKit.h></h1>

<p>@interface GameOverScene : SKScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size won:(BOOL)won;</p>

<p>@end
```</p>

<p>在上面的代码中导入了Sprite Kit头文件，并声明了一个特定的初始化方法，该方法的第一个参数用来定位显示的位置，第二个参数won用来判断用户是否赢了。</p>

<p>接着用下面的代码替换<code>GameOverLayer.m</code>中的内容：</p>

<p>```objc</p>

<h1>import &ldquo;GameOverScene.h&rdquo;</h1>

<h1>import &ldquo;MyScene.h&rdquo;</h1>

<p>@implementation GameOverScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size won:(BOOL)won {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 1
    self.backgroundColor = [SKColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];

    // 2
    NSString * message;
    if (won) {
        message = @"You Won!";
    } else {
        message = @"You Lose :[";
    }

    // 3
    SKLabelNode *label = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
    label.text = message;
    label.fontSize = 40;
    label.fontColor = [SKColor blackColor];
    label.position = CGPointMake(self.size.width/2, self.size.height/2);
    [self addChild:label];

    // 4
    [self runAction:
        [SKAction sequence:@[
            [SKAction waitForDuration:3.0],
            [SKAction runBlock:^{
                // 5
                SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
                SKScene * myScene = [[MyScene alloc] initWithSize:self.size];
                [self.view presentScene:myScene transition: reveal];
            }]
        ]]
    ];

}
return self;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>上面的代码可以分为4部分内容，我们来分别看看：</p>

<ol>
<li>将背景色设置为白色(与主场景一样颜色)。</li>
<li>根据<code>won</code>参数，将信息设置为"You Won"或"You Lose"。</li>
<li>这里的代码是利用Sprite Kit将一个文本标签显示到屏幕中。如代码所示，只需要选择一个字体，并设置少量的参数即可，也非常简单。</li>
<li>设置并运行有个有两个action的sequence。为了看起来方便，此处我将它们放到一块(而不是为每个action创建单独的一个变量)。首先是等待3秒，然后是利用<code>runBlock</code>action来运行一些代码。</li>
<li>演示了在Sprite Kit中如何过渡到新的场景。首先可以选择任意的一种不同的动画过渡效果，用于场景的显示，在这里选择了翻转效果(持续0.5秒)。然后是创建一个想要显示的场景，接着使用self.view的方法<code>presentScene:transition:</code>来显示出场景。</li>
</ol>


<p>OK，万事俱备，只欠东风了！现在只需要在主场景中，适当的情况下加载game over scene就可以了。</p>

<p>首先，在<code>MyScene.m</code>中导入新的场景：</p>

<p>```objc</p>

<h1>import &ldquo;GameOverScene.h&rdquo;</h1>

<p>```</p>

<p>然后，在<code>addMonster</code>中，用下面的代码替换最后一行在怪物上运行action的代码：</p>

<p>```objc
SKAction * loseAction = [SKAction runBlock:^{</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * gameOverScene = [[GameOverScene alloc] initWithSize:self.size won:NO];
[self.view presentScene:gameOverScene transition: reveal];
</code></pre>

<p>}];
[monster runAction:[SKAction sequence:@[actionMove, loseAction, actionMoveDone]]];
```</p>

<p>上面创建了一个"lose action"，当怪物离开屏幕时，显示game over场景。</p>

<p>在这里为什么<code>loseAction</code>要在<code>actionMoveDone</code>之前运行呢？
原因在于如果将一个精灵从场景中移除了，那么它就不在处于场景的层次结构中了，也就不会有action了。所以需要过渡到lose场景之后，才能将精灵移除。不过，实际上actionMoveDone永远都不会被调用——因为此时已经过渡到新的场景中了，留在这里就是为了达到教学的目的。</p>

<p>现在，需要处理一下赢了的情况。在private interface中添加一个新的属性：</p>

<p><code>objc
@property (nonatomic) int monstersDestroyed;
</code></p>

<p>然后将如下代码添加到<code>projectile:didCollideWithMonster:</code>的底部：</p>

<p>```objc
self.monstersDestroyed++;
if (self.monstersDestroyed > 30) {</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * gameOverScene = [[GameOverScene alloc] initWithSize:self.size won:YES];
[self.view presentScene:gameOverScene transition: reveal];
</code></pre>

<p>}
```</p>

<p>编译并运行程序，尝试一下赢了和输了会看到的画面！</p>

<h3><a id="hqhc"></a>何去何从?</h3>

<p>至此<code>Sprite Kit教程：初学者</code>结束！这里可以下到<a href="http://cdn2.raywenderlich.com/downloads/SpriteKitSimpleGame2.zip">完整的代码</a>。</p>

<p>希望本文能帮助你学习Sprite Kit，并写出你自己的游戏！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>

<p>……Sprite Kit教程：初学者 3 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：初学者 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"/>
    <updated>2013-09-29T00:06:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/09/10.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>感谢<a href="http://answerhuang.duapp.com/">answer哥</a>对本文翻译问题的提出。(2013-10-14)</p>

<h3><strong>目录</strong></h3>

<ul>
<li>Sprite Kit的优点和缺点</li>
<li>Sprite Kit vs Cocos2D-iPhone vs Cocos2D-X vs Unity</li>
<li>Hello, Sprite Kit!</li>
<li><a href="#hpxs">横屏显示</a></li>
<li><a href="#ydgs">移动怪兽</a></li>
<li><a href="#fspd">发射炮弹</a></li>
<li>碰撞检测: 概述</li>
<li>碰撞检测: 实现</li>
<li>收尾</li>
<li>何去何从?</li>
</ul>


<h3><a id="hpxs"></a>横屏显示</h3>

<p>首先，在Project Navigator中单击SpriteKitSimpleGame工程以打开target设置，选中SpriteKitSimpleGame target。然后在<code>Deployment Info</code>中，不要勾选<code>Portrait</code>，只选中<code>Landscape</code>和<code>Landscape Right</code>，如下所示：</p>

<p><img src="/images/2013/09/11.png"></p>

<p>编译并运行工程，会看到如下运行画面：</p>

<p><img src="/images/2013/09/12.png"></p>

<p>下面我们试着添加一个忍者(ninja)。</p>

<p>首先，下载此<a href="http://cdn3.raywenderlich.com/wp-content/uploads/2015/01/SpriteKitSimpleGameResources.zip">工程的资源文件</a>，并将其拖拽到Xcode工程中。确保勾选上<code>“Copy items into destination group’s folder (if needed)”</code>和<code>SpriteKitSimpleGame target</code>。</p>

<p>接着，打开<code>MyScene.m</code>，并用下面的内容替换之：</p>

<p>```objc</p>

<h1>import &ldquo;MyScene.h&rdquo;</h1>

<p>// 1
@interface MyScene ()
@property (nonatomic) SKSpriteNode * player;
@end</p>

<p>@implementation MyScene</p>

<p>&ndash;(id)initWithSize:(CGSize)size {</p>

<pre><code>if (self = [super initWithSize:size]) {

    // 2
    NSLog(@"Size: %@", NSStringFromCGSize(size));

    // 3
    self.backgroundColor = [SKColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:1.0];

    // 4
    self.player = [SKSpriteNode spriteNodeWithImageNamed:@"player"];
    self.player.position = CGPointMake(100, 100);
    [self addChild:self.player];

}
return self;
</code></pre>

<p>}</p>

<p>@end
```</p>

<p>我们来看看上面的代码。</p>

<ol>
<li>为了给player(例如忍者)声明一个私有变量，在这里创建了一个私有的interface，之后可以把这个私有变量添加到场景中。</li>
<li>在这里打印出了场景的size，至于什么原因很快你就会看到了。</li>
<li>在Sprite Kit中设置一个场景的背景色非常简单——只需要设置<code>backgroundColor</code>属性，在这里将其设置位白色。</li>
<li>在Sprite Kit场景中添加一个精灵同样非常简单，只需要使用<code>spriteNodeWithImageNamed</code>方法，并把一副图片的名称传递进去就可以创建一个精灵。接着设置一下精灵的位置，然后调用<code>addChild</code>方法将该精灵添加到场景中。在代码中将忍者的位置设置为<code>(100, 100)</code>，该位置是从屏幕的左下角到右上角计算的。</li>
</ol>


<p>编译并运行，看看效果如何…</p>

<p><img src="/images/2013/09/13.png"></p>

<p>呀！屏幕是白色的，并没有看到忍者。这是为什么呢？你可能在想设计之初就是这样的，实际上这里有一个问题。</p>

<p>如果你观察一下控制台输出的内容，会看到如下内容</p>

<p><code>objc
SpriteKitSimpleGame[3139:907] Size: {320, 568}
</code>
scene认为自己的宽度是320，高度则是568——实际上刚好相反!</p>

<p>我们来看看具体发生了什么：定位到<code>ViewController.m</code>的<code>viewDidLoad</code>方法：</p>

<p>```objc
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];

// Configure the view.
SKView * skView = (SKView *)self.view;
skView.showsFPS = YES;
skView.showsNodeCount = YES;

// Create and configure the scene.
SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
scene.scaleMode = SKSceneScaleModeAspectFill;

// Present the scene.
[skView presentScene:scene];
</code></pre>

<p>}
```</p>

<p>上面的代码中利用view的边界size创建了场景。不过请注意，当<code>viewDidLoad</code>被调用的时候，view还没被添加到view层级结构中，因此它还没有响应出布局的改变。所以view的边界可能还不正确，进而在viewDidLoad中并不是开启场景的最佳时机。</p>

<p><code>提醒</code>：要想了解更多相关内容，请看由Rob Mayoff带来的<a href="http://stackoverflow.com/questions/9539676/uiviewcontroller-returns-invalid-frame">最佳解释</a>。</p>

<p>解决方法就是将开启场景代码的过程再靠后一点。用下面的代码替换<code>viewDidLoad</code>:
```objc
&ndash; (void)viewWillLayoutSubviews
{</p>

<pre><code>[super viewWillLayoutSubviews];

// Configure the view.
SKView * skView = (SKView *)self.view;
if (!skView.scene) {
  skView.showsFPS = YES;
  skView.showsNodeCount = YES;

  // Create and configure the scene.
  SKScene * scene = [MyScene sceneWithSize:skView.bounds.size];
  scene.scaleMode = SKSceneScaleModeAspectFill;

  // Present the scene.
  [skView presentScene:scene];
}
</code></pre>

<p>}
```</p>

<p>编译并运行程序，可以看到，忍者已经显示在屏幕中了！</p>

<p><img src="/images/2013/09/14.png"></p>

<p>如上图所示，可以看到坐标系已经正确了，如果想要把忍者的位置设置为其中间靠左，那么在<code>MyScene.m</code>中用下面的代码来替换设置忍者位置相关的代码：</p>

<p>```objc</p>

<p>self.player.position = CGPointMake(self.player.size.width/2, self.frame.size.height/2);</p>

<p>```</p>

<h3><a id="ydgs"></a>移动怪兽</h3>

<p>接下来，我们希望在场景中添加一些怪兽，让忍者进行攻击。为了让游戏更有趣一点，希望怪兽能够移动——否则没有太大的挑战！OK，我们就在屏幕的右边，离屏的方式创建怪兽，并给怪兽设置一个动作：告诉它们往左边移动。</p>

<p>将下面这个方法添加到<code>MyScene.m</code>中：</p>

<p>```objc
&ndash; (void)addMonster {</p>

<pre><code>// Create sprite
SKSpriteNode * monster = [SKSpriteNode spriteNodeWithImageNamed:@"monster"];

// Determine where to spawn the monster along the Y axis
int minY = monster.size.height / 2;
int maxY = self.frame.size.height - monster.size.height / 2;
int rangeY = maxY - minY;
int actualY = (arc4random() % rangeY) + minY;

// Create the monster slightly off-screen along the right edge,
// and along a random position along the Y axis as calculated above
monster.position = CGPointMake(self.frame.size.width + monster.size.width/2, actualY);
[self addChild:monster];

// Determine speed of the monster
int minDuration = 2.0;
int maxDuration = 4.0;
int rangeDuration = maxDuration - minDuration;
int actualDuration = (arc4random() % rangeDuration) + minDuration;

// Create the actions
SKAction * actionMove = [SKAction moveTo:CGPointMake(-monster.size.width/2, actualY) duration:actualDuration];
SKAction * actionMoveDone = [SKAction removeFromParent];
[monster runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
</code></pre>

<p>}
```</p>

<p>在上面，我尽量让代码看起来容易理解。首先是通过一个简单的计算，确定怪兽出现的位置，并将该位置设置给怪兽，然后将其添加到场景中。</p>

<p>接着是添加动作(actions)。跟Cocos2D一样，Sprite Kit同样提供了很多方便的内置动作，例如移动动作、旋转动作、淡入淡出动作、动画动作等。在这里我们只需要在怪兽上使用3中动作即可：</p>

<ul>
<li><code>moveTo:duration:</code>使用这个动作可以把怪兽从屏幕外边移动到左边。移动过程中，我们可以指定移动持续的时间，上面的代码中，指定为2-4秒之间的一个随机数。</li>
<li><code>removeFromParent:</code>在Sprite Kit中，可以使用该方法，方便的将某个node从parent中移除，能有效的从场景中删除某个对象。此处，将不再需要显示的怪兽从场景中移除。这个功能非常的重要，否则当有源源不断的怪兽出现在场景中时，会耗尽设备的所有资源。</li>
<li><code>sequence:</code>sequence动作可以一次性就把一系列动作串联起来按照一定顺序执行。通过该方法我们就能让<code>moveTo:</code>方法先执行，当完成之后，在执行<code>removeFromParent:</code>动作。</li>
</ul>


<p>最后，我们需要做的事情就是调用上面这个方法<code>addMonster</code>，以实际的创建出怪兽！为了更加好玩，下面我们来让怪兽随着时间持续的出现在屏幕中。</p>

<p>在Sprite Kit中，并不能像Cocos2D一样，可以配置每隔X秒就回调一下update方法。同样也不支持将从上次更新到目前为止的时间差传入方法中。(非常令人吃惊！)。</p>

<p>不过，我们可以通过一小段代码来仿造这种行为。首先在<code>MyScene.m</code>的private interface中添加如下属性：</p>

<p><code>objc
@property (nonatomic) NSTimeInterval lastSpawnTimeInterval;
@property (nonatomic) NSTimeInterval lastUpdateTimeInterval;
</code>
通过<code>lastSpawnTimeInterval</code>可以记录着最近出现怪兽时的时间，而<code>lastUpdateTimeInterval</code>可以记录着上次更新时的时间。</p>

<p>接着，我们写一个方法，该方法在画面每一帧更新的时候都会被调用。记住，该方法不会被自动调用——需要另外写一个方法来调用它：</p>

<p>```objc
&ndash; (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {</p>

<pre><code>self.lastSpawnTimeInterval += timeSinceLast;
if (self.lastSpawnTimeInterval &gt; 1) {
    self.lastSpawnTimeInterval = 0;
    [self addMonster];
}
</code></pre>

<p>}
```</p>

<p>上面的代码中简单的将上次更新(update调用)的时间追加到<code>self.lastSpawnTimeInterval</code>中。一旦该时间大于1秒，就在场景中新增一个怪兽，并将<code>lastSpawnTimeInterval</code>重置。</p>

<p>最后，添加如下方法来调用上面的方法：</p>

<p>```objc
&ndash; (void)update:(NSTimeInterval)currentTime {</p>

<pre><code>// Handle time delta.
// If we drop below 60fps, we still want everything to move the same distance.
CFTimeInterval timeSinceLast = currentTime - self.lastUpdateTimeInterval;
self.lastUpdateTimeInterval = currentTime;
if (timeSinceLast &gt; 1) { // more than a second since last update
    timeSinceLast = 1.0 / 60.0;
    self.lastUpdateTimeInterval = currentTime;
}

[self updateWithTimeSinceLastUpdate:timeSinceLast];
</code></pre>

<p>}
```</p>

<p>Sprite Kit在显示每帧时都会调用上面的<code>update:</code>方法。</p>

<p>上面的代码其实是来自苹果提供的Adventure示例中。该方法会传入当前的时间，在其中，会做一些计算，以确定出上一帧更新的时间。注意，在代码中做了一些合理性的检查，以避免从上一帧更新到现在已经过去了大量时间，并且将间隔重置为1/60秒，避免出现奇怪的行为。</p>

<p>现在编译并运行程序，可以看到许多怪兽从左边移动到屏幕右边并消失。</p>

<p><img src="/images/2013/09/15.png"></p>

<h3><a id="fspd"></a>发射炮弹</h3>

<p>现在我们开始给忍者添加一些动作，首先从发射炮弹开始！实际上有多种方法来实现炮弹的发射，不过，在这里要实现的方法时当用户tap屏幕时，从忍者的方位到tap的方位发射一颗炮弹。</p>

<p>由于本文是针对初级开发者，所以在这里我使用<code>moveTo:</code>动作来实现，不过这需要做一点点的数学运算——因为<code>moveTo:</code>方法需要指定炮弹的目的地，但是又不能直接使用touch point(因为touch point仅仅代表需要发射的方向)。实际上我们需要让炮弹穿过touch point，直到炮弹在屏幕中消失。</p>

<p>如下图，演示了上面的相关内容：</p>

<p><img src="/images/2013/09/16.jpg"></p>

<p>如图所示，我们可以通过origin point到touch point得到一个小的三角形。我们要做的就是根据这个小三角形的比例创建出一个大的三角形——而你知道你想要的一个端点是离开屏幕的地方。</p>

<p>为了做这个计算，如果有一些基本的矢量方法可供调用(例如矢量的加减法)，那么会非常有帮助，但很不幸的时Sprite Kit并没有提供相关方法，所以，我们必须自己实现。</p>

<p>不过很幸运的时这非常容易实现。将下面的方法添加到文件的顶部(implementation之前)：</p>

<p>```objc
static inline CGPoint rwAdd(CGPoint a, CGPoint b) {</p>

<pre><code>return CGPointMake(a.x + b.x, a.y + b.y);
</code></pre>

<p>}</p>

<p>static inline CGPoint rwSub(CGPoint a, CGPoint b) {</p>

<pre><code>return CGPointMake(a.x - b.x, a.y - b.y);
</code></pre>

<p>}</p>

<p>static inline CGPoint rwMult(CGPoint a, float b) {</p>

<pre><code>return CGPointMake(a.x * b, a.y * b);
</code></pre>

<p>}</p>

<p>static inline float rwLength(CGPoint a) {</p>

<pre><code>return sqrtf(a.x * a.x + a.y * a.y);
</code></pre>

<p>}</p>

<p>// Makes a vector have a length of 1
static inline CGPoint rwNormalize(CGPoint a) {</p>

<pre><code>float length = rwLength(a);
return CGPointMake(a.x / length, a.y / length);
</code></pre>

<p>}
```
上面实现了一些标准的矢量函数。如果你看得不是太明白，请看这里关于<a href="http://www.mathsisfun.com/algebra/vectors.html">矢量方法的解释</a>。</p>

<p>接着，在文件中添加一个新的方法：</p>

<p>```objc
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event {</p>

<pre><code>// 1 - Choose one of the touches to work with
UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];

// 2 - Set up initial location of projectile
SKSpriteNode * projectile = [SKSpriteNode spriteNodeWithImageNamed:@"projectile"];
projectile.position = self.player.position;

// 3- Determine offset of location to projectile
CGPoint offset = rwSub(location, projectile.position);

// 4 - Bail out if you are shooting down or backwards
if (offset.x &lt;= 0) return;

// 5 - OK to add now - we've double checked position
[self addChild:projectile];

// 6 - Get the direction of where to shoot
CGPoint direction = rwNormalize(offset);

// 7 - Make it shoot far enough to be guaranteed off screen
CGPoint shootAmount = rwMult(direction, 1000);

// 8 - Add the shoot amount to the current position       
CGPoint realDest = rwAdd(shootAmount, projectile.position);

// 9 - Create the actions
float velocity = 480.0/1.0;
float realMoveDuration = self.size.width / velocity;
SKAction * actionMove = [SKAction moveTo:realDest duration:realMoveDuration];
SKAction * actionMoveDone = [SKAction removeFromParent];
[projectile runAction:[SKAction sequence:@[actionMove, actionMoveDone]]];
</code></pre>

<p>}
```</p>

<p>上面的代码中做了很多事情，我们来详细看看。</p>

<ol>
<li>SpriteKit为我们做了很棒的一件事情就是它提供了一个UITouch的category，该category中有<code>locationInNode:</code>和<code>previousLocationInNode:</code>方法。这两个方法可以帮助我们定位到在SKNode内部坐标系中touch的坐标位置。这样一来，我们就可以寻得到在场景坐标系中touch的位置。</li>
<li>然后创建一个炮弹，并将其放置到忍者的地方，以当做其开始位置。注意，现在还没有将其添加到场景中，因为还需要先做一个合理性的检查——该游戏不允许忍者向后发射。</li>
<li>接着利用touch位置减去炮弹的当前位置，这样就能获得一个从当前位置到touch位置的矢量。</li>
<li>如果X值小于0，就意味着忍者将要向后发射，由于在这里的游戏中是不允许的(真实中的忍者是不回头的！)，所以就return。</li>
<li>否则，将可以将炮弹添加到场景中。</li>
<li>调用方法<code>rwNormalize</code>，将offset转换为一个单位矢量(长度为1)。这样做可以让在相同方向上，根据确定的长度来构建一个矢量更加容易（因为1 * length = length）。</li>
<li>在单位矢量的方向上乘以1000。为什么是1000呢？因为着肯定足够超过屏幕边缘了 :]</li>
<li>将上一步中计算得到的位置与炮弹的位置相加，以获得炮弹最终结束的位置。</li>
<li>最后，参照之前构建怪物时的方法，创建<code>moveTo:</code>和<code>removeFromParent:</code>两个actions。</li>
</ol>


<p>编译并运行程序，现在忍者可以发射炮弹了！</p>

<p><img src="/images/2013/09/17.png"></p>

<p>……Sprite Kit教程：初学者 2 结束……</p>
]]></content>
  </entry>
  
</feed>
