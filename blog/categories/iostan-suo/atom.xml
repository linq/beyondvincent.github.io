<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS探索 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iostan-suo/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2014-01-21T17:45:36+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何自定义iOS中的控件]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios/"/>
    <updated>2014-01-20T17:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/18.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>下面先来看看目录：</p>

<ol>
<li>子类化UIControl

<ul>
<li>绘制用户界面

<ul>
<li>绘制背景</li>
<li>绘制用户的可操作区域</li>
<li>绘制手柄</li>
</ul>
</li>
<li>跟踪用户的操作

<ul>
<li>开始跟踪</li>
<li>持续跟踪</li>
<li>结束跟踪</li>
</ul>
</li>
<li>Target-Action模式</li>
</ul>
</li>
<li>如何使用自定义控件</li>
<li>总结</li>
<li>代码下载</li>
</ol>


<p>在开发过程中，有时候UIKit的标准控件并不能满足我们的需求，例如你需要一个控件能支持用户方便的选择0-360°之间的一个角度值，此时就需要根据自己的需求自定义控件了。</p>

<p>对于选择角度值的控件可以这样实现：创建一个圆形的滑块，用户通过拖动手柄操作就能选择角度值。实际上这样的控件在别的一些平台中你可能看到过，但是在UIKit中并没有。</p>

<p>本文就实现一个选择角度值的控件来介绍控件的自定义。下面先来看看到底要做成什么样子：</p>

<p><img src="/images/2014/01/12.png" alt="" /></p>

<h3>1. 子类化UIControl</h3>

<p><code>UIControl</code>是UIView的子类，它又是所有UIKit控件的父类(例如UIButton、UISlider和UISwitch等)。</p>

<p>UIControl的主要作用是创建相应的逻辑将action分发到对应的target，另外90%的情况下，它会根据自身的状态(例如Highlighted, Selected和Disabled等)来绘制用户界面。</p>

<p>通过UIControl，我们主要管理3个重要的任务：</p>

<ul>
<li>绘制用户界面</li>
<li>跟踪用户的操作</li>
<li>Target-Action模式</li>
</ul>


<p>在本文的圆形滑块中，我们要做如下一些事情：</p>

<p>定制一个用户界面(圆形滑块本身)，通过该界面用户可以通过手柄进行界面交互。用户的交互操作会被转换为控件target对应的action(控件将滑块按钮的frame origin转换为0-360之间的一个值，并用于target/action上)。</p>

<p>建议在学习本文的时候从文章尾部的连接中下载完整的示例工程。</p>

<p>下面我将从上面列出的3个重要任务一一进行分解介绍。</p>

<p>这些步骤都是模块化的，所以如果你对界面的绘制不感兴趣，可以跳过<code>绘制用户界面</code>，直接学习后面的步骤。</p>

<p>打开工程文件中的<code>TBCircluarSlider.m</code>文件。然后开始学习下面的内容。</p>

<h4>1.1 绘制用户界面</h4>

<p>我比较喜欢使用Core Graphics，唯一用到UIKit的就是通过textfield来显示滑块的值。</p>

<p><code>提醒</code>：此处需要用到一些<code>Core Graphics</code>知识，如果你不懂也没多大关系，我会尽量把代码做详细的讲解。</p>

<p>我们先来看看控件的不同组成部分，这样更有利于后面的学习。</p>

<p>首先，是用一个<code>黑色的圆环</code>当做滑块的背景。</p>

<p><img src="/images/2014/01/13.png" alt="" /></p>

<p><code>可操作区域(active area)</code>是一个从蓝色到紫色的梯度渐变效果。</p>

<p><img src="/images/2014/01/14.png" alt="" /></p>

<p>用户通过拖拽下面的这个手柄按钮来选择值：</p>

<p><img src="/images/2014/01/15.png" alt="" /></p>

<p>最后，用于显示选中值的<code>TextField</code>。在下一版中，我计划让用户可以通过键盘输入角度值。</p>

<p><img src="/images/2014/01/16.png" alt="" /></p>

<p>控件界面的绘制主要使用drawRect函数，首选我们需要获取到当前使用的图形上下文，如下代码所示：</p>

<p><code>objc
CGContextRef ctx = UIGraphicsGetCurrentContext();
</code></p>

<h5>1.1.1 绘制背景</h5>

<p>背景是360°的，所以只要用CGContextAddArc给图形上下文添加正确的path，并设置正确的stroke即可。</p>

<p>下面的代码可以就可以完成背景的绘制：</p>

<p>```objc
//Add the arc path
CGContextAddArc(ctx, self.frame.size.width/2, self.frame.size.height/2, radius, 0, M_PI *2, 0);</p>

<p>//Set the stroke colour
[[UIColor blackColor]setStroke];</p>

<p>//set Line width and cap
CGContextSetLineWidth(ctx, TB_BACKGROUND_WIDTH);
CGContextSetLineCap(ctx, kCGLineCapButt);</p>

<p>//draw it!
CGContextDrawPath(ctx, kCGPathStroke);
```</p>

<p><code>CGContextArc</code>函数的参数包括图形上下文，弧度的中心坐标点，以及半径(是一个私有变量)，接着是弧度开始和结束时的角度(在TBCircularSlider.m文件的头部可以看到一些关于数学计算的方法)，最后一个参数标示绘制的方向，0表示逆时针方向。</p>

<p>接下来的3行的代码是用来设置一些信息的，例如颜色和线条宽度等。最后使用<code>CGContextDrawPath</code>方法完成背景的绘制。</p>

<h5>1.1.2 绘制用户的可操作区域</h5>

<p>这部分需要利用一点小技巧才行。此处我们绘制一个线性渐变的掩码图片，下面看看原理：</p>

<p><img src="/images/2014/01/17.png" alt="" /></p>

<p>此处掩码图片的工作原理是可以看到原始渐变矩形框的一个孔。</p>

<p>在这里绘制的弧度有一个阴影，这是创建掩码图时使用了一点模糊的效果。</p>

<p>下面是创建掩码图的相关代码：</p>

<p><code>objc
UIGraphicsBeginImageContext(CGSizeMake(320,320));
CGContextRef imageCtx = UIGraphicsGetCurrentContext();
 
CGContextAddArc(imageCtx, self.frame.size.width/2  , self.frame.size.height/2, radius, 0, ToRad(self.angle), 0);
[[UIColor redColor]set];
 
//Use shadow to create the Blur effect
CGContextSetShadowWithColor(imageCtx, CGSizeMake(0, 0), self.angle/20, [UIColor blackColor].CGColor);
 
//define the path
CGContextSetLineWidth(imageCtx, TB_LINE_WIDTH);
CGContextDrawPath(imageCtx, kCGPathStroke);
 
//save the context content into the image mask
CGImageRef mask = CGBitmapContextCreateImage(UIGraphicsGetCurrentContext());
UIGraphicsEndImageContext();
</code></p>

<p>在上面的代码中首先创建了一个图形上下文，然后设置了一下阴影。通过<code>CGContextSetShadowWithColor</code>方法，我们可以设置如下内容：</p>

<ul>
<li>上下文</li>
<li>偏移量(此处不需要)</li>
<li>模糊值(该值是通过参数控制的：使用当前的角度除以20，当用户与此控件交互时，以此获得一个简单的动画模糊值)</li>
<li>颜色</li>
</ul>


<p>接着是根据当前的角度绘制一个相应的弧度。</p>

<p>例如，如果当前的角度变量是360°，那么就绘制一个圆弧，如果是90°，就绘制一个弧度为90°的一个弧。最后，利用<code>CGBitmapContextCreateImage</code>方法获取一张图片（刚刚绘制的弧）。这个图片就是我们所需要的掩码图了。</p>

<p>裁剪上下文：</p>

<p>现在我们已经有一个渐变的掩码图了。接着利用函数<code>CGContextClipToMask</code>对上下文进行裁剪——给该函数传入上面刚刚创建好的掩码图。代码如下所示：</p>

<p><code>objc
CGContextClipToMask(ctx, self.bounds, mask);
</code></p>

<p>最后我们来绘制渐变效果，代码如下所示：</p>

<p><code>objc
//Define the colour steps
CGFloat components[8] = {
    0.0, 0.0, 1.0, 1.0,     // Start color - Blue
    1.0, 0.0, 1.0, 1.0 };   // End color - Violet
 
CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();
CGGradientRef gradient = CGGradientCreateWithColorComponents(baseSpace, components, NULL, 2);
 
//Define the gradient direction
CGPoint startPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMinY(rect));
CGPoint endPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMaxY(rect));
 
    //Choose a colour space
CGColorSpaceRelease(baseSpace), baseSpace = NULL;   
 
//Create and Draw the gradient
CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint, 0);
CGGradientRelease(gradient), gradient = NULL;
</code></p>

<p>绘制渐变效果需要很多处理，不过我们可以将其分为4部分：</p>

<ul>
<li>定义颜色的变化范围</li>
<li>定义渐变的方向</li>
<li>选择颜色空间</li>
<li>创建并绘制渐变</li>
</ul>


<p>最终的显示效果(看到渐变矩形框的一部分)要归功于之前创建的掩码图。</p>

<p>另外，为了在背景边框模拟光线反射，我添加了一些灯光效果。</p>

<h5>1.1.3 绘制手柄</h5>

<p>下面我们根据当前的角度值，在的正确位置绘制出手柄。</p>

<p>实际上，在绘制过程中，这一步非常简单，复杂一点的就是计算一下手柄所在的位置。</p>

<p>这里我们需要使用三角函数将一个<code>标量值(scalar number)</code>转换为<code>CGPoint</code>。不要担心有多复杂，只需要使用Sin和Cos函数就可以完成。代码如下所示：</p>

<p><code>objc
-(CGPoint)pointFromAngle:(int)angleInt{
     
    //Define the Circle center
    CGPoint centerPoint = CGPointMake(self.frame.size.width/2 - TB_LINE_WIDTH/2, self.frame.size.height/2 - TB_LINE_WIDTH/2);
     
    //Define The point position on the circumference
    CGPoint result;
    result.y = round(centerPoint.y + radius * sin(ToRad(-angleInt))) ;
    result.x = round(centerPoint.x + radius * cos(ToRad(-angleInt)));
     
    return result;
}
</code></p>

<p>上面的代码中，指定一个角度值，然后计算出在圆周上面的位置，当然，这里需要圆周的中心点和半径。</p>

<p>使用sin函数在使用sin函数时，需要一个Y坐标值，而cos函数则需要X坐标值。</p>

<p>需要注意的是此处每个函数返回的值都认为半径为1，所以需要将所得结果乘以我们指定的半径大小，并相对于圆周的中心做计算。</p>

<p>希望下面的公式对你的理解有所帮助：</p>

<p><code>objc
point.y = center.y + (radius * sin(angle));
point.x = center.x + (radius * cos(angle));
</code></p>

<p>通过上面的计算，现在我们已经知道手柄的具体位置了，所以，接下来就直接将手柄绘制到指定位置即可，如下代码所示：</p>

<p><code>objc
-(void) drawTheHandle:(CGContextRef)ctx{
     
    CGContextSaveGState(ctx);
     
    //I Love shadows
    CGContextSetShadowWithColor(ctx, CGSizeMake(0, 0), 3, [UIColor blackColor].CGColor);
     
    //Get the handle position!
    CGPoint handleCenter =  [self pointFromAngle: self.angle];
     
    //Draw It!
    [[UIColor colorWithWhite:1.0 alpha:0.7]set];
    CGContextFillEllipseInRect(ctx, CGRectMake(handleCenter.x, handleCenter.y, TB_LINE_WIDTH, TB_LINE_WIDTH));
     
    CGContextRestoreGState(ctx);
}
</code></p>

<p>具体操作步骤如下：</p>

<ul>
<li>保存当前的上下文(当在一个单独的函数中进行绘制任务时，将上下文的状态进行保存是编程的一个好习惯)。</li>
<li>给手柄设置一些阴影效果</li>
<li>定义手柄的颜色，然后利用<code>CGContextFillEllipseInRect</code>将其绘制出来。</li>
</ul>


<p>我们在drawRect函数的最后调用上面这个方法：</p>

<p><code>objc
[self drawTheHandle:ctx];
</code></p>

<p>至此，我们就完成了绘制部分的任务。</p>

<h4>1.2 跟踪用户的操作</h4>

<p>在UIControl的子类中，我们可以<code>override</code>3个特殊的方法来提供一个自定义的跟踪行为</p>

<h5>1.2.1 开始跟踪</h5>

<p>当在控件的bound内发生了一个触摸事件，首先会调用控件的<code>beginTrackingWithTouch</code>方法。</p>

<p>我们就看看如何<code>override</code>这个方法吧：</p>

<p><code>objc
-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super beginTrackingWithTouch:touch withEvent:event];
 
    //We need to track continuously
    return YES;
}
</code></p>

<p>该函数返回的BOOl值决定着：当触摸事件是dragged时，是否需要响应。在我们这里的自定义控件中，是需要跟踪用户的dragging，所以返回YES。</p>

<p>上面这个函数有两个参数：touch对象和事件。</p>

<h5>1.2.2 持续跟踪</h5>

<p>在上一个方法中我们指定了这里的自定义控件需要跟踪一个持续的事件，所以当用户进行drag时，会调用一个特殊的方法：<code>continueTrackingWithTouch</code>：</p>

<p><code>objc
-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event
</code></p>

<p>该方法返回的BOOL值标示是否继续跟踪touch事件。</p>

<p>通过该方法我们可以根据touch位置对用户的操作进行过滤。例如，我们可以：仅当touch位置与手柄位置相交的时候才激活控件(activate control)。不过在这里我们的控制逻辑并不是这样的，我们希望用户点击任何位置都能对手柄做出相应的位置处理。</p>

<p>本文的该方法负责更新手柄的位置(在后面的一节中会看到我们把该位置信息传递给对应的target上)。</p>

<p>对上面这个方法的override代码如下所示：</p>

<p><code>objc
-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super continueTrackingWithTouch:touch withEvent:event];
 
    //Get touch location
    CGPoint lastPoint = [touch locationInView:self];
 
    //Use the location to design the Handle
    [self movehandle:lastPoint];
 
        //We'll see this function in the next section:
    [self sendActionsForControlEvents:UIControlEventValueChanged];
 
    return YES;
}
</code></p>

<p>上面的代码中，首先利用<code>locationInView</code>获取到touch的位置，然后将该位置传递给<code>moveHandle</code>方法，该方法会将传入的值转换为一个有效的手柄位置(a valid handle position)。</p>

<p>此处“a valid position”的意思是什么呢？</p>

<p>此控件的手柄只能在背景圆弧定义的边界范围内做移动，但是我们不希望强制要求用户必须在很小的圆弧内才可以移动手柄，如果非要这样的话，用户体验会非常的糟糕。</p>

<p><code>moveHandle</code>的任务就是负责把任意的位置值转变为手柄可移动的值，另外，另外，在该函数中，还对指定的滑块角度值做了转换，代码如下所示：</p>

<p><code>objc
-(void)movehandle:(CGPoint)lastPoint{
     
    //Get the center
    CGPoint centerPoint = CGPointMake(self.frame.size.width/2,
                                                                            self.frame.size.height/2);
     
    //Calculate the direction from the center point to an arbitrary position.
    float currentAngle = AngleFromNorth(centerPoint,
                                                                                lastPoint,
                                                                                NO);
    int angleInt = floor(currentAngle);
     
    //Store the new angle
    self.angle = 360 - angleInt;
 
    //Update the textfield
    _textField.text =  [NSString stringWithFormat:@"%d",
                                                                                                    self.angle];
     
    //Redraw
    [self setNeedsDisplay];
}
</code></p>

<p>上面代码中，实际上主要任务都是在<code>AngleFromNorth</code>方法中处理的：根据两个point，就会返回一个连接这两点对应的一个角度关系，<code>AngleFromNorth</code>方法的实现如下所示：</p>

<p><code>objc
static inline float AngleFromNorth(CGPoint p1, CGPoint p2, BOOL flipped) {
    CGPoint v = CGPointMake(p2.x-p1.x,p2.y-p1.y);
    float vmag = sqrt(SQR(v.x) + SQR(v.y)), result = 0;
    v.x /= vmag;
    v.y /= vmag;
    double radians = atan2(v.y,v.x);
    result = ToDeg(radians);
    return (result &gt;=0  ? result : result + 360.0);
}
</code></p>

<p>提醒：<code>angleFromNorth</code>方法并不是我的原创，我是直接从苹果提供的OSX示例clockControl中拿过来用的。</p>

<p>在上面的代码中，获得了角度值以后，将其存储到<code>angle</code>中，然后更新一下textfield的值。</p>

<p>接着调用的<code>setNeedDisplay</code>是为了确保<code>drawRect</code>被调用，以尽快在界面上做出相应的更新。</p>

<h5>1.2.3 结束跟踪</h5>

<p>当跟踪结束的时候，会调用下面这个方法：</p>

<p><code>objc
-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super endTrackingWithTouch:touch withEvent:event];
}
</code></p>

<p>在本文中，我们并不需要override该方法。如果当用户完成控件的界面操作时，你希望做一些处理，那么该方法会非常有用。</p>

<h4>1.3 Target-Action模式</h4>

<p>至此，圆形滑块控件可以工作了，你可以drag手柄，并能看到textfield中值的改变。</p>

<p>发送action——控件事件</p>

<p>如果希望自己定制的控件与UIControl行为保持一致，那么当控件的值发生变化时，需要进行通知处理：使用<code>sendActionsForControlEvents</code>方法，并制定特定的事件类型，值改变对应的事件一般是<code>UIControlEventValueChanged</code>。</p>

<p>苹果已经预定义了许多事件类型(Xcode中，在UIControlEventValueChanged上<code>cmd + 鼠标单击</code>)。如果你的控件是继承自UITextField，那么你可能会对<code>UIControlEventEdigitingDidBegin</code>感兴趣，如果你要做一个touch Up action，那么可以使用UIControlTouchUpInside。</p>

<p>如果你注意的话，在本文前部分的continueTrackingWithTouch方法里面，我们调用了<code>sendActionsForControlEvents</code>方法：</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>这样处理之后，当控件值发生变化时，每一个对象(观察者——注册该事件)都会收到响应的通知。</p>

<h3>2. 如何使用自定义控件</h3>

<p>到这里，我们的控件定制完毕，下面介绍如何在程序中使用自定义的控件。</p>

<p>打开文件<code>TBViewController.m</code>，看看<code>viewDidLoad</code>方法里面的代码：</p>

<p><code>objc
- (void)viewDidLoad
{
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.1 alpha:1];
     
    //Create the Circular Slider
    TBCircularSlider *slider = [[TBCircularSlider alloc]initWithFrame:CGRectMake(0, 60, TB_SLIDER_SIZE, TB_SLIDER_SIZE)];
     
    //Define Target-Action behaviour
    [slider addTarget:self action:@selector(newValue:) forControlEvents:UIControlEventValueChanged];
     
    [self.view addSubview:slider];
}
</code></p>

<p>在上面的代码中，给view设置了一个背景色，并通过调用<code>initWithFrame</code>方法实例化了一个圆形滑块(自定义的控件)。</p>

<p>注意：UIControl继承自UIView，所以它继承了UIView的所有方法。</p>

<p>接着定义了如何与该控件进行交互：使用<code>addTarget:action:forControlEvent:</code>方法。</p>

<p>该方法只是给控件的特定事件设置一下target-action。如果你还记得的话，上面层介绍过，每当用户移动手柄时，圆形滑块都会发送一个UIControlEventValueChanged事件。所以我们可以通过下面的代码为该事件注册一个action：</p>

<p><code>objc
[slider addTarget:self action:@selector(newValue:) forControlEvents:UIControlEventValueChanged];
</code></p>

<p>这样我们就可以创建一个<code>**newValue**</code>方法来处理值发生改变时的一些事情：</p>

<p><code>objc
-(void)newValue:(TBCircularSlider*)slider{
    NSLog(@"Slider Value %d",slider.angle);
}
</code></p>

<p>结合Target-Action，所以函数会受到action的发送者，此处是slider，通过这个slider，就能直接获取到角度值。</p>

<h3>3. 总结</h3>

<p>根据本文的具体步骤，你可以构建<code>任意你想要的控件</code>。</p>

<p>当然，也有其它一些方法来构建自定控件，不过本文基本上是按照苹果的建议来做的。</p>

<p>点击下图，下载代码</p>

<h3>4. 代码下载</h3>

<p><a href="https://github.com/ariok/TB_CircularSlider"><img src="/images/2013/11/34.jpg" alt="" /></a></p>

<p>本文由破船译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在下面的评论中回复我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给tableview cell添加动画]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/13/animation-tableview-cell/"/>
    <updated>2014-01-13T17:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/13/animation-tableview-cell</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/5.png" alt="" /></p>

<!--more-->


<h3>小引</h3>

<p>本文介绍如何利用给tableview cell添加动画。其实只需要很少的代码量就可以。本文参考<a href="http://www.thinkandbuild.it/animating-uitableview-cells/">Animating UITableView cells</a></p>

<p>下面先来看看最终的效果：</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNjYxMTgxOTQw" frameborder=0 allowfullscreen></iframe>


<p>从上面的视频中，可以看出，当cell显示出来的时候，是在Y和Z轴上进行3D旋转。</p>

<p>下面来看看是如何实现的：</p>

<p>首先假设你已经能够熟练使用UITableView了。那么我们只需要实现UITableViewDelegate中的tableView:WillDisplayCell:ForRowAtIndexPath:即可。当cell显示之前，会先调用该方法，因此给cell添加动画，在这个方法里面即可。</p>

<p>如下代码所示：</p>

<p>```objc
&ndash;(void)tableView:(UITableView <em>)tableView willDisplayCell:(UITableViewCell </em>)cell forRowAtIndexPath:(NSIndexPath *)indexPath{</p>

<pre><code>// 1. 配置CATransform3D的内容
CATransform3D transform;
transform = CATransform3DMakeRotation( (90.0*M_PI)/180, 0.0, 0.7, 0.4);
transform.m34 = 1.0/ -600;

// 2. 定义cell的初始状态
cell.layer.shadowColor = [[UIColor blackColor]CGColor];
cell.layer.shadowOffset = CGSizeMake(10, 10);
cell.alpha = 0;

cell.layer.transform = transform;
cell.layer.anchorPoint = CGPointMake(0, 0.5);

// 3. 定义cell的最终状态，并提交动画
[UIView beginAnimations:@"transform" context:NULL];
[UIView setAnimationDuration:0.5];
cell.layer.transform = CATransform3DIdentity;
cell.alpha = 1;
cell.layer.shadowOffset = CGSizeMake(0, 0);
cell.frame = CGRectMake(0, cell.frame.origin.y, cell.frame.size.width, cell.frame.size.height);
[UIView commitAnimations];
</code></pre>

<p>}
```</p>

<p>第一步：使用CATransform3D在Y和Z轴上做旋转设置。</p>

<p>第二步：定义cell的初始状态，添加了一些阴影，并将第一步中的transform设置给cell中layer的transform matrix。然后将anchor设置为0.0, 0.5，也就是说让cell围绕着左边进行旋转。</p>

<p>第三步：通过动画，将cell设置为原始状态。此处利用了UIView的beginAnimations:context方法来更新cell中layer的值。当然还有别的方法来执行动画，不过这种方法比较简单，我们可以设置持续时间。代码里面将transform设置为CATransform3DIdentity。</p>

<p>这样通过第二步和第三步的状态就能够引导动画，以此完成最终效果。</p>

<p>完整代码工程下载地址：
<a href="https://github.com/BeyondVincent/BVTableViewAnimation">BVTableViewAnimation</a></p>

<p>下面是网上看到的两个内容，可以参考：</p>

<p><a href="http://www.raywenderlich.com/49311/advanced-table-view-animations-tutorial-drop-in-cards">From RW：Table View Animations Tutorial: Drop-In Cards</a><a href="http://weibo.com/522056706"><code>@bluesea哈哈哈</code></a>推荐本链接</p>

<p><a href="http://maniacdev.com/2013/05/library-allowing-you-to-create-table-views-with-wacky-highly-detailed-ripple-cell-animations">Library Allowing You To Create Table Views With Wacky Highly Detailed Ripple Cell Animations
</a></p>

<p><a href="http://maniacdev.com/2012/05/drop-in-open-source-library-for-creating-wacky-animated-uitableviews">Drop-In Open Source Library For Creating Wacky Animated UITableViews</a></p>

<p>希望上面介绍对你有帮助，如果有问题，可以在下面的回复我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-3-iOS开发个人提升]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/11/129-my-iOS-growth-path-3/"/>
    <updated>2014-01-11T03:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/11/129-my-iOS-growth-path-3</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/12/11.png" alt="" /></p>

<!--more-->


<p>注1：这篇文章是我的iOS成长之路系列文章中的第三篇文章，第一篇文章：<a href="http://beyondvincent.com/blog/2013/12/17/125-my-iOS-growth-path-1/">iOS成长之路-1-入门</a>，第二篇文章：
<a href="http://beyondvincent.com/blog/2014/01/06/126-my-iOS-growth-path-2/">iOS成长之路-2-我的第一个iOS Demo</a>。</p>

<p>通过两周时间来学习iOS，我慢慢的叩开了iOS开发的大门，接下来就是一个积累的过程，我主要经历了如下几个过程：</p>

<ul>
<li>饱览群书</li>
<li>跟着项目一起成长</li>
<li>与同行交流</li>
<li>做一些分享</li>
</ul>


<h3>饱览群书</h3>

<p><img src="/images/2014/01/2.jpg" alt="" /></p>

<p>  在初期，我认为多看书对于个人提升有很大的帮助，从某方面来说，这主要扩展了个人对iOS开发的理解广度(初期，先不要急于往最深处研究)，接着把书上的讲解与动手编程结合起来，这样可以加强编程理解能力。</p>

<p>  我们在选择书籍的时候，一定要注重质量，如果英文阅读能力没问题的话，建议直接上英文书籍(不解释)，例如iOS 7 Programming Cookbook，或者iOS7 by Tutorials(最新版)，如果英文有点吃力的话，我还是建议看英文书籍，看不懂的可以用google翻译，记得我在搞Symbian开发时，看英文书籍的时候，就是经常开着<a href="http://translate.google.cn/?hl=en">google翻译</a>。相信硬着头皮看上1个月，你会有各种感受，慢慢的，你会觉得英文内容读起来非常的行云流水，理解起来也要比中文书籍更加容易。</p>

<p>  另外，这里所说的饱览群书，还包括网络中的学习资料，你可以订阅一些iOS开发相关的博文，我曾在<a href="http://beyondvincent.com/blog/2013/07/18/106/">这里汇总了一些不错的博文</a>，你可以去订阅一下。</p>

<p>  还有两个好去处就是苹果每年WWDC上出的大量参考资料，最新的是<a href="https://developer.apple.com/wwdc/videos/">WWDC2013</a>，值得拥有。再一个就是来自斯坦福大学的公开课<a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550">Developing iOS 7 Apps for iPhone and iPad</a>，也非常适合初学者。</p>

<p>  最后，你还需要知道两个网站：<a href="https://github.com/">github</a>和<a href="http://stackoverflow.com/">stackoverflow</a>，其中github主要用来存放开源项目，你可以在这里学习到别人的好多精华，好多内容都可以拿过来直接使用。另外stackoverflow是国外一个非常著名的问答网站，学习初期，基本上你遇到的问题，都能在这里搜索到相关解答。</p>

<h3>跟着项目一起成长</h3>

<p>  我觉得做项目对个人成长非常快，特别如果你是初学者的话，因为你是带着问题去学习和思考，同时也会有一定的项目压力，迫使你不断向前进。当然，大多数项目涉及到的知识点都会有一定的局限性，例如音乐类软件，主要涉及到多媒体相关的知识，而阅读类的软件可能对于图形渲染要求要多一点。虽说项目涉及到的知识有一定的局限性，但是它需要有一定的深度，所以对个人能力的提升也非常有效。</p>

<p>  另外，各项目之间也会有一些共性，只要你熟悉了这些共性，那么在项目之间可以拿来即用，例如网络模块、数据存储模块，有些项目可能就是业务需求不同而已。</p>

<p>  如果你是初学者的话，要是有机会做项目，千万不要错过学习提升的好机会，不要因为项目压力，有什么想法，相信顶住各种压力和想法，最后你会感谢曾经努力的你。</p>

<h3>与同行交流</h3>

<p><img src="/images/2014/01/3.jpg" alt="" /></p>

<p>  有时候，你一个人在做项目，或者学习时，或许会感觉到特别的孤独，有一颗特别强烈的心，迫切想跟外界进行交流：这个功能点的实现可行吗？有人遇到同样的问题吗？别人是如何做的？</p>

<p>  其实，在开发或学习过程中，多与同行进行交流是非常有帮助的，交流过程中，有时候一个问题，一个想法，经他人指点，会有茅塞顿开的感觉。当然，交流的对象最好是经验丰富的喽。这样你更加容易信任对方，可以把他当做你前进的灯塔。</p>

<p>  不过交流也需要一定的技巧的，遇到问题不是一味的去咨询别人，你可以首先尝试自己解决，别忘记google可是万能的。当然也并不是任何时候都有交流的对象。</p>

<h3>做一些分享</h3>

<p><img src="/images/2014/01/4.jpg" alt="" /></p>

<p>  我曾经翻译过一些文章和书籍，本来看起很简单的事情，内容也看得懂，但是要想再次用中文表达，其实并没有想象中的简单，好多时候，你需要反复的推敲，并查阅更多的资料，以确保你所翻译出来的内容是正确的。</p>

<p>  一句话，这东西需要坚持，到最后，你会发现收获颇多，另外，当你的成果得到别人的认可，对你也会是一个不小的鼓舞。</p>

<p>  当然，要是能做一些原创内容分享，是再好不过的了，因为在写原创内容的时候，你首先需要做一个构思和规划，并会查阅大量在资料，以此来支撑自己分享的内容。这要比翻译文章高级多了，翻译那是跟着别人的思路走。</p>

<p>  或许你想说，你是程序员，只会写代码，不擅长写文章，写总结，那反过来，试问谁有天生会呢？相信熟能生巧，你所需要做的就是大胆的迈出第一步，然后坚持走下去！</p>

<h3>小结</h3>

<p>上面写了一些关于iOS开发提升方面的内容，实际上这不仅针对iOS，其它平台或者技术同样可行。希望文中的内容对你有些许帮助，如果有任何疑问，可以在下方给我留言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-2-我的第一个iOS Demo]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/06/126-my-iOS-growth-path-2/"/>
    <updated>2014-01-06T23:57:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/06/126-my-iOS-growth-path-2</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/12/10.png" alt="" /></p>

<!--more-->


<p>注1：本文是我在2011年9月花了两周时间做了我的第一个iOS Demo。这篇文章是我的iOS成长之路系列文章中的第二篇文章，第一篇文章请来这里看<a href="http://beyondvincent.com/blog/2013/12/17/125-my-iOS-growth-path-1/">iOS成长之路-1-入门</a></p>

<p>下面先来看看本文的目录</p>

<ol>
<li>概述</li>
<li>业务需求</li>
<li>框架</li>
<li>UML图(用例图、类图和时序图)</li>
<li>小结</li>
</ol>


<p>通过2周时间的开发，我的第一个iOS程序基本做成。下面对此次开发进行一个总结。以便清楚的认识到开发中的一些不足之处，并积累下经验，为后续的开发提供参考依据。</p>

<h3>概述</h3>

<p>由于时间紧迫，在这里做了一个精简版的移动办公软件。主要功能有如下：</p>

<ol>
<li>登录</li>
<li>查看公司发文待办</li>
<li>查看文件单信息(包括意见信息)</li>
<li>浏览正文</li>
<li>浏览附件</li>
<li>填写意见</li>
<li>发送文件</li>
</ol>


<p>下面将主要从此次开发涉及到的业务，结合使用到的框架、类图和时序图进行优势和缺陷总结。</p>

<h3>业务需求</h3>

<p>本次开发中涉及到的业务逻辑并不复杂，可以用下图进行表述：</p>

<p><img src="/images/2013/12/12.png" alt="" /></p>

<p>我们可以把整个过程理解为：数据获取->数据展现->数据采集->数据反馈</p>

<p>根据以往开发经验，手机终端的移动办公业务逻辑基本上都可以从上图中的流程演变而来。针对这样的业务需求，下面进行适合这种业务的框架设计介绍。针对不同的开发平台，这种框架会有一些缺陷，同样也会在此进行描述，并希望能够找到相关好的解决方案。</p>

<h3>框架</h3>

<p>下图是此次MOA开发过程中的整体框架图。此图分为3个层面。最上面一层是UI显示层，在这一层主要是做UI方面的显示，是直接面向用户的。中间一层是DataAccess层，该层主要的职责是把所有的数据访问都封装起来。第三层封装了网络访问、文件操作、XML文件解析等。</p>

<p><img src="/images/2013/12/13.png" alt="" /></p>

<p>下面将根据此次开发的情况，说一下该框架的优点和缺陷</p>

<p>优点：</p>

<ol>
<li>整体层次清晰，不复杂，无论是老手还是新手，都能够很容易的理解并在上面进行开发。</li>
<li>实现了UI与数据的分离，降低了业务数据与UI界面的耦合度，无论是UI需求的变更，还是业务数据逻辑的变化，都减小了UI与数据之间的影响。</li>
<li>模块的独立性，各个模块之间能够做到到低耦合、高内聚，这样不仅在此次开发中方便使用，在今后的相关开发项目中，也可以直接拿过来就使用，加强了软件的复用性原则。</li>
</ol>


<p>缺陷：</p>

<ol>
<li>数据的凌乱性。在此次开发中，数据全部放在DataAccess里面，这样加深了UI界面与DataAccess层的耦合度，在一定程度上，不利于UI与数据分离。</li>
<li>有时会导致级联修改。尤其是体现在至上而下的方向。如果在表示层需要增加一个功能，为保证其设计符合分层结构，可能在第二层，第三层都需要做相应的调整。</li>
<li>第三层里面的封装性不强，特别是XML解析的封装。在针对面向对象开发，应该加强XML解析的抽象封装力度，否则编写的代码就是一次性的，不符合软件开发的复用性原则，同时也增加了代码的无用性，并不利于后期的变更维护。</li>
<li>目前设计中存在一个严重的缺陷，现在只能同时并发一个网络异步请求。这在前期的设计中没有做详细的考虑，下一步需要对此进行改进，已达到支持多个异步请求操作。</li>
</ol>


<p>一些思考：</p>

<ol>
<li>为了加强UI与数据之间的高度分离，有必要对DataAccess进行职责细化。在第二层里面增加一个模块：model[数据模型]，把DataAccess中的数据提取到model里面，DataAccess和UI涉及到的数据都存放在model模块中。这样更加利于DataAccess层的职责单一，以及数据与UI能够更好的进行交互。</li>
<li>在第三层里面，涉及到的一些数据操作，需要加强抽象封装力度，尽量做到软件的复用性。此次开发中，特别是xml数据的解析，前期没有做好充分的考虑与设计，导致后期出现了单纯的copy and paste。非常不好。需要想办法改进。</li>
<li>在iOS中，cocoa touch层已经为开发者提供了视图控制器功能，这在简单UI开发中已经非常够用并实用了。在此，有个预想，如果在遇到UI比较复杂的应用场景时，cocoa touch提供的视图控制器不能满足，可能需要在框架中增加视图管理模块。</li>
<li>UI方面积累：iOS在UI方面做得非常到位，做iOS开发，必须在UI方面做出特色，根据相关业务(移动办公)特点，真正使做出的产品是用户需要的、用户想要的。因此，在UI方面，必须要加强技术与经验的积累。</li>
</ol>


<h3>UML图(用例图、类图和时序图)</h3>

<h4>用例图</h4>

<p>此次实现的功能，可以用下图进行描述。主要涉及到的业务是公司的发文。</p>

<p><img src="/images/2013/12/14.png" alt="" /></p>

<p>在此版中，没有进行考虑，并且在今后的版本中需要进行考虑的功能如下：</p>

<ol>
<li>消息的及时推送功能。此功能非常的有必要去思考并实现。一条待办事项，极有可能是紧急待办处理的，这是就需要用户在第一时间得知消息，并及时的进行处理。并且，在消息的传递过程中，消息应该主动被用户所感知。
所以一条新消息来了，不能依赖于用户主动的去服务器刷新数据进行检测新消息，应该提供一种机制，当服务器上有某个用户的新消息时，能够及时的传达给用户。</li>
<li>用户使用环境的可配置型。随着用户的办公场景变化、所处网络变化，我们的移动办公系统，最理想的要求就是根据所述变化，智能的进行选择用户环境，最低要求是能够方便用户进行环境的可配置。</li>
<li>日志。把用户的登录、操作信息记录并归档。</li>
<li>意见反馈。通过意见反馈窗口，用户可以方便的把自己对使用软件上的一些想法、建议、问题反馈给我们，我们也能够及时的了解到用户的意见，并对用户意见进行考虑，对我们的软件进行更新升级。</li>
</ol>


<p>在此版中已经存在的，但是在今后版本中需要加强考虑的功能：</p>

<ol>
<li>应用与用户交互体验方面(界面易操作、功能易理解、应用的鲁棒性等)</li>
</ol>


<h4>类图</h4>

<p>下图展示了此次开发中的类图结构，为了图的层次清晰，图中绘制了主要的相关类，有些使用到的类在图中并没有绘制出来，但他们同样是此次开发中重要的一部分。此次涉及到的类图并不复杂，在此次总结中，不做类图的详细介绍。通过下图，很容易理解类图的结构。</p>

<p><img src="/images/2013/12/15.png" alt="" /></p>

<h4>时序图</h4>

<p>下面涉及到的内容比较偏重与细节。基于以下原因，在这里只针对登录操作的时序图进行介绍。</p>

<ol>
<li>本次开发涉及到比较复杂的时序是网络的请求过程。</li>
<li>登录请求的完整过程，与其他请求(待办请求、文件单信息请求等)基本相同。</li>
</ol>


<p>当用户点击登录按钮进行登录操作时，会走如下流程(正常情况下，即网络通畅，用户名和密码正确)
首先LoginViewController通过DataAccess，调用XMLHandle的方法，组合出请求的数据内容(下图中的第3、4步骤)。</p>

<p>然后DataAccess调用ASIHTTPRequest方法(下图中第5、6步骤)，发起异步登录请求。</p>

<p>其次，当网络请求完毕，ASIHTTPRequest的delegate(第7步骤[DataAccess遵从])会被调用，DataAccess会调用XMLHandle的方法(第8步骤)进行数据解析。</p>

<p>最后DataAccess会调用DataAccess的delegate（第10步骤），通知LoginViewController，登录请求结果，LoginViewController根据请求的结果，如果登录成功，则进入待办列表画面(第11步骤)。</p>

<p><img src="/images/2013/12/16.png" alt="" /></p>

<h3>小结</h3>

<p>以上就是我在学习iOS开发初期，写的第一个iOS Demo，功能虽然略显粗糙，希望对初学者有一个参考作用，如果你对文中的内容有想法，可以在下面的回复中，与我交流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-1-入门]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/12/17/125-my-iOS-growth-path-1/"/>
    <updated>2013-12-17T21:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/12/17/125-my-iOS-growth-path-1</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/12/9.png" alt="" /></p>

<!--more-->


<p>注1：我是从2011年8月份开始接触iOS开发的，到现在(2013年12月)有2年多时间了，我计划用3篇文章来总结一下我的iOS成长之路：入门、我的第一个iOS Demo和iOS开发个人提升，本文就是这个系列中的第一篇文章。</p>

<p>注2：本文主要以日志的形式记录我的iOS入门。共计2周时间。由于时间有点久远了，可能有些内容已经过时了。</p>

<h3>第一周</h3>

<p><code>2011年8月15日</code>：今天第一次接触苹果电脑，还是一体机。在开电脑的时候遇到了一个笑话，居然找不到苹果一体机的开机键在哪里。后来还是谷歌大神告诉了我——在背后。这事太囧了。你也跟我遇到一样的笑话吗？</p>

<p><code>2011年8月16日</code>：iOS开发环境熟悉。电脑已经安装配置好了iPhone开发环境，但是作为一名入门级选手，还是从环境的搭建开始比较好。所以我还是先来熟悉一下iOS开发环境。</p>

<p>iPhone开发环境通常有两种</p>

<ol>
<li>一种是在windows xp下通过虚拟机安装苹果操作系统——俗称黑苹果，然后在进行开发环境的配置。</li>
<li>另外一种就是购置一台苹果电脑，在里面配置开发环境（推荐此方法）。</li>
</ol>


<p>在配置开发环境的时候需要用到iOS SDK和Xcode。开发环境提供了一个模拟器，大多数情况下开发的应用可以在模拟器上进行测试，有些涉及到3G网络等实际环境下测试的，就需要一台iPhone手机。也建议及早的把应用部署到真机上进行测试，以避免后期部署出现不可预测的情况，来降低风险。</p>

<p>我今天制定的学习路线是这样的：学习obj-c开发语言，熟悉iPhone-SDK，掌握iOS开发框架。</p>

<p><code>2011年8月17日</code>：今天完成了iPhone下HelloWorld程序编写，初步了解在iPhone中开发应用的流程。还有一些疑问需要解决：delegate的使用、mvc在iPhone下应用、Interface Builder的入门操作、iPhone应用程序框架的了解。</p>

<p><code>2011年8月18日</code>：今天主要学习了如下内容：</p>

<ol>
<li>iOS技术概览： iOS操作系统是iPhone、iPod touch 以及iPad设备的核心，下图是iOS的框架图，由4层构成。其中Cocoa Touch层是我们在今后开发中主要接触的一层，并且建议能用这层提供的服务，尽量不用底层的，因为这样不仅可以减少代码量，也可以减少程序的复杂度。</li>
</ol>


<p><img src="/images/2013/12/8.jpg" alt="" /></p>

<p>2、对iOS中插座变量、动作、视图控制器和视图切换进行了学习。</p>

<p>A:插座变量(IBOutlet):是在视图控制器中定义的变量，通过IBOutlet关键字在控制器里面定义之后，在IB(Interface Builder)里面可以体现出来。</p>

<p>B:控制器中定义的动作主要用来响应IB里面设计好的按钮对应的事件，当然，在响应事件之前，需要需要将IB中的控件事件连接到控制器中定义的动作。</p>

<p>C、视图控制器：视图控制器的主要作用如下1）、创建和管理视图；2）、管理视图上显示的数据；3）、设备方向变化、调整视图大小以适应屏幕；4）、负责视图和模型之间的数据传递</p>

<p>在debug代码的时候遇到一个问题，就是界面上的按钮按下去了，但是写好的动作代码没有执行。得出的结论是：IB和XCode之间没有做好相关的关联（有时候会忘记了进行关联，相信熟能生巧！）</p>

<p><code>2011年8月18日</code>：今天主要学习了iPhone开发中的两项内容，键盘的输入和屏幕旋转。</p>

<p>1、键盘输入：在iPhone中，用户数据的输入主要是通过触摸键盘。由于在iPhone上的应用程序受到屏幕大小的限制，有时候当输入面板弹出来的时候，会将文本控件遮挡，这时候就需要对程序进行调整。首先是通过观察键盘的状态（显示\隐藏），然后对UI重新进行布局。观察键盘状态的时候，用到了iOS里面提供的NSNotificationCenter,它的原理就是观察者模式，提供了注册、通知、删除事件三个重要功能，当键盘状态发生改变了，就是通过它告诉我们的，然后我们在根据具体情况进行UI调整。实际上，NSNotificationCenter在iOS里面用得比较多，比如说网络状况的、打电话的状态等一些系统属性都会在这里获得。</p>

<p>键盘状态的监听关键代码：</p>

<p>```objc
[[NSNotificationCenter defaultCenter]</p>

<pre><code>     addObserver:self
     selector:@selector(keyboardWillShow:)
     name:UIKeyboardWillShowNotification
     object:self.view.window];
</code></pre>

<p>[[NSNotificationCenter defaultCenter]</p>

<pre><code>     addObserver:self
     selector:@selector(keyboardWillHide:)
     name:UIKeyboardWillHideNotification
     object:nil];
</code></pre>

<p>```</p>

<p>2、屏幕旋转：在iPhone手机上，可能会面对不同方向屏幕上显示的UI要保持一致性。在此，我们需要知道屏幕何时方向改变了，然后对UI进行调整。</p>

<p><code>一周学习总结</code>：通过这一周的iPhone开发学习，给我的感觉是在iPhone上做应用比较方便快捷，特别是做UI设计的时候，SDK提供了良好的环境（IB），让我在入门的阶段也能够感觉到乐趣。这不得不抱怨一下Symbian了，开发入门门槛高，UI界面开发忒不友好，程序调试让人奔溃。</p>

<p><code>下周计划</code>：</p>

<ol>
<li>系统的学习obj-c语言。obj-c语言是iOS中推荐使用的开发语言。</li>
<li>学习iOS中的视图控制器、页签栏控制器、导航控制器等，以便能构建出不同类型的应用程序。</li>
<li>学习表视图的使用，SQLite3数据库的了解，文件的读写等。</li>
</ol>


<h3>第二周</h3>

<p><code>2011年8月22日</code>：今天主要学习了Objective-C 里面的如下内容（协议和分类还没有详细的学习）：</p>

<ol>
<li>类和对象（类的定义、继承、实例化、类内存的释放）。类的定义与C++等面向对象语言定义类似，都是先声明，然后实现。不过Objective-C只支持单继承，这跟C++有区别。类的扩展可以通过继承、分类和协议来进行。</li>
<li>消息。在Objective-C里面，想让对象完成某个处理时，需要给对象发送一条消息，这类似与C++里面的函数调用，但是与之有很大的区别，函数通常是静态绑定的，在编译程序的时候函数所执行的代码已经确定（多态除外）。而消息则是在执行时才确定的。</li>
<li>内存管理。通过引用计数和自动释放池来对内存进行管理。</li>
<li>类对象。在Objective-C中类自身就是对象，经常用来实例化一个对象，如下面的消息使用（类作为消息的接受者）：[Class alloc];</li>
</ol>


<p>Objective-C在C的基础上，实现了面向对象。其比较大的特点有：内存管理使用引用技术、自动释放池和运行时确定消息执行者、协议、分类等。</p>

<p><code>2011年8月23日</code>：今天主要学习了Objective-C的如下内容：</p>

<pre><code> 分类、协议、属性和页签栏视图使用学习
</code></pre>

<ol>
<li>分类：当我们想给某个类加一些方法时，如果不想通过继承这个类来实现，可以通过分类给这个类加一些行为，这个过程与继承相比更加轻量化。下面的代码演示了如何进行分类：</li>
</ol>


<p>```objc
@interface NSString (SubClass)
&ndash;(id) DoSomething();
@end</p>

<p>@implementation NSString (SubClass)
&ndash;(id) DoSomething(){
// do something&hellip;
}
@end
```</p>

<p>上面的代码中，第一行，SubClass为分类名字，NSString为需要增加行为的类。分类的实现与一般类的实现类似。</p>

<ol>
<li>协议：协议是一组预定义的行为方法，这类似于java中的接口。协议分为正式协议和非正式协议，前者为采用该协议的类必须实现它定义的方法，后者为可选。协议的定义如下代码所示：</li>
</ol>


<p><code>objc
@protocol HandleEvent
{
-(void) HandleKeyUpEvent;
-(void) HandleKeyDownEvent : (id) sender;
}
</code></p>

<ol>
<li>属性：属性的作用是用来访问对象的实例变量。使用方法是在头文件(.h)中用@property来声明一个属性，然后在实现文件(.m)中用@synthesize来告诉编译器自动生成某个变量的访问器方法。如下：
```objc
@property (nonatomic, retain) NSString *name;</li>
</ol>


<p>@synthesize name;
```</p>

<ol>
<li>页签栏视图使用：使用sdk提供的Tab Bar Application模板来创建页签栏视图，然后可以通过自己加入页签栏项目（TarBarItem控件）。</li>
</ol>


<p><code>2011年8月24日</code>：今天主要学习了基于导航栏视图的应用程序开发和对学习iOS中的视图控制器进行了一个回顾</p>

<ol>
<li>基于导航栏视图的应用程序开发。页签栏应用程序适用于包含多个视图，用户可以在不同的视图间进行快速切换，这些视图涉及到的数据迁移关系不强。如果我们遇到的数据具有层次关系，比如：邮件列表视图和邮件详细信息视图两个画面具有紧密的逻辑关系【选择邮件列表中的某邮件，进入到邮件详细信息】，此时使用基于导航的视图应用程序是最好的选择。</li>
</ol>


<p>在导航应用程序中，使用的是UINavigationController特殊视图控制器，这方便管理层次内容的导航。</p>

<ol>
<li>iOS中视图控制器学习回顾。iOS中的视图控制器主要作用是创建和管理视图，负责视图和模型中数据的交互和响应视图中的交互事件。UIViewController是iOS里面的视图控制器基本类型，还有UINavigationController和UITabBarController等集合控制器类型的视图控制器。</li>
</ol>


<p><code>2011年8月25日</code>：今天主要学习了如下内容：表视图(UITableView)sqlite数据库的使用</p>

<ol>
<li><p>表视图(UITableView)的使用：表视图一般用在基于导航视图控制器应用中，在UIKit框架中，表视图以行的形式展现UI，其中每一行我们可以对其进行个性化，比如添加图标之类的。在我们的程序中也会经常用到表视图，在使用表视图的时候我们要注意两个概念：1）表视图的数据源(UITableViewDataSource)，主要是为表视图提供数据的一个协议。2）表视图代理(UITableViewDelegate)，主要用来处理表视图的一些事件，并对表视图进行一些编辑和删除操作。</p></li>
<li><p>iPhone中sqlite数据库的使用。sqlite支持在iPhone中使用。sqlite是一款轻型的数据库，主要运用在嵌入式设备中，在使用中，不需要对其进行配置和管理配置，并且可以支持到2TB大的数据文件。不仅支持常用的sql语句：增删改查，还有其它一些丰富的功能：事物等。
 在iPhone中使用sqlite数据库与在其它平台中使用sqlite数据库基本不需要变化多少。这也方便在不同平台间进行复用。
 基本使用步骤：创建数据库，创建表，插入数据，查询数据。
 打开数据库代码：
通过调用sqlite3_open函数，打开一个已经存在的数据库，如果不存在，则创建它。如下代码所示：</p></li>
</ol>


<p>```objc
&ndash;(void) openDB {</p>

<pre><code>    if (sqlite3_open([[self filePath] UTF8String], &amp;db) != SQLITE_OK) {
            sqlite3_close(db);
            NSAssert(0, @"Database failed to open.");
    }
</code></pre>

<p>}
```</p>

<p>创建表和插入表：组合出了sql语句，然后执行sqlite提供的方法sqlite3_exec即可。如果过程中出现错误，sqlite3_exec方法也会有错误反馈。
查询内容：先组合一个查询语句，例如：@&ldquo;SELECT * FROM TABLENAME"，然后实例化一个sqlite3_stmt对象，查询出来的数据放在这里面，再通过调用sqlite3_prepare_v2，和sqlite3_step两个方法对数据进行查询，查询出来的内容还需要sqlite3_column_text方法进行内容的提取。</p>

<p><a href="http://www.sqlite.org/">sqlite</a> 这是sqlite的官方网站，相关的内容，我们在使用过程中，可以在这里进行查阅。</p>

<p><code>2011年8月26日</code>：今天主要学习了如下内容：iOS中文件的使用。
iOS提供了如下方法来进行文件的读写和管理</p>

<ol>
<li>Foundation 框架：</li>
</ol>


<p>1)如果应用程序的数据表现形式为属性列表（property list），则可以使用NSPopertyListSerializaitonAPI把属性列表转换为NSData对象，然后可以使用NSData类提供的方法把数据写到磁盘中。</p>

<p>2) Foundation 框架提供了NSFileHandle类进行文件的存取操作，也提供了NSFileManager类在文件系统里面进行文件的创建和操作(删除，重命名等)。</p>

<ol>
<li>Core OS：
1)支持C语言的接口对文件进行操作：fopen、fread和fwrite（需要import头文件：stdio.h）
2)支持mmap和munmap，以高效的load大容量文件到内存中，以进行内容的存取。(需要import头文件：mman.h)。</li>
</ol>


<p>下面是一些文件访存的原则，我们在创建文件或者把数据写入到文件中时，最好遵循下面的原则：
写入disk中的数据量最小化。文件的操作相对来说慢，并且是写到Flash disk中，Flash disk的寿命是有限（可擦写约1000000次）的。一些具体的细节有利于我们最小化对文件相关的操作：</p>

<p>1)只写文件修改过的那一部分。避免把只修改了几个字节的文件全部进行写操作。</p>

<p>2)当定义文件内容格式时，把需要平凡修改的内容进行分组，从而在每一次进行disk写操作时，最小化需要写入到disk中的块数。</p>

<p>3)如果是结构化内容组成的数据进行随机存取，则存储在SQLite数据库中。特别是，当处理的数据可能会增长到几百M时，这非常重要。</p>

<p>避免把缓存文件写到disk中。此规则的唯一例外是，当应用程序退出，下次再启动时，需要上次退出时的程序状态，则可以把程序退出时的状态进行存储。</p>

<p><code>基于iPhone OS-based设备的文件系统是区分大小写的，这有别于xp系统，无论什么时候，只要是在进行文件名的编码时，必须确保大小写的精确匹配，否则代码不能打开或访问文件。</code></p>

<p><code>一周学习总结</code></p>

<p>本周主要学习了如下内容：</p>

<ol>
<li>Objective-C语言学习，对iOS中开发使用的语言进行了全面的学习，了解了其中的基本使用。</li>
<li>页签栏视图控制器、导航栏视图控制器和表视图的使用，视图控制器在iOS应用中，起到非常重要的作用，是与UI进行衔接的重要部件。</li>
<li>iOS中sqlite的使用，文件的操作。在iOS中，我们可以使用sqlite进行数据的存取，iOS也提供了对文件的操作。</li>
<li>iPhone应用程序的首选项，在iOS中，我们可以把应用程序的一些配置数据存储在首选项中，通过首选项，进行配置。 通过本周的学习，对iOS开发有了进一步的掌握。</li>
</ol>


<p><code>下周学习计划</code></p>

<ol>
<li>学习iOS中的网络开发、多线程、事件处理和媒体（图像&amp;声音），进一步学习iOS中的UI</li>
<li>开发一个iOS Demo</li>
</ol>


<h3>第三周</h3>

<p>没有第三周啦！！！
上周计划iOS中的网络开发、多线程、事件处理和媒体（图像&amp;声音）就在后续的日子里面学习吧。</p>

<h3>总结</h3>

<p>iOS开发的学习我感觉还是比较容易上手的，由于开发环境的限制，对于初学者来说最大的困难可能在于设备，不过相信想要学习该平台的人来说，初期的投入还是值得的。还记得毕业那会刚参加工作就学习Symbian开发，Symbian虽然有3个大分支：诺基亚支持的S60，索爱的UIQ和DoCoMo的MOAP，它们都由全球的通信巨头掌控着，但是Symbian对于初学者太难以入门了，这无疑将许多开发者挡在大门之外。当时一个HelloWorld例子就足足让我啃上一个月。紧接着二阶段构造、活动对象、调度器等都是让人头晕目眩的东西。其实心里对Symbian一直恋恋不忘，这不又多说了几句，哎！大浪淘沙！</p>

<p>下一篇文章我将介绍第三周和第四周做的事情：我写的第一个iOS Demo。</p>
]]></content>
  </entry>
  
</feed>
