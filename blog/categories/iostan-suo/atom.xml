<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS探索 | 破船之家]]></title>
  <link href="http://BeyondVincent.github.io/blog/categories/iostan-suo/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2014-01-26T15:39:10+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对NSArray中自定义的对象进行排序]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects/"/>
    <updated>2014-01-26T16:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/20.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://ios-blog.co.uk/tutorials/how-to-sort-nsarray-with-custom-objects/">How to sort NSArray with custom objects</a>。</p>

<p>我们开发的每个程序都会使用到一些数据，而这些数据一般被封装在一个自定义的类中。例如一个音乐程序可能会有一个Song类，聊天程序则又一个Friend类，点菜程序会有一个Recipe类等。有时候我们希望在程序中显示的列表数据是按照一定顺序进行排列的，本文我们就来看看在iOS中有哪些方法可以对NSArray中的对象进行排序。下面是目录：</p>

<ul>
<li>小引</li>
<li>使用NSComparator进行排序</li>
<li>使用NSDescriptor进行排序</li>
<li>使用selector进行排序</li>
</ul>


<h3>小引</h3>

<p>我们将要排序的对象是一个Persion类，如下定义：</p>

<p>```objc
@interface Person : NSObject</p>

<p>@property (nonatomic, copy) NSString <em>name;
@property (nonatomic, copy) NSString </em>surname;
@property (nonatomic, strong) NSDate *dateOfBirth;</p>

<p>@end
```</p>

<p>而数组中包含如下内容：</p>

<p><code>objc
Smith John 03/01/1984
Andersen Jane 16/03/1979
Clark Anne 13/09/1995
Smith David 19/07/1981
Johnson Rose 22/02/1989
</code></p>

<h3>使用NSComparator进行排序</h3>

<p>comparator实际上是用一个block对象作比较操作。它的定义如下所示：</p>

<p><code>objc
typedef NSComparisonResult (^NSComparator)(id obj1, id obj2);
</code></p>

<p>上面的参数(obj1、obj2)就是我们将要做比较的对象。block返回的结果为NSComparisonResult类型来表示两个对象的顺序。</p>

<p>要对整个数组做排序，则需要使用NSArray的<code>sortArrayUsingComparator:</code>方法，如下代码所示：</p>

<p>```objc
NSArray <em>sortedArray = [self.persons sortedArrayUsingComparator:^NSComparisonResult(Person </em>p1, Person *p2){</p>

<pre><code>return [p1.surname compare:p2.surname];
</code></pre>

<p>}];
```</p>

<p>最终排序的结果如下所示：</p>

<p><code>objc
Andersen Jane
Clark Anne
Johnson Rose
Smith John
Smith David
</code></p>

<h3>使用NSDescriptor进行排序</h3>

<p>Sort descriptor不仅可以用来对数组进行排序，还能指定element在table view中的排序，以及Core Data中对fetch request返回的数据做排序处理。通过sort descriptor可以很方便的对数组进行多个key的排序。下面来看看如何对我们的数组做surname排序，然后在进行name排序：</p>

<p>```objc
NSSortDescriptor <em>firstDescriptor = [[NSSortDescriptor alloc] initWithKey:@&ldquo;surname&rdquo; ascending:YES];
NSSortDescriptor </em>secondDescriptor = [[NSSortDescriptor alloc] initWithKey:@&ldquo;name&rdquo; ascending:YES];</p>

<p>NSArray *sortDescriptors = [NSArray arrayWithObjects:firstDescriptor, secondDescriptor, nil];</p>

<p>NSArray *sortedArray = [self.persons sortedArrayUsingDescriptors:sortDescriptors];
```</p>

<p>上面代码的排序结果如下所示：</p>

<p><code>objc
Andersen Jane
Clark Anne
Johnson Rose
Smith David
Smith John
</code></p>

<h3>使用selector进行排序</h3>

<p>当面，我们也可以定义自己的方法进行两个对象做比较，并将该方法用于数组排序。comparator消息会被发送到数值中的每个对象中，并携带数组中另外的一个对象当做参数。自定义的的方法的返回结果是这样的：如果本身对象小于参数中的对象，就返回<code>NSOrederedAscending</code>，相反，则返回<code>NSOrderedDescending</code>，如果相等，那么返回<code>NSOrderedSame</code>。如下代码所示：</p>

<p>```objc
&ndash; (NSComparisonResult)compare:(Person *)otherPerson {</p>

<pre><code>return [self.dateOfBirth compare:otherPerson.dateOfBirth];
</code></pre>

<p>}
```</p>

<p>这个方法定义在Person类中，用来对person的生日进行排序。</p>

<p>上面所介绍的这些方法都是为了完成相同的事情：对数组做排序处理，你可能在想改选择使用哪个呢？当需要通过多个key进行排序，那么最简单的方法就是使用sort descriptor。如果比较方法很复杂的话，建议在使用外面自己的selector。Block是再iOS 4之后引入的一个强大功能，用block作比较，可以不必使用任何的变量就能完成一个简单的比较方法，当然，你也可以定义一个复杂的block，来替换selector。</p>

<p>最后，其实这里并没有标准答案，你可以跟着自己的感觉走:]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中的Literals]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/23/guided-tour-through-objective-c-literals/"/>
    <updated>2014-01-23T15:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/23/guided-tour-through-objective-c-literals</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/19.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/guided-tour-through-objective-c-literals/">Guided tour through Objective-C Literals</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>苹果在2012年就已经把Literals加入到LLVM中，利用Literals，不仅可以方便快捷的创建某些特定数据类型，还可以简化代码量，加强代码的可读性。</p>

<p>下面先来看看目录：</p>

<ol>
<li>NSNumber</li>
<li>NSArray</li>
<li>NSDictionary</li>
<li>Expressions</li>
</ol>


<p>下面我们就让代码来说话吧。</p>

<h3>1. NSNumber</h3>

<p>曾经你是否一直这样来实例化<code>NSNumber</code>：</p>

<p><code>objc
NSNumber *integer = [NSNumber numberWithInt:19];
</code></p>

<p>是不是感觉比较麻烦，现在好了，通过Literal，只需要如下一行简洁的代码即可：</p>

<p><code>objc
NSNumber *integer = @19
</code></p>

<p>在上面的代码中，使用了<code>@</code>符号，这跟创建NSString一样(只是不用双引号吧了)，这样一来，就非常容易记住和使用啦。</p>

<p>不仅如此，我们还可以利用C语言中的后缀风格来定义NSNumber，如下代码所示：</p>

<p><code>objc
NSNumber *unsignedInteger = @19U;   //Unsigned Integer
NSNumber *longInteger = @19L;       //Long Integer
NSNumber *floatNumber = @19.5493F;  //Float
 
NSNumber *boolean = @YES; //        //BOOL
</code></p>

<h3>2. NSArray</h3>

<p>有些编程语言创建数组是非常简单的，例如PHP。但是在引入Literal之前，Objective-C中创建数组的语法确不简单。如下代码所示：</p>

<p><code>objc
NSArray *array = [NSArray arrayWithObjects: [NSNumber numberWithInt:10],
                                            @"A String!",
                                            [NSNumber numberWithFloat:10.654F],
                                             nil];
</code></p>

<p>上面代码中不仅初始化对象复杂，还需要额外添加一个nil。但是要用Literal，看起来完全不一样了：</p>

<p><code>objc
NSArray *array_l = @[@10, @"A string", @10.645F];
</code></p>

<p>如上所示，利用Literal，可以通过<code>@[]</code>轻松的搞定数组初始化，并且省掉最后的<code>nil</code>。实际上编译器会把上面的代码替换为<code>[NSArray arrayWithObjects:count:]</code>。</p>

<p>在Literal之前，访问数组中的对象需要使用一个类似这样的方法<code>objectAtIndex</code>：</p>

<p><code>objc
id obj = [array objectAtIndex:0];
</code></p>

<p>而来到Literal的世界中，可以使用一对方括弧<code>[]</code>加对象对应的索引就可以访问到了：</p>

<p><code>objc
id obj = array[0];
</code></p>

<p>通过上面的语法，我们可以按照下面的方法来修改可变数组中的值：</p>

<p><code>objc
NSMutableArray *mutableArray = [NSMutableArray arrayWithObject:@[@11,@76]];
mutableArray[0] = @51;
</code></p>

<h3>3. NSDictionary</h3>

<p>在Literal引入之前，NSDictionary对象的实例化跟NSArray类似，看起来也很长，并且在最后需要<code>nil</code>，如下代码所示：</p>

<p><code>objc
NSDictionary *dict = [NSDictionary dictionaryWithObjects:[NSArray arrayWithObjects: [NSNumber numberWithInt:10],
                                                                                    [NSNumber numberWithInt:20],
                                                                                    [NSNumber numberWithInt:30],
                                                                                    nil]
                                                 forKeys:[NSArray arrayWithObjects: @"first",
                                                                                    @"second",
                                                                                    @"third",
                                                                                    nil]];
</code></p>

<p>上面的代码看起来着实有点过头了。如果要用Literal的话，就简洁明了多了：</p>

<p><code>objc
NSDictionary *dicts = @{@"first":@10, @"second":@20, @"third":@30};
</code></p>

<p>在上面NSDictionary实例化过程中，通过Literal，除了可以定义NSNumber和NSArray之外，还可以以可读的方式一一放置key和对应的值。相信这种方法大家都会喜欢。</p>

<p>从上面的介绍，你应该会喜欢上Literal，它确实可以让我们的代码更加容易读懂，并且不容易出错！！！</p>

<p>另外，我们还可以通过下面这样的方式访问字典中key对应的内容：(感谢<a href="http://weibo.com/u/2135198615">@谌启亮</a>在评论中的提醒)</p>

<p><code>objc
NSString *firstValue = dicts[@"first"]
</code></p>

<p>// 注意：下面这一点内容我摘自<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Objective-C-Literals-Boxed Expressions</a></p>

<h3>4. Expressions</h3>

<p>Objective-C提供了一种新的语法对C表达式进行包装：<code>@( &lt;expression&gt; )</code></p>

<p>它支持标量表达式(numeric, enumerated, BOOL)，以及C字符串指针类型：</p>

<p>```objc
// numbers.
NSNumber <em>smallestInt = @(-INT_MAX &ndash; 1);  // [NSNumber numberWithInt:(-INT_MAX &ndash; 1)]
NSNumber </em>piOverTwo = @(M_PI / 2);        // [NSNumber numberWithDouble:(M_PI / 2)]</p>

<p>// enumerated types.
typedef enum { Red, Green, Blue } Color;
NSNumber *favoriteColor = @(Green);       // [NSNumber numberWithInt:((int)Green)]</p>

<p>// strings.
NSString <em>path = @(getenv(&ldquo;PATH&rdquo;));       // [NSString stringWithUTF8String:(getenv(&ldquo;PATH&rdquo;))]
NSArray </em>pathComponents = [path componentsSeparatedByString:@&ldquo;:&rdquo;];
```</p>

<p>关于Literals的更多详细内容可以参考：<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Objective-C-Literals</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何自定义iOS中的控件]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios/"/>
    <updated>2014-01-20T17:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/18.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>下面先来看看目录：</p>

<ol>
<li>子类化UIControl

<ul>
<li>绘制用户界面

<ul>
<li>绘制背景</li>
<li>绘制用户的可操作区域</li>
<li>绘制手柄</li>
</ul>
</li>
<li>跟踪用户的操作

<ul>
<li>开始跟踪</li>
<li>持续跟踪</li>
<li>结束跟踪</li>
</ul>
</li>
<li>Target-Action模式</li>
</ul>
</li>
<li>如何使用自定义控件</li>
<li>总结</li>
<li>代码下载</li>
</ol>


<p>在开发过程中，有时候UIKit的标准控件并不能满足我们的需求，例如你需要一个控件能支持用户方便的选择0-360°之间的一个角度值，此时就需要根据自己的需求自定义控件了。</p>

<p>对于选择角度值的控件可以这样实现：创建一个圆形的滑块，用户通过拖动手柄操作就能选择角度值。实际上这样的控件在别的一些平台中你可能看到过，但是在UIKit中并没有。</p>

<p>本文就实现一个选择角度值的控件来介绍控件的自定义。下面先来看看到底要做成什么样子：</p>

<p><img src="/images/2014/01/12.png" alt="" /></p>

<h3>1. 子类化UIControl</h3>

<p><code>UIControl</code>是UIView的子类，它又是所有UIKit控件的父类(例如UIButton、UISlider和UISwitch等)。</p>

<p>UIControl的主要作用是创建相应的逻辑将action分发到对应的target，另外90%的情况下，它会根据自身的状态(例如Highlighted, Selected和Disabled等)来绘制用户界面。</p>

<p>通过UIControl，我们主要管理3个重要的任务：</p>

<ul>
<li>绘制用户界面</li>
<li>跟踪用户的操作</li>
<li>Target-Action模式</li>
</ul>


<p>在本文的圆形滑块中，我们要做如下一些事情：</p>

<p>定制一个用户界面(圆形滑块本身)，通过该界面用户可以通过手柄进行界面交互。用户的交互操作会被转换为控件target对应的action(控件将滑块按钮的frame origin转换为0-360之间的一个值，并用于target/action上)。</p>

<p>建议在学习本文的时候从文章尾部的连接中下载完整的示例工程。</p>

<p>下面我将从上面列出的3个重要任务一一进行分解介绍。</p>

<p>这些步骤都是模块化的，所以如果你对界面的绘制不感兴趣，可以跳过<code>绘制用户界面</code>，直接学习后面的步骤。</p>

<p>打开工程文件中的<code>TBCircluarSlider.m</code>文件。然后开始学习下面的内容。</p>

<h4>1.1 绘制用户界面</h4>

<p>我比较喜欢使用Core Graphics，唯一用到UIKit的就是通过textfield来显示滑块的值。</p>

<p><code>提醒</code>：此处需要用到一些<code>Core Graphics</code>知识，如果你不懂也没多大关系，我会尽量把代码做详细的讲解。</p>

<p>我们先来看看控件的不同组成部分，这样更有利于后面的学习。</p>

<p>首先，是用一个<code>黑色的圆环</code>当做滑块的背景。</p>

<p><img src="/images/2014/01/13.png" alt="" /></p>

<p><code>可操作区域(active area)</code>是一个从蓝色到紫色的梯度渐变效果。</p>

<p><img src="/images/2014/01/14.png" alt="" /></p>

<p>用户通过拖拽下面的这个手柄按钮来选择值：</p>

<p><img src="/images/2014/01/15.png" alt="" /></p>

<p>最后，用于显示选中值的<code>TextField</code>。在下一版中，我计划让用户可以通过键盘输入角度值。</p>

<p><img src="/images/2014/01/16.png" alt="" /></p>

<p>控件界面的绘制主要使用drawRect函数，首选我们需要获取到当前使用的图形上下文，如下代码所示：</p>

<p><code>objc
CGContextRef ctx = UIGraphicsGetCurrentContext();
</code></p>

<h5>1.1.1 绘制背景</h5>

<p>背景是360°的，所以只要用CGContextAddArc给图形上下文添加正确的path，并设置正确的stroke即可。</p>

<p>下面的代码可以就可以完成背景的绘制：</p>

<p>```objc
//Add the arc path
CGContextAddArc(ctx, self.frame.size.width/2, self.frame.size.height/2, radius, 0, M_PI *2, 0);</p>

<p>//Set the stroke colour
[[UIColor blackColor]setStroke];</p>

<p>//set Line width and cap
CGContextSetLineWidth(ctx, TB_BACKGROUND_WIDTH);
CGContextSetLineCap(ctx, kCGLineCapButt);</p>

<p>//draw it!
CGContextDrawPath(ctx, kCGPathStroke);
```</p>

<p><code>CGContextArc</code>函数的参数包括图形上下文，弧度的中心坐标点，以及半径(是一个私有变量)，接着是弧度开始和结束时的角度(在TBCircularSlider.m文件的头部可以看到一些关于数学计算的方法)，最后一个参数标示绘制的方向，0表示逆时针方向。</p>

<p>接下来的3行的代码是用来设置一些信息的，例如颜色和线条宽度等。最后使用<code>CGContextDrawPath</code>方法完成背景的绘制。</p>

<h5>1.1.2 绘制用户的可操作区域</h5>

<p>这部分需要利用一点小技巧才行。此处我们绘制一个线性渐变的掩码图片，下面看看原理：</p>

<p><img src="/images/2014/01/17.png" alt="" /></p>

<p>此处掩码图片的工作原理是可以看到原始渐变矩形框的一个孔。</p>

<p>在这里绘制的弧度有一个阴影，这是创建掩码图时使用了一点模糊的效果。</p>

<p>下面是创建掩码图的相关代码：</p>

<p><code>objc
UIGraphicsBeginImageContext(CGSizeMake(320,320));
CGContextRef imageCtx = UIGraphicsGetCurrentContext();
 
CGContextAddArc(imageCtx, self.frame.size.width/2  , self.frame.size.height/2, radius, 0, ToRad(self.angle), 0);
[[UIColor redColor]set];
 
//Use shadow to create the Blur effect
CGContextSetShadowWithColor(imageCtx, CGSizeMake(0, 0), self.angle/20, [UIColor blackColor].CGColor);
 
//define the path
CGContextSetLineWidth(imageCtx, TB_LINE_WIDTH);
CGContextDrawPath(imageCtx, kCGPathStroke);
 
//save the context content into the image mask
CGImageRef mask = CGBitmapContextCreateImage(UIGraphicsGetCurrentContext());
UIGraphicsEndImageContext();
</code></p>

<p>在上面的代码中首先创建了一个图形上下文，然后设置了一下阴影。通过<code>CGContextSetShadowWithColor</code>方法，我们可以设置如下内容：</p>

<ul>
<li>上下文</li>
<li>偏移量(此处不需要)</li>
<li>模糊值(该值是通过参数控制的：使用当前的角度除以20，当用户与此控件交互时，以此获得一个简单的动画模糊值)</li>
<li>颜色</li>
</ul>


<p>接着是根据当前的角度绘制一个相应的弧度。</p>

<p>例如，如果当前的角度变量是360°，那么就绘制一个圆弧，如果是90°，就绘制一个弧度为90°的一个弧。最后，利用<code>CGBitmapContextCreateImage</code>方法获取一张图片（刚刚绘制的弧）。这个图片就是我们所需要的掩码图了。</p>

<p>裁剪上下文：</p>

<p>现在我们已经有一个渐变的掩码图了。接着利用函数<code>CGContextClipToMask</code>对上下文进行裁剪——给该函数传入上面刚刚创建好的掩码图。代码如下所示：</p>

<p><code>objc
CGContextClipToMask(ctx, self.bounds, mask);
</code></p>

<p>最后我们来绘制渐变效果，代码如下所示：</p>

<p><code>objc
//Define the colour steps
CGFloat components[8] = {
    0.0, 0.0, 1.0, 1.0,     // Start color - Blue
    1.0, 0.0, 1.0, 1.0 };   // End color - Violet
 
CGColorSpaceRef baseSpace = CGColorSpaceCreateDeviceRGB();
CGGradientRef gradient = CGGradientCreateWithColorComponents(baseSpace, components, NULL, 2);
 
//Define the gradient direction
CGPoint startPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMinY(rect));
CGPoint endPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMaxY(rect));
 
    //Choose a colour space
CGColorSpaceRelease(baseSpace), baseSpace = NULL;   
 
//Create and Draw the gradient
CGContextDrawLinearGradient(ctx, gradient, startPoint, endPoint, 0);
CGGradientRelease(gradient), gradient = NULL;
</code></p>

<p>绘制渐变效果需要很多处理，不过我们可以将其分为4部分：</p>

<ul>
<li>定义颜色的变化范围</li>
<li>定义渐变的方向</li>
<li>选择颜色空间</li>
<li>创建并绘制渐变</li>
</ul>


<p>最终的显示效果(看到渐变矩形框的一部分)要归功于之前创建的掩码图。</p>

<p>另外，为了在背景边框模拟光线反射，我添加了一些灯光效果。</p>

<h5>1.1.3 绘制手柄</h5>

<p>下面我们根据当前的角度值，在的正确位置绘制出手柄。</p>

<p>实际上，在绘制过程中，这一步非常简单，复杂一点的就是计算一下手柄所在的位置。</p>

<p>这里我们需要使用三角函数将一个<code>标量值(scalar number)</code>转换为<code>CGPoint</code>。不要担心有多复杂，只需要使用Sin和Cos函数就可以完成。代码如下所示：</p>

<p><code>objc
-(CGPoint)pointFromAngle:(int)angleInt{
     
    //Define the Circle center
    CGPoint centerPoint = CGPointMake(self.frame.size.width/2 - TB_LINE_WIDTH/2, self.frame.size.height/2 - TB_LINE_WIDTH/2);
     
    //Define The point position on the circumference
    CGPoint result;
    result.y = round(centerPoint.y + radius * sin(ToRad(-angleInt))) ;
    result.x = round(centerPoint.x + radius * cos(ToRad(-angleInt)));
     
    return result;
}
</code></p>

<p>上面的代码中，指定一个角度值，然后计算出在圆周上面的位置，当然，这里需要圆周的中心点和半径。</p>

<p>使用sin函数在使用sin函数时，需要一个Y坐标值，而cos函数则需要X坐标值。</p>

<p>需要注意的是此处每个函数返回的值都认为半径为1，所以需要将所得结果乘以我们指定的半径大小，并相对于圆周的中心做计算。</p>

<p>希望下面的公式对你的理解有所帮助：</p>

<p><code>objc
point.y = center.y + (radius * sin(angle));
point.x = center.x + (radius * cos(angle));
</code></p>

<p>通过上面的计算，现在我们已经知道手柄的具体位置了，所以，接下来就直接将手柄绘制到指定位置即可，如下代码所示：</p>

<p><code>objc
-(void) drawTheHandle:(CGContextRef)ctx{
     
    CGContextSaveGState(ctx);
     
    //I Love shadows
    CGContextSetShadowWithColor(ctx, CGSizeMake(0, 0), 3, [UIColor blackColor].CGColor);
     
    //Get the handle position!
    CGPoint handleCenter =  [self pointFromAngle: self.angle];
     
    //Draw It!
    [[UIColor colorWithWhite:1.0 alpha:0.7]set];
    CGContextFillEllipseInRect(ctx, CGRectMake(handleCenter.x, handleCenter.y, TB_LINE_WIDTH, TB_LINE_WIDTH));
     
    CGContextRestoreGState(ctx);
}
</code></p>

<p>具体操作步骤如下：</p>

<ul>
<li>保存当前的上下文(当在一个单独的函数中进行绘制任务时，将上下文的状态进行保存是编程的一个好习惯)。</li>
<li>给手柄设置一些阴影效果</li>
<li>定义手柄的颜色，然后利用<code>CGContextFillEllipseInRect</code>将其绘制出来。</li>
</ul>


<p>我们在drawRect函数的最后调用上面这个方法：</p>

<p><code>objc
[self drawTheHandle:ctx];
</code></p>

<p>至此，我们就完成了绘制部分的任务。</p>

<h4>1.2 跟踪用户的操作</h4>

<p>在UIControl的子类中，我们可以<code>override</code>3个特殊的方法来提供一个自定义的跟踪行为</p>

<h5>1.2.1 开始跟踪</h5>

<p>当在控件的bound内发生了一个触摸事件，首先会调用控件的<code>beginTrackingWithTouch</code>方法。</p>

<p>我们就看看如何<code>override</code>这个方法吧：</p>

<p><code>objc
-(BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super beginTrackingWithTouch:touch withEvent:event];
 
    //We need to track continuously
    return YES;
}
</code></p>

<p>该函数返回的BOOl值决定着：当触摸事件是dragged时，是否需要响应。在我们这里的自定义控件中，是需要跟踪用户的dragging，所以返回YES。</p>

<p>上面这个函数有两个参数：touch对象和事件。</p>

<h5>1.2.2 持续跟踪</h5>

<p>在上一个方法中我们指定了这里的自定义控件需要跟踪一个持续的事件，所以当用户进行drag时，会调用一个特殊的方法：<code>continueTrackingWithTouch</code>：</p>

<p><code>objc
-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event
</code></p>

<p>该方法返回的BOOL值标示是否继续跟踪touch事件。</p>

<p>通过该方法我们可以根据touch位置对用户的操作进行过滤。例如，我们可以：仅当touch位置与手柄位置相交的时候才激活控件(activate control)。不过在这里我们的控制逻辑并不是这样的，我们希望用户点击任何位置都能对手柄做出相应的位置处理。</p>

<p>本文的该方法负责更新手柄的位置(在后面的一节中会看到我们把该位置信息传递给对应的target上)。</p>

<p>对上面这个方法的override代码如下所示：</p>

<p><code>objc
-(BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super continueTrackingWithTouch:touch withEvent:event];
 
    //Get touch location
    CGPoint lastPoint = [touch locationInView:self];
 
    //Use the location to design the Handle
    [self movehandle:lastPoint];
 
        //We'll see this function in the next section:
    [self sendActionsForControlEvents:UIControlEventValueChanged];
 
    return YES;
}
</code></p>

<p>上面的代码中，首先利用<code>locationInView</code>获取到touch的位置，然后将该位置传递给<code>moveHandle</code>方法，该方法会将传入的值转换为一个有效的手柄位置(a valid handle position)。</p>

<p>此处“a valid position”的意思是什么呢？</p>

<p>此控件的手柄只能在背景圆弧定义的边界范围内做移动，但是我们不希望强制要求用户必须在很小的圆弧内才可以移动手柄，如果非要这样的话，用户体验会非常的糟糕。</p>

<p><code>moveHandle</code>的任务就是负责把任意的位置值转变为手柄可移动的值，另外，另外，在该函数中，还对指定的滑块角度值做了转换，代码如下所示：</p>

<p><code>objc
-(void)movehandle:(CGPoint)lastPoint{
     
    //Get the center
    CGPoint centerPoint = CGPointMake(self.frame.size.width/2,
                                                                            self.frame.size.height/2);
     
    //Calculate the direction from the center point to an arbitrary position.
    float currentAngle = AngleFromNorth(centerPoint,
                                                                                lastPoint,
                                                                                NO);
    int angleInt = floor(currentAngle);
     
    //Store the new angle
    self.angle = 360 - angleInt;
 
    //Update the textfield
    _textField.text =  [NSString stringWithFormat:@"%d",
                                                                                                    self.angle];
     
    //Redraw
    [self setNeedsDisplay];
}
</code></p>

<p>上面代码中，实际上主要任务都是在<code>AngleFromNorth</code>方法中处理的：根据两个point，就会返回一个连接这两点对应的一个角度关系，<code>AngleFromNorth</code>方法的实现如下所示：</p>

<p><code>objc
static inline float AngleFromNorth(CGPoint p1, CGPoint p2, BOOL flipped) {
    CGPoint v = CGPointMake(p2.x-p1.x,p2.y-p1.y);
    float vmag = sqrt(SQR(v.x) + SQR(v.y)), result = 0;
    v.x /= vmag;
    v.y /= vmag;
    double radians = atan2(v.y,v.x);
    result = ToDeg(radians);
    return (result &gt;=0  ? result : result + 360.0);
}
</code></p>

<p>提醒：<code>angleFromNorth</code>方法并不是我的原创，我是直接从苹果提供的OSX示例clockControl中拿过来用的。</p>

<p>在上面的代码中，获得了角度值以后，将其存储到<code>angle</code>中，然后更新一下textfield的值。</p>

<p>接着调用的<code>setNeedDisplay</code>是为了确保<code>drawRect</code>被调用，以尽快在界面上做出相应的更新。</p>

<h5>1.2.3 结束跟踪</h5>

<p>当跟踪结束的时候，会调用下面这个方法：</p>

<p><code>objc
-(void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event{
    [super endTrackingWithTouch:touch withEvent:event];
}
</code></p>

<p>在本文中，我们并不需要override该方法。如果当用户完成控件的界面操作时，你希望做一些处理，那么该方法会非常有用。</p>

<h4>1.3 Target-Action模式</h4>

<p>至此，圆形滑块控件可以工作了，你可以drag手柄，并能看到textfield中值的改变。</p>

<p>发送action——控件事件</p>

<p>如果希望自己定制的控件与UIControl行为保持一致，那么当控件的值发生变化时，需要进行通知处理：使用<code>sendActionsForControlEvents</code>方法，并制定特定的事件类型，值改变对应的事件一般是<code>UIControlEventValueChanged</code>。</p>

<p>苹果已经预定义了许多事件类型(Xcode中，在UIControlEventValueChanged上<code>cmd + 鼠标单击</code>)。如果你的控件是继承自UITextField，那么你可能会对<code>UIControlEventEdigitingDidBegin</code>感兴趣，如果你要做一个touch Up action，那么可以使用UIControlTouchUpInside。</p>

<p>如果你注意的话，在本文前部分的continueTrackingWithTouch方法里面，我们调用了<code>sendActionsForControlEvents</code>方法：</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>这样处理之后，当控件值发生变化时，每一个对象(观察者——注册该事件)都会收到响应的通知。</p>

<h3>2. 如何使用自定义控件</h3>

<p>到这里，我们的控件定制完毕，下面介绍如何在程序中使用自定义的控件。</p>

<p>打开文件<code>TBViewController.m</code>，看看<code>viewDidLoad</code>方法里面的代码：</p>

<p><code>objc
- (void)viewDidLoad
{
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor colorWithRed:0.1 green:0.1 blue:0.1 alpha:1];
     
    //Create the Circular Slider
    TBCircularSlider *slider = [[TBCircularSlider alloc]initWithFrame:CGRectMake(0, 60, TB_SLIDER_SIZE, TB_SLIDER_SIZE)];
     
    //Define Target-Action behaviour
    [slider addTarget:self action:@selector(newValue:) forControlEvents:UIControlEventValueChanged];
     
    [self.view addSubview:slider];
}
</code></p>

<p>在上面的代码中，给view设置了一个背景色，并通过调用<code>initWithFrame</code>方法实例化了一个圆形滑块(自定义的控件)。</p>

<p>注意：UIControl继承自UIView，所以它继承了UIView的所有方法。</p>

<p>接着定义了如何与该控件进行交互：使用<code>addTarget:action:forControlEvent:</code>方法。</p>

<p>该方法只是给控件的特定事件设置一下target-action。如果你还记得的话，上面层介绍过，每当用户移动手柄时，圆形滑块都会发送一个UIControlEventValueChanged事件。所以我们可以通过下面的代码为该事件注册一个action：</p>

<p><code>objc
[slider addTarget:self action:@selector(newValue:) forControlEvents:UIControlEventValueChanged];
</code></p>

<p>这样我们就可以创建一个<code>**newValue**</code>方法来处理值发生改变时的一些事情：</p>

<p><code>objc
-(void)newValue:(TBCircularSlider*)slider{
    NSLog(@"Slider Value %d",slider.angle);
}
</code></p>

<p>结合Target-Action，所以函数会受到action的发送者，此处是slider，通过这个slider，就能直接获取到角度值。</p>

<h3>3. 总结</h3>

<p>根据本文的具体步骤，你可以构建<code>任意你想要的控件</code>。</p>

<p>当然，也有其它一些方法来构建自定控件，不过本文基本上是按照苹果的建议来做的。</p>

<p>点击下图，下载代码</p>

<h3>4. 代码下载</h3>

<p><a href="https://github.com/ariok/TB_CircularSlider"><img src="/images/2013/11/34.jpg" alt="" /></a></p>

<p>本文由破船译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在下面的评论中回复我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给tableview cell添加动画]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/13/animation-tableview-cell/"/>
    <updated>2014-01-13T17:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/13/animation-tableview-cell</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/5.png" alt="" /></p>

<!--more-->


<h3>小引</h3>

<p>本文介绍如何利用给tableview cell添加动画。其实只需要很少的代码量就可以。本文参考<a href="http://www.thinkandbuild.it/animating-uitableview-cells/">Animating UITableView cells</a></p>

<p>下面先来看看最终的效果：</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNjYxMTgxOTQw" frameborder=0 allowfullscreen></iframe>


<p>从上面的视频中，可以看出，当cell显示出来的时候，是在Y和Z轴上进行3D旋转。</p>

<p>下面来看看是如何实现的：</p>

<p>首先假设你已经能够熟练使用UITableView了。那么我们只需要实现UITableViewDelegate中的tableView:WillDisplayCell:ForRowAtIndexPath:即可。当cell显示之前，会先调用该方法，因此给cell添加动画，在这个方法里面即可。</p>

<p>如下代码所示：</p>

<p>```objc
&ndash;(void)tableView:(UITableView <em>)tableView willDisplayCell:(UITableViewCell </em>)cell forRowAtIndexPath:(NSIndexPath *)indexPath{</p>

<pre><code>// 1. 配置CATransform3D的内容
CATransform3D transform;
transform = CATransform3DMakeRotation( (90.0*M_PI)/180, 0.0, 0.7, 0.4);
transform.m34 = 1.0/ -600;

// 2. 定义cell的初始状态
cell.layer.shadowColor = [[UIColor blackColor]CGColor];
cell.layer.shadowOffset = CGSizeMake(10, 10);
cell.alpha = 0;

cell.layer.transform = transform;
cell.layer.anchorPoint = CGPointMake(0, 0.5);

// 3. 定义cell的最终状态，并提交动画
[UIView beginAnimations:@"transform" context:NULL];
[UIView setAnimationDuration:0.5];
cell.layer.transform = CATransform3DIdentity;
cell.alpha = 1;
cell.layer.shadowOffset = CGSizeMake(0, 0);
cell.frame = CGRectMake(0, cell.frame.origin.y, cell.frame.size.width, cell.frame.size.height);
[UIView commitAnimations];
</code></pre>

<p>}
```</p>

<p>第一步：使用CATransform3D在Y和Z轴上做旋转设置。</p>

<p>第二步：定义cell的初始状态，添加了一些阴影，并将第一步中的transform设置给cell中layer的transform matrix。然后将anchor设置为0.0, 0.5，也就是说让cell围绕着左边进行旋转。</p>

<p>第三步：通过动画，将cell设置为原始状态。此处利用了UIView的beginAnimations:context方法来更新cell中layer的值。当然还有别的方法来执行动画，不过这种方法比较简单，我们可以设置持续时间。代码里面将transform设置为CATransform3DIdentity。</p>

<p>这样通过第二步和第三步的状态就能够引导动画，以此完成最终效果。</p>

<p>完整代码工程下载地址：
<a href="https://github.com/BeyondVincent/BVTableViewAnimation">BVTableViewAnimation</a></p>

<p>下面是网上看到的两个内容，可以参考：</p>

<p><a href="http://www.raywenderlich.com/49311/advanced-table-view-animations-tutorial-drop-in-cards">From RW：Table View Animations Tutorial: Drop-In Cards</a><a href="http://weibo.com/522056706"><code>@bluesea哈哈哈</code></a>推荐本链接</p>

<p><a href="http://maniacdev.com/2013/05/library-allowing-you-to-create-table-views-with-wacky-highly-detailed-ripple-cell-animations">Library Allowing You To Create Table Views With Wacky Highly Detailed Ripple Cell Animations
</a></p>

<p><a href="http://maniacdev.com/2012/05/drop-in-open-source-library-for-creating-wacky-animated-uitableviews">Drop-In Open Source Library For Creating Wacky Animated UITableViews</a></p>

<p>希望上面介绍对你有帮助，如果有问题，可以在下面的回复我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-3-iOS开发个人提升]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/11/129-my-iOS-growth-path-3/"/>
    <updated>2014-01-11T03:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/11/129-my-iOS-growth-path-3</id>
    <content type="html"><![CDATA[<p><img src="/images/2013/12/11.png" alt="" /></p>

<!--more-->


<p>注1：这篇文章是我的iOS成长之路系列文章中的第三篇文章，第一篇文章：<a href="http://beyondvincent.com/blog/2013/12/17/125-my-iOS-growth-path-1/">iOS成长之路-1-入门</a>，第二篇文章：
<a href="http://beyondvincent.com/blog/2014/01/06/126-my-iOS-growth-path-2/">iOS成长之路-2-我的第一个iOS Demo</a>。</p>

<p>通过两周时间来学习iOS，我慢慢的叩开了iOS开发的大门，接下来就是一个积累的过程，我主要经历了如下几个过程：</p>

<ul>
<li>饱览群书</li>
<li>跟着项目一起成长</li>
<li>与同行交流</li>
<li>做一些分享</li>
</ul>


<h3>饱览群书</h3>

<p><img src="/images/2014/01/2.jpg" alt="" /></p>

<p>  在初期，我认为多看书对于个人提升有很大的帮助，从某方面来说，这主要扩展了个人对iOS开发的理解广度(初期，先不要急于往最深处研究)，接着把书上的讲解与动手编程结合起来，这样可以加强编程理解能力。</p>

<p>  我们在选择书籍的时候，一定要注重质量，如果英文阅读能力没问题的话，建议直接上英文书籍(不解释)，例如iOS 7 Programming Cookbook，或者iOS7 by Tutorials(最新版)，如果英文有点吃力的话，我还是建议看英文书籍，看不懂的可以用google翻译，记得我在搞Symbian开发时，看英文书籍的时候，就是经常开着<a href="http://translate.google.cn/?hl=en">google翻译</a>。相信硬着头皮看上1个月，你会有各种感受，慢慢的，你会觉得英文内容读起来非常的行云流水，理解起来也要比中文书籍更加容易。</p>

<p>  另外，这里所说的饱览群书，还包括网络中的学习资料，你可以订阅一些iOS开发相关的博文，我曾在<a href="http://beyondvincent.com/blog/2013/07/18/106/">这里汇总了一些不错的博文</a>，你可以去订阅一下。</p>

<p>  还有两个好去处就是苹果每年WWDC上出的大量参考资料，最新的是<a href="https://developer.apple.com/wwdc/videos/">WWDC2013</a>，值得拥有。再一个就是来自斯坦福大学的公开课<a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550">Developing iOS 7 Apps for iPhone and iPad</a>，也非常适合初学者。</p>

<p>  最后，你还需要知道两个网站：<a href="https://github.com/">github</a>和<a href="http://stackoverflow.com/">stackoverflow</a>，其中github主要用来存放开源项目，你可以在这里学习到别人的好多精华，好多内容都可以拿过来直接使用。另外stackoverflow是国外一个非常著名的问答网站，学习初期，基本上你遇到的问题，都能在这里搜索到相关解答。</p>

<h3>跟着项目一起成长</h3>

<p>  我觉得做项目对个人成长非常快，特别如果你是初学者的话，因为你是带着问题去学习和思考，同时也会有一定的项目压力，迫使你不断向前进。当然，大多数项目涉及到的知识点都会有一定的局限性，例如音乐类软件，主要涉及到多媒体相关的知识，而阅读类的软件可能对于图形渲染要求要多一点。虽说项目涉及到的知识有一定的局限性，但是它需要有一定的深度，所以对个人能力的提升也非常有效。</p>

<p>  另外，各项目之间也会有一些共性，只要你熟悉了这些共性，那么在项目之间可以拿来即用，例如网络模块、数据存储模块，有些项目可能就是业务需求不同而已。</p>

<p>  如果你是初学者的话，要是有机会做项目，千万不要错过学习提升的好机会，不要因为项目压力，有什么想法，相信顶住各种压力和想法，最后你会感谢曾经努力的你。</p>

<h3>与同行交流</h3>

<p><img src="/images/2014/01/3.jpg" alt="" /></p>

<p>  有时候，你一个人在做项目，或者学习时，或许会感觉到特别的孤独，有一颗特别强烈的心，迫切想跟外界进行交流：这个功能点的实现可行吗？有人遇到同样的问题吗？别人是如何做的？</p>

<p>  其实，在开发或学习过程中，多与同行进行交流是非常有帮助的，交流过程中，有时候一个问题，一个想法，经他人指点，会有茅塞顿开的感觉。当然，交流的对象最好是经验丰富的喽。这样你更加容易信任对方，可以把他当做你前进的灯塔。</p>

<p>  不过交流也需要一定的技巧的，遇到问题不是一味的去咨询别人，你可以首先尝试自己解决，别忘记google可是万能的。当然也并不是任何时候都有交流的对象。</p>

<h3>做一些分享</h3>

<p><img src="/images/2014/01/4.jpg" alt="" /></p>

<p>  我曾经翻译过一些文章和书籍，本来看起很简单的事情，内容也看得懂，但是要想再次用中文表达，其实并没有想象中的简单，好多时候，你需要反复的推敲，并查阅更多的资料，以确保你所翻译出来的内容是正确的。</p>

<p>  一句话，这东西需要坚持，到最后，你会发现收获颇多，另外，当你的成果得到别人的认可，对你也会是一个不小的鼓舞。</p>

<p>  当然，要是能做一些原创内容分享，是再好不过的了，因为在写原创内容的时候，你首先需要做一个构思和规划，并会查阅大量在资料，以此来支撑自己分享的内容。这要比翻译文章高级多了，翻译那是跟着别人的思路走。</p>

<p>  或许你想说，你是程序员，只会写代码，不擅长写文章，写总结，那反过来，试问谁有天生会呢？相信熟能生巧，你所需要做的就是大胆的迈出第一步，然后坚持走下去！</p>

<h3>小结</h3>

<p>上面写了一些关于iOS开发提升方面的内容，实际上这不仅针对iOS，其它平台或者技术同样可行。希望文中的内容对你有些许帮助，如果有任何疑问，可以在下方给我留言。</p>
]]></content>
  </entry>
  
</feed>
