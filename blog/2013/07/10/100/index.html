
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>深度围观block：第二集 - 破船之家</title>
	<meta name="author" content="破船(BeyondVincent)">

	
	<meta name="description" content="深度围观block：第二集 本文由破船译自galloway转载请注明出处！ 小引 今天翻译了第二篇，这个翻译是比较痛苦(其实不止这篇，所有的都是)， 不比单纯的阅读，许多地方需要查阅资料，并细心的遣词造句，还得注意词不达意的地方(例如文中的A block that captures &hellip;">
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="破船之家" type="application/atom+xml">
	
	<link rel="canonical" href="http://BeyondVincent.github.io/blog/2013/07/10/100/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='http://www.gravatar.com/avatar/" + MD5("beyondvincent@gmail.com") + "?s=160' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">破船之家</a></h1>
<p class="subtitle">宠辱不惊，闲看庭前花开花落<br>去留无意，漫随天外云卷云舒<br>不妄取，不妄予，不妄想，不妄求<br>与人方便，随遇而安</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><a href="/about">关于我</a></li>
</ul>
</nav>
欢迎关注我的微信公众账号<br>
<div align=center><img width="100" height="100" src="./images/2013/12/qrcode_bv.jpg"></div>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/beyondvincent" title="Weibo">Weibo</a>
		
		
		
		
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner"><article class="post" itemscope itemtype="http://schema.org/BlogPosting">
	<h1 class="title" itemprop="name">深度围观block：第二集</h1>
	<div class="entry-content" itemprop="articleBody"><p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/blocks.png"><img class="alignnone size-full wp-image-1571" alt="blocks" src="http://beyondvincent.com/wp-content/uploads/2013/07/blocks.png" width="561" height="233" /></a></p>

<p>本文由<strong><span style="color: #339966;">破船</span></strong>译自<span style="text-decoration: underline;"><strong><span style="color: #339966;"><a href="http://www.galloway.me.uk/2012/10/a-look-inside-blocks-episode-2/" target="_blank"><span style="color: #339966; text-decoration: underline;">galloway</span></a></span></strong></span>转载请注明出处！</p>

<h2><strong><span style="color: #339966;">小引</span></strong></h2>

<p>今天翻译了第二篇，这个翻译是比较痛苦(其实不止这篇，所有的都是)， 不比单纯的阅读，许多地方需要查阅资料，并细心的遣词造句，还得注意词不达意的地方(例如文中的<strong><span style="color: #339966;">A block that captures scope</span></strong>我翻译为<strong><span style="color: #339966;">block的拷贝范围</span></strong>，总感觉缺了一些作者原意，功力有限啊)。所以，我劝大家要是能看原文尽量去看原文吧，我这翻译的权当参考。</p>

<!--more-->


<h2><strong><span style="color: #339966;">目录</span></strong></h2>

<ul>
<li><strong><span style="color: #339966;">介绍</span></strong></li>
<li><strong><span style="color: #339966;">block类型</span></strong></li>
<li><strong><span style="color: #339966;">block的拷贝范围</span></strong></li>
<li><strong><span style="color: #339966;">block拷贝对象的类型</span></strong></li>
<li><strong><span style="color: #339966;">何去何从</span></strong></li>
</ul>


<h3><strong><span style="color: #339966;">正文</span></strong></h3>

<h2><strong><span style="color: #339966;">介绍</span></strong></h2>

<p>本文接着上一篇文章(<strong><span style="text-decoration: underline;"><span style="color: #339966;"><a href="http://beyondvincent.com/2013/07/09/%E6%B7%B1%E5%BA%A6%E5%9B%B4%E8%A7%82block%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%9B%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">深度围观block：第一集</span></a></span></span></strong>)，继续从编译器的角度深度围观block。在本文中，将介绍block并不是一成不变的，以及block在栈上的构成。</p>

<h2><strong><span style="color: #339966;">block类型</span></strong></h2>

<p>在<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://beyondvincent.com/2013/07/09/%E6%B7%B1%E5%BA%A6%E5%9B%B4%E8%A7%82block%EF%BC%9A%E7%AC%AC%E4%B8%80%E9%9B%86/" target="_blank"><span style="color: #339966; text-decoration: underline;">第一篇</span></a></span></span></strong>文章中，我们已经看到block有一个<strong><span style="color: #339966;">_NSConcreteGlobalBlock</span></strong>这样的类。由于所有变量都是已知的，所以在编译期间，block的结构(structure)和描述(descriptor)都将全部被初始化。关于block这里有几种不同的类型，每种类型都有对应的类。为了简单起见，这里只考虑其中三种：</p>

<ol>
<li><strong><span style="color: #339966;">_NSConcreteGlobalBlock</span></strong>是定义一个全局的block，在编译器就已经完成相关初始化任务。这种类型的block不会涉及到任何拷贝，例如一个空的block。</li>
<li><strong><span style="color: #339966;">_NSConcreteStackBlock</span></strong>是一个分配在栈上的block。这里是所有最终被拷贝到堆(heap)上的block的开始。</li>
<li><strong><span style="color: #339966;">_NSConcreteMallocBlock</span></strong>是分配到堆(heap)上的block。拷贝完一个block之后，这就会结束。当block的引用计数变为0，该block就会被释放。</li>
</ol>


<h2><strong><span style="color: #339966;">block拷贝范围</span></strong></h2>

<p>这次我们来看看另外一些代码，如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;dispatch/dispatch.h&gt;

typedef void(^BlockA)(void);
void foo(int);

__attribute__((noinline))
void runBlockA(BlockA block) {
    block();
}

void doBlockA() {
    int a = 128;
    BlockA block = ^{
        foo(a);
    };
    runBlockA(block);
}</pre>


<p>为了让block拷贝一些内容，上面的代码中调用了<strong><span style="color: #339966;">foo</span></strong>函数，并给这个函数传递了一个变量。再说一下，本文涉及到的汇编代码是与armv7相关指令。下面是其中一部分汇编指令：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl  _runBlockA
    .align  2
    .code   16                      @ @runBlockA
    .thumb_func     _runBlockA
_runBlockA:
    ldr     r1, [r0, #12]
    bx      r1</pre>


<p>上面的汇编代码与<strong><span style="color: #339966;">runBlockA</span></strong>函数相关，这跟第一篇文章中的相同——都是调用了block中的<strong><span style="color: #339966;">invoke</span></strong>函数。接着是<strong><span style="color: #339966;">doBlockA</span></strong>汇编代码，如下所示：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.globl  _doBlockA
    .align  2
    .code   16                      @ @doBlockA
    .thumb_func     _doBlockA
_doBlockA:
    push    {r7, lr}
    mov     r7, sp
    sub     sp, #24
    movw    r2, :lower16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
    movt    r2, :upper16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
    movw    r1, :lower16:(___doBlockA_block_invoke_0-(LPC1_1+4))
LPC1_0:
    add     r2, pc
    movt    r1, :upper16:(___doBlockA_block_invoke_0-(LPC1_1+4))
    movw    r0, :lower16:(___block_descriptor_tmp-(LPC1_2+4))
LPC1_1:
    add     r1, pc
    ldr     r2, [r2]
    movt    r0, :upper16:(___block_descriptor_tmp-(LPC1_2+4))
    str     r2, [sp]
    mov.w   r2, #1073741824
    str     r2, [sp, #4]
    movs    r2, #0
LPC1_2:
    add     r0, pc
    str     r2, [sp, #8]
    str     r1, [sp, #12]
    str     r0, [sp, #16]
    movs    r0, #128
    str     r0, [sp, #20]
    mov     r0, sp
    bl      _runBlockA
    add     sp, #24
    pop     {r7, pc}</pre>


<p>看看，这跟之前的代码有所不同了。看起来这不仅仅是从一个全局的符号中加载block，而且还做了额外的一些事情。乍一看这么多代码让人有点无从下手，不过认真看，还是很容易理解的。从上面的代码可以看出，编译器已经忽略了对代码排序的优化，为了方便阅读代码，我对上面的汇编代码重新进行排序(当然，请相信我，这不会影响任何功能)。下面是我重排好的代码效果：</p>

<pre class="wp-code-highlight prettyprint linenums:1">_doBlockA:
        // 1
        push    {r7, lr}
        mov     r7, sp

        // 2
        sub     sp, #24

        // 3
        movw    r2, :lower16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
        movt    r2, :upper16:(L__NSConcreteStackBlock$non_lazy_ptr-(LPC1_0+4))
LPC1_0:
        add     r2, pc
        ldr     r2, [r2]
        str     r2, [sp]

        // 4
        mov.w   r2, #1073741824
        str     r2, [sp, #4]

        // 5
        movs    r2, #0
        str     r2, [sp, #8]

        // 6
        movw    r1, :lower16:(___doBlockA_block_invoke_0-(LPC1_1+4))
        movt    r1, :upper16:(___doBlockA_block_invoke_0-(LPC1_1+4))
LPC1_1:
        add     r1, pc
        str     r1, [sp, #12]

        // 7
        movw    r0, :lower16:(___block_descriptor_tmp-(LPC1_2+4))
        movt    r0, :upper16:(___block_descriptor_tmp-(LPC1_2+4))
LPC1_2:
        add     r0, pc
        str     r0, [sp, #16]

        // 8
        movs    r0, #128
        str     r0, [sp, #20]

        // 9
        mov     r0, sp
        bl      _runBlockA

        // 10
        add     sp, #24
        pop     {r7, pc}</pre>


<p>下面我们来看看这些代码都做了什么：</p>

<ol>
<li>开场白。首先将 <strong><span style="color: #339966;">r7</span></strong> push到栈上面——因为r7会被覆盖，而r7寄存器中的内容在跨函数调用时是需要用到的。<strong><span style="color: #339966;">lr</span></strong>是链接寄存器(link register)，该寄存器中存储着当这个函数返回时需要执行下一条指令的地址。接着mov这条指令的作用是把栈指针保存到r7<strong><span style="color: #339966;">寄存器</span></strong>中。</li>
<li>从栈指针所处位置开始减去24，也就是在栈空间上开辟24字节来存储数据。</li>
<li>这里涉及到的代码是为了对符号<strong><span style="color: #339966;">L__NSConcreteStackBlock$non_lazy_ptr</span></strong>进行寻址，由于跟pc(program counter)相关联，所以无论代码处于二进制文件中任何位置，当最终链接时，都能对该符号做到正确的寻址。</li>
<li>将值<strong><span style="color: #339966;">1073741824</span></strong>存储到栈指针 + 4 的位置。</li>
<li>将值<strong><span style="color: #339966;"></span></strong>存储到栈指针 + 8 的位置。现在，将要发生什么可能已经变得逐渐清晰了——在栈上创建了一个<strong><span style="color: #339966;">Block_layout</span></strong>结构的对象！到现在为止，已经设置了该结构的3个值：<strong><span style="color: #339966;">isa</span></strong>指针，<strong><span style="color: #339966;">flags</span></strong>和<strong><span style="color: #339966;">reserved</span></strong>值。</li>
<li>将<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>存储至栈指针 + 12的位置。这是block结构中的<strong><span style="color: #339966;">invoke</span></strong>。</li>
<li>将<strong><span style="color: #339966;">___block_descriptor_tmp</span></strong>存储至栈指针 + 16的位置。这是block结构中的<strong><span style="color: #339966;">descriptor</span></strong>。</li>
<li>将值<strong><span style="color: #339966;">128</span></strong>存储到栈指针 + 20的位置。如果回头看看<strong><span style="color: #339966;">Block_layout</span></strong>结构，可以看到里面只应该有5个值。那么在这个block结构体后面存储的128是什么呢？——注意到这个<strong><span style="color: #339966;">128</span></strong>实际上就是在block中拷贝的变量的值。所以这肯定就是存储block使用到的值的地方——在<strong><span style="color: #339966;">Block_layout</span></strong>结构尾部。</li>
<li>现在栈指针指向了已经完成初始化之后的block结构，在这里的汇编指令是将栈指针装载到<strong><span style="color: #339966;">r0</span></strong>中，然后调用<strong><span style="color: #339966;">runBlockA</span></strong>函数。(记住：在ARM EABI中，<strong><span style="color: #339966;">r0</span></strong>中存储的内容被当做函数的第一个参数)。</li>
<li>最后将栈指针加上24，这样就能够把最开始减去的24(在栈上开辟的24位空间)收回来。接着将栈中的两个值pop到<strong><span style="color: #339966;">r7</span></strong>和<strong><span style="color: #339966;">pc</span></strong>寄存器中。这里pop到<strong><span style="color: #339966;">r7</span></strong>中的，跟最开始从r7中push至栈中的内容是一致的，而<strong><span style="color: #339966;">pc</span></strong>的值则是最开始push <strong><span style="color: #339966;">lr</span></strong>到栈中的值，这样当函数返回时，可以让CPU能够正确的继续执行后续指令。</li>
</ol>


<p>Cooool！如果你一直认真看到这里，那么相信你的收获已经非常多了！</p>

<p>下面我们再看看block中的invoke函数和descriptor。希望跟第一集中的不要有太大差别。如下汇编代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.align  2
    .code   16                      @ @__doBlockA_block_invoke_0
    .thumb_func     ___doBlockA_block_invoke_0
___doBlockA_block_invoke_0:
    ldr     r0, [r0, #20]
    b.w     _foo

    .section        __TEXT,__cstring,cstring_literals
L_.str:                                 @ @.str
    .asciz   "v4@?0"

    .section        __TEXT,__objc_classname,cstring_literals
L_OBJC_CLASS_NAME_:                     @ @"\01L_OBJC_CLASS_NAME_"
    .asciz   "\001P"

    .section        __DATA,__const
    .align  2                       @ @__block_descriptor_tmp
___block_descriptor_tmp:
    .long   0                       @ 0x0
    .long   24                      @ 0x18
    .long   L_.str
    .long   L_OBJC_CLASS_NAME_</pre>


<p>看着没错，跟第一集中的没多大区别。唯一不同的就是block descriptor中的<strong><span style="color: #339966;">size</span></strong>——现在是<strong><span style="color: #339966;">24</span></strong>(之前是<strong><span style="color: #339966;">20</span></strong>)。这是因为block拷贝了一个整型值，所以block的结构需要24个字节，而不再是标准的20个字节了。在之前的代码中，我们已经分析了在创建block时，多出的4个字节被添加到block结构的尾部。<br/>
在实际的block函数中，例如<strong><span style="color: #339966;">___doBlockA_block_invoke_0</span></strong>，可以看到从block结构尾部读取出相关值，如<strong><span style="color: #339966;">r0 + 20</span></strong>，就是在block中拷贝的变量。</p>

<h2><strong><span style="color: #339966;">block拷贝对象的类型</span></strong></h2>

<p>下面我们来看看如果block拷贝的是别的对象类型(例如 <strong><span style="color: #339966;">NSString</span></strong>)，而不是integer，会发生什么呢？如下代码：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#import &lt;dispatch/dispatch.h&gt;

typedef void(^BlockA)(void);
void foo(NSString*);

__attribute__((noinline))
void runBlockA(BlockA block) {
    block();
}

void doBlockA() {
    NSString *a = @"A";
    BlockA block = ^{
        foo(a);
    };
    runBlockA(block);
}</pre>


<p>由于<strong><span style="color: #339966;">doBlockA</span></strong>变化不大，所以在此不深入介绍。这里感兴趣的是根据上面代码创建的block descriptor结构：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.section        __DATA,__const
    .align  4                       @ @__block_descriptor_tmp
___block_descriptor_tmp:
    .long   0                       @ 0x0
    .long   24                      @ 0x18
    .long   ___copy_helper_block_
    .long   ___destroy_helper_block_
    .long   L_.str1
    .long   L_OBJC_CLASS_NAME_</pre>


<p>注意看上面的汇编代码中有指向两个函数(<strong><span style="color: #339966;"><em>__copy_helper_block</em></span></strong>和<strong><span style="color: #339966;"><em>__destroy_helper_block</em></span></strong>)的指针。下面是这两个函数的定义：</p>

<pre class="wp-code-highlight prettyprint linenums:1">.align  2
    .code   16                      @ @__copy_helper_block_
    .thumb_func     ___copy_helper_block_
___copy_helper_block_:
    ldr     r1, [r1, #20]
    adds    r0, #20
    movs    r2, #3
    b.w     __Block_object_assign

    .align  2
    .code   16                      @ @__destroy_helper_block_
    .thumb_func     ___destroy_helper_block_
___destroy_helper_block_:
    ldr     r0, [r0, #20]
    movs    r1, #3
    b.w     __Block_object_dispose</pre>


<p>这里我先假设当block被拷贝和销毁时，都会调用这里的函数。那么被block拷贝的对象肯定会发生reatain和release。上面的代码中，可以看出如果r0和r1包含有效数据时，拷贝函数接收两个参数(<strong><span style="color: #339966;">r0</span></strong>和<strong><span style="color: #339966;">r1</span></strong>)。而销毁函数接收一个参数。可以看出所有的拷贝和销毁任务都应该是由<strong><span style="color: #339966;">__Block_object_assign</span></strong>和<strong><span style="color: #339966;">__Block_object_dispose</span></strong>两个函数完成的。这两个函数位于block的运行时代码中(是LLVM里面<strong><span style="color: #339966;">compiler-rt</span></strong>工程的一部分)。<br/>
如果你希望了解一下block运行时相关代码，可以来这里下载源码：<strong><span style="text-decoration: underline;"><span style="color: #339966; text-decoration: underline;"><a href="http://compiler-rt.llvm.org" target="_blank"><span style="color: #339966; text-decoration: underline;"><a href="http://compiler-rt.llvm.org">http://compiler-rt.llvm.org</a></span></a></span></span></strong>。特别关注一下里面的<strong><span style="color: #339966;">runtime.c</span></strong>文件。</p>

<h2><strong><span style="color: #339966;">何去何从</span></strong></h2>

<p>在下一集中我将调查<strong><span style="color: #339966;">Block_copy</span></strong>相关代码，并看看相关工作处理情况，以此来深度围观一下block运行时。通过下一集的学习，你也将会深入了解拷贝和销毁函数(也就是本文中我们刚刚看到的在block拷贝对象时使用的函数)。</p>

<p>本文由<span style="text-decoration: underline;"><span style="color: #339966;"><strong><a href="http://beyondvincent.com/"><span style="color: #339966; text-decoration: underline;">破船</span></a></strong></span></span>翻译●转载请注明出处●<time datetime="2013-05-18T17:37:00+08:00" data-updated="true">2013-07-10</time></p>
</div>

</article>

	<div class="share">
	<!-- JiaThis Button BEGIN -->
    <div class="jiathis_style_32x32">
        <a class="jiathis_button_tsina"></a>
        <a class="jiathis_button_tqq"></a>
        <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
        <a class="jiathis_counter_style"></a>
    </div>
    <script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1371195888343945" charset="utf-8"></script>
    <!-- JiaThis Button END -->
    
    
</div>




<section>
    <h1>评论</h1>
    <div id="comments" aria-live="polite"><!-- Duoshuo Comment BEGIN -->
<div class="ds-thread" data-author-key=“1”></div>
<script type="text/javascript">
    var duoshuoQuery = {short_name:"beyondvincent"};
    (function() {
     var ds = document.createElement('script');
     ds.type = 'text/javascript';ds.async = true;
     ds.src = 'http://static.duoshuo.com/embed.js';
     ds.charset = 'UTF-8';
     (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
     })();
    </script>
<!-- Duoshuo Comment END --></div>
</section>

</div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2013 - 破船(BeyondVincent) -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'beyondvincent001';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-42893468-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>





<script type="text/javascript">
    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F1a3c98825a726bfbf68a83ba97e0b9be' type='text/javascript'%3E%3C/script%3E"));
    </script>

		</div>
	</div>
</body>
</html>
