<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[破船之家]]></title>
  <link href="http://BeyondVincent.github.io/atom.xml" rel="self"/>
  <link href="http://BeyondVincent.github.io/"/>
  <updated>2014-01-24T10:39:53+08:00</updated>
  <id>http://BeyondVincent.github.io/</id>
  <author>
    <name><![CDATA[破船(BeyondVincent)]]></name>
    <email><![CDATA[beyondvincent@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C中的Literals]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/23/guided-tour-through-objective-c-literals/"/>
    <updated>2014-01-23T15:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/23/guided-tour-through-objective-c-literals</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2014/01/19.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/guided-tour-through-objective-c-literals/">Guided tour through Objective-C Literals</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>苹果在2012年就已经把Literals加入到LLVM中，利用Literals，不仅可以方便快捷的创建某些特定数据类型，还可以简化代码量，加强代码的可读性。</p>

<p>下面先来看看目录：</p>

<ol>
<li>NSNumber</li>
<li>NSArray</li>
<li>NSDictionary</li>
<li>Expressions</li>
</ol>


<p>下面我们就让代码来说话吧。</p>

<h3>1. NSNumber</h3>

<p>曾经你是否一直这样来实例化<code>NSNumber</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">integer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt:</span><span class="mi">19</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>是不是感觉比较麻烦，现在好了，通过Literal，只需要如下一行简洁的代码即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">integer</span> <span class="o">=</span> <span class="err">@</span><span class="mi">19</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，使用了<code>@</code>符号，这跟创建NSString一样(只是不用双引号吧了)，这样一来，就非常容易记住和使用啦。</p>

<p>不仅如此，我们还可以利用C语言中的后缀风格来定义NSNumber，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">unsignedInteger</span> <span class="o">=</span> <span class="err">@</span><span class="mi">19</span><span class="n">U</span><span class="p">;</span><span class="err">  </span> <span class="c1">//Unsigned Integer</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">longInteger</span> <span class="o">=</span> <span class="err">@</span><span class="mi">19L</span><span class="p">;</span><span class="err">      </span> <span class="c1">//Long Integer</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">floatNumber</span> <span class="o">=</span> <span class="err">@</span><span class="mf">19.5493F</span><span class="p">;</span><span class="err"> </span> <span class="c1">//Float </span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">boolean</span> <span class="o">=</span> <span class="err">@</span><span class="n">YES</span><span class="p">;</span> <span class="c1">//        //BOOL</span>
</span></code></pre></td></tr></table></div></figure>


<h3>2. NSArray</h3>

<p>有些编程语言创建数组是非常简单的，例如PHP。但是在引入Literal之前，Objective-C中创建数组的语法确不简单。如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObjects:</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt:</span><span class="mi">10</span><span class="p">],</span>
</span><span class='line'><span class="err">                                            </span><span class="s">@&quot;A String!&quot;</span><span class="p">,</span>
</span><span class='line'><span class="err">                                            </span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">10.654F</span><span class="p">],</span>
</span><span class='line'><span class="err">                                             </span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码中不仅初始化对象复杂，还需要额外添加一个nil。但是要用Literal，看起来完全不一样了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array_l</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">10</span><span class="p">,</span> <span class="s">@&quot;A string&quot;</span><span class="p">,</span> <span class="err">@</span><span class="mf">10.645F</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上所示，利用Literal，可以通过<code>@[]</code>轻松的搞定数组初始化，并且省掉最后的<code>nil</code>。实际上编译器会把上面的代码替换为<code>[NSArray arrayWithObjects:count:]</code>。</p>

<p>在Literal之前，访问数组中的对象需要使用一个类似这样的方法<code>objectAtIndex</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">objectAtIndex:</span><span class="mi">0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>而来到Literal的世界中，可以使用一对方括弧<code>[]</code>加对象对应的索引就可以访问到了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的语法，我们可以按照下面的方法来修改可变数组中的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithObject:</span><span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">11</span><span class="p">,</span><span class="err">@</span><span class="mi">76</span><span class="p">]];</span>
</span><span class='line'><span class="n">mutableArray</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="err">@</span><span class="mi">51</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>3. NSDictionary</h3>

<p>在Literal引入之前，NSDictionary对象的实例化跟NSArray类似，看起来也很长，并且在最后需要<code>nil</code>，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjects:</span><span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObjects:</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt:</span><span class="mi">10</span><span class="p">],</span>
</span><span class='line'><span class="err">                                                                                    </span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt:</span><span class="mi">20</span><span class="p">],</span>
</span><span class='line'><span class="err">                                                                                    </span><span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithInt:</span><span class="mi">30</span><span class="p">],</span>
</span><span class='line'><span class="err">                                                                                    </span><span class="nb">nil</span><span class="p">]</span>
</span><span class='line'><span class="err">                                                 </span><span class="nl">forKeys:</span><span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithObjects:</span> <span class="s">@&quot;first&quot;</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                                    </span><span class="s">@&quot;second&quot;</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                                    </span><span class="s">@&quot;third&quot;</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                                    </span><span class="nb">nil</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码看起来着实有点过头了。如果要用Literal的话，就简洁明了多了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">dicts</span> <span class="o">=</span> <span class="err">@</span><span class="p">{</span><span class="s">@&quot;first&quot;</span><span class="o">:</span><span class="err">@</span><span class="mi">10</span><span class="p">,</span> <span class="s">@&quot;second&quot;</span><span class="o">:</span><span class="err">@</span><span class="mi">20</span><span class="p">,</span> <span class="s">@&quot;third&quot;</span><span class="o">:</span><span class="err">@</span><span class="mi">30</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面NSDictionary实例化过程中，通过Literal，除了可以定义NSNumber和NSArray之外，还可以以可读的方式一一放置key和对应的值。相信这种方法大家都会喜欢。</p>

<p>从上面的介绍，你应该会喜欢上Literal，它确实可以让我们的代码更加容易读懂，并且不容易出错！！！</p>

<p>另外，我们还可以通过下面这样的方式访问字典中key对应的内容：(感谢<a href="http://weibo.com/u/2135198615">@谌启亮</a>在评论中的提醒)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">firstValue</span> <span class="o">=</span> <span class="n">dicts</span><span class="p">[</span><span class="s">@&quot;first&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>// 注意：下面这一点内容我摘自<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Objective-C-Literals-Boxed Expressions</a></p>

<h3>4. Expressions</h3>

<p>Objective-C提供了一种新的语法对C表达式进行包装：<code>@( &lt;expression&gt; )</code></p>

<p>它支持标量表达式(numeric, enumerated, BOOL)，以及C字符串指针类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// numbers.</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">smallestInt</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="o">-</span><span class="n">INT_MAX</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// [NSNumber numberWithInt:(-INT_MAX - 1)]</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">piOverTwo</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">M_PI</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>        <span class="c1">// [NSNumber numberWithDouble:(M_PI / 2)]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// enumerated types.</span>
</span><span class='line'><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">Red</span><span class="p">,</span> <span class="n">Green</span><span class="p">,</span> <span class="n">Blue</span> <span class="p">}</span> <span class="n">Color</span><span class="p">;</span>
</span><span class='line'><span class="n">NSNumber</span> <span class="o">*</span><span class="n">favoriteColor</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">Green</span><span class="p">);</span>       <span class="c1">// [NSNumber numberWithInt:((int)Green)]</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// strings.</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="err">@</span><span class="p">(</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;PATH&quot;</span><span class="p">));</span>       <span class="c1">// [NSString stringWithUTF8String:(getenv(&quot;PATH&quot;))]</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">pathComponents</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span> <span class="nl">componentsSeparatedByString:</span><span class="s">@&quot;:&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于Literals的更多详细内容可以参考：<a href="http://clang.llvm.org/docs/ObjectiveCLiterals.html">Objective-C-Literals</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何自定义iOS中的控件]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios/"/>
    <updated>2014-01-20T17:00:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/20/how-to-build-a-custom-control-in-ios</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2014/01/18.png" alt="" /></p>

<!--more-->


<p>本文译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在最后的评论中回复我。</p>

<p>下面先来看看目录：</p>

<ol>
<li>子类化UIControl

<ul>
<li>绘制用户界面

<ul>
<li>绘制背景</li>
<li>绘制用户的可操作区域</li>
<li>绘制手柄</li>
</ul>
</li>
<li>跟踪用户的操作

<ul>
<li>开始跟踪</li>
<li>持续跟踪</li>
<li>结束跟踪</li>
</ul>
</li>
<li>Target-Action模式</li>
</ul>
</li>
<li>如何使用自定义控件</li>
<li>总结</li>
<li>代码下载</li>
</ol>


<p>在开发过程中，有时候UIKit的标准控件并不能满足我们的需求，例如你需要一个控件能支持用户方便的选择0-360°之间的一个角度值，此时就需要根据自己的需求自定义控件了。</p>

<p>对于选择角度值的控件可以这样实现：创建一个圆形的滑块，用户通过拖动手柄操作就能选择角度值。实际上这样的控件在别的一些平台中你可能看到过，但是在UIKit中并没有。</p>

<p>本文就实现一个选择角度值的控件来介绍控件的自定义。下面先来看看到底要做成什么样子：</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/12.png" alt="" /></p>

<h3>1. 子类化UIControl</h3>

<p><code>UIControl</code>是UIView的子类，它又是所有UIKit控件的父类(例如UIButton、UISlider和UISwitch等)。</p>

<p>UIControl的主要作用是创建相应的逻辑将action分发到对应的target，另外90%的情况下，它会根据自身的状态(例如Highlighted, Selected和Disabled等)来绘制用户界面。</p>

<p>通过UIControl，我们主要管理3个重要的任务：</p>

<ul>
<li>绘制用户界面</li>
<li>跟踪用户的操作</li>
<li>Target-Action模式</li>
</ul>


<p>在本文的圆形滑块中，我们要做如下一些事情：</p>

<p>定制一个用户界面(圆形滑块本身)，通过该界面用户可以通过手柄进行界面交互。用户的交互操作会被转换为控件target对应的action(控件将滑块按钮的frame origin转换为0-360之间的一个值，并用于target/action上)。</p>

<p>建议在学习本文的时候从文章尾部的连接中下载完整的示例工程。</p>

<p>下面我将从上面列出的3个重要任务一一进行分解介绍。</p>

<p>这些步骤都是模块化的，所以如果你对界面的绘制不感兴趣，可以跳过<code>绘制用户界面</code>，直接学习后面的步骤。</p>

<p>打开工程文件中的<code>TBCircluarSlider.m</code>文件。然后开始学习下面的内容。</p>

<h4>1.1 绘制用户界面</h4>

<p>我比较喜欢使用Core Graphics，唯一用到UIKit的就是通过textfield来显示滑块的值。</p>

<p><code>提醒</code>：此处需要用到一些<code>Core Graphics</code>知识，如果你不懂也没多大关系，我会尽量把代码做详细的讲解。</p>

<p>我们先来看看控件的不同组成部分，这样更有利于后面的学习。</p>

<p>首先，是用一个<code>黑色的圆环</code>当做滑块的背景。</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/13.png" alt="" /></p>

<p><code>可操作区域(active area)</code>是一个从蓝色到紫色的梯度渐变效果。</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/14.png" alt="" /></p>

<p>用户通过拖拽下面的这个手柄按钮来选择值：</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/15.png" alt="" /></p>

<p>最后，用于显示选中值的<code>TextField</code>。在下一版中，我计划让用户可以通过键盘输入角度值。</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/16.png" alt="" /></p>

<p>控件界面的绘制主要使用drawRect函数，首选我们需要获取到当前使用的图形上下文，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGContextRef</span> <span class="n">ctx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<h5>1.1.1 绘制背景</h5>

<p>背景是360°的，所以只要用CGContextAddArc给图形上下文添加正确的path，并设置正确的stroke即可。</p>

<p>下面的代码可以就可以完成背景的绘制：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Add the arc path</span>
</span><span class='line'><span class="n">CGContextAddArc</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M_PI</span> <span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Set the stroke colour</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">]</span><span class="n">setStroke</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//set Line width and cap</span>
</span><span class='line'><span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">TB_BACKGROUND_WIDTH</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextSetLineCap</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">kCGLineCapButt</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//draw it!</span>
</span><span class='line'><span class="n">CGContextDrawPath</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">kCGPathStroke</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>CGContextArc</code>函数的参数包括图形上下文，弧度的中心坐标点，以及半径(是一个私有变量)，接着是弧度开始和结束时的角度(在TBCircularSlider.m文件的头部可以看到一些关于数学计算的方法)，最后一个参数标示绘制的方向，0表示逆时针方向。</p>

<p>接下来的3行的代码是用来设置一些信息的，例如颜色和线条宽度等。最后使用<code>CGContextDrawPath</code>方法完成背景的绘制。</p>

<h5>1.1.2 绘制用户的可操作区域</h5>

<p>这部分需要利用一点小技巧才行。此处我们绘制一个线性渐变的掩码图片，下面看看原理：</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/17.png" alt="" /></p>

<p>此处掩码图片的工作原理是可以看到原始渐变矩形框的一个孔。</p>

<p>在这里绘制的弧度有一个阴影，这是创建掩码图时使用了一点模糊的效果。</p>

<p>下面是创建掩码图的相关代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIGraphicsBeginImageContext</span><span class="p">(</span><span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span><span class="mi">320</span><span class="p">));</span>
</span><span class='line'><span class="n">CGContextRef</span> <span class="n">imageCtx</span> <span class="o">=</span> <span class="n">UIGraphicsGetCurrentContext</span><span class="p">();</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="n">CGContextAddArc</span><span class="p">(</span><span class="n">imageCtx</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="err"> </span> <span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ToRad</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">angle</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">[[</span><span class="n">UIColor</span> <span class="n">redColor</span><span class="p">]</span><span class="n">set</span><span class="p">];</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="c1">//Use shadow to create the Blur effect</span>
</span><span class='line'><span class="n">CGContextSetShadowWithColor</span><span class="p">(</span><span class="n">imageCtx</span><span class="p">,</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">self</span><span class="p">.</span><span class="n">angle</span><span class="o">/</span><span class="mi">20</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="c1">//define the path</span>
</span><span class='line'><span class="n">CGContextSetLineWidth</span><span class="p">(</span><span class="n">imageCtx</span><span class="p">,</span> <span class="n">TB_LINE_WIDTH</span><span class="p">);</span>
</span><span class='line'><span class="n">CGContextDrawPath</span><span class="p">(</span><span class="n">imageCtx</span><span class="p">,</span> <span class="n">kCGPathStroke</span><span class="p">);</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="c1">//save the context content into the image mask</span>
</span><span class='line'><span class="n">CGImageRef</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">CGBitmapContextCreateImage</span><span class="p">(</span><span class="n">UIGraphicsGetCurrentContext</span><span class="p">());</span>
</span><span class='line'><span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中首先创建了一个图形上下文，然后设置了一下阴影。通过<code>CGContextSetShadowWithColor</code>方法，我们可以设置如下内容：</p>

<ul>
<li>上下文</li>
<li>偏移量(此处不需要)</li>
<li>模糊值(该值是通过参数控制的：使用当前的角度除以20，当用户与此控件交互时，以此获得一个简单的动画模糊值)</li>
<li>颜色</li>
</ul>


<p>接着是根据当前的角度绘制一个相应的弧度。</p>

<p>例如，如果当前的角度变量是360°，那么就绘制一个圆弧，如果是90°，就绘制一个弧度为90°的一个弧。最后，利用<code>CGBitmapContextCreateImage</code>方法获取一张图片（刚刚绘制的弧）。这个图片就是我们所需要的掩码图了。</p>

<p>裁剪上下文：</p>

<p>现在我们已经有一个渐变的掩码图了。接着利用函数<code>CGContextClipToMask</code>对上下文进行裁剪——给该函数传入上面刚刚创建好的掩码图。代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGContextClipToMask</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后我们来绘制渐变效果，代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//Define the colour steps</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">components</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span><span class="err">    </span> <span class="c1">// Start color - Blue</span>
</span><span class='line'><span class="err">    </span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span><span class="err">  </span> <span class="c1">// End color - Violet</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="n">CGColorSpaceRef</span> <span class="n">baseSpace</span> <span class="o">=</span> <span class="n">CGColorSpaceCreateDeviceRGB</span><span class="p">();</span>
</span><span class='line'><span class="n">CGGradientRef</span> <span class="n">gradient</span> <span class="o">=</span> <span class="n">CGGradientCreateWithColorComponents</span><span class="p">(</span><span class="n">baseSpace</span><span class="p">,</span> <span class="n">components</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="c1">//Define the gradient direction </span>
</span><span class='line'><span class="n">CGPoint</span> <span class="n">startPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">rect</span><span class="p">),</span> <span class="n">CGRectGetMinY</span><span class="p">(</span><span class="n">rect</span><span class="p">));</span>
</span><span class='line'><span class="n">CGPoint</span> <span class="n">endPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">rect</span><span class="p">),</span> <span class="n">CGRectGetMaxY</span><span class="p">(</span><span class="n">rect</span><span class="p">));</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Choose a colour space</span>
</span><span class='line'><span class="n">CGColorSpaceRelease</span><span class="p">(</span><span class="n">baseSpace</span><span class="p">),</span> <span class="n">baseSpace</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="err">   </span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="c1">//Create and Draw the gradient</span>
</span><span class='line'><span class="n">CGContextDrawLinearGradient</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">gradient</span><span class="p">,</span> <span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="n">CGGradientRelease</span><span class="p">(</span><span class="n">gradient</span><span class="p">),</span> <span class="n">gradient</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>绘制渐变效果需要很多处理，不过我们可以将其分为4部分：</p>

<ul>
<li>定义颜色的变化范围</li>
<li>定义渐变的方向</li>
<li>选择颜色空间</li>
<li>创建并绘制渐变</li>
</ul>


<p>最终的显示效果(看到渐变矩形框的一部分)要归功于之前创建的掩码图。</p>

<p>另外，为了在背景边框模拟光线反射，我添加了一些灯光效果。</p>

<h5>1.1.3 绘制手柄</h5>

<p>下面我们根据当前的角度值，在的正确位置绘制出手柄。</p>

<p>实际上，在绘制过程中，这一步非常简单，复杂一点的就是计算一下手柄所在的位置。</p>

<p>这里我们需要使用三角函数将一个<code>标量值(scalar number)</code>转换为<code>CGPoint</code>。不要担心有多复杂，只需要使用Sin和Cos函数就可以完成。代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nf">pointFromAngle:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">angleInt</span><span class="p">{</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Define the Circle center</span>
</span><span class='line'><span class="err">    </span><span class="n">CGPoint</span> <span class="n">centerPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">TB_LINE_WIDTH</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">TB_LINE_WIDTH</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Define The point position on the circumference</span>
</span><span class='line'><span class="err">    </span><span class="n">CGPoint</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="err">    </span><span class="n">result</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">centerPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">ToRad</span><span class="p">(</span><span class="o">-</span><span class="n">angleInt</span><span class="p">)))</span> <span class="p">;</span>
</span><span class='line'><span class="err">    </span><span class="n">result</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">round</span><span class="p">(</span><span class="n">centerPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">ToRad</span><span class="p">(</span><span class="o">-</span><span class="n">angleInt</span><span class="p">)));</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，指定一个角度值，然后计算出在圆周上面的位置，当然，这里需要圆周的中心点和半径。</p>

<p>使用sin函数在使用sin函数时，需要一个Y坐标值，而cos函数则需要X坐标值。</p>

<p>需要注意的是此处每个函数返回的值都认为半径为1，所以需要将所得结果乘以我们指定的半径大小，并相对于圆周的中心做计算。</p>

<p>希望下面的公式对你的理解有所帮助：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
</span><span class='line'><span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过上面的计算，现在我们已经知道手柄的具体位置了，所以，接下来就直接将手柄绘制到指定位置即可，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">drawTheHandle:</span><span class="p">(</span><span class="n">CGContextRef</span><span class="p">)</span><span class="nv">ctx</span><span class="p">{</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="n">CGContextSaveGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//I Love shadows</span>
</span><span class='line'><span class="err">    </span><span class="n">CGContextSetShadowWithColor</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">);</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Get the handle position!</span>
</span><span class='line'><span class="err">    </span><span class="n">CGPoint</span> <span class="n">handleCenter</span> <span class="o">=</span><span class="err"> </span> <span class="p">[</span><span class="n">self</span> <span class="nl">pointFromAngle:</span> <span class="n">self</span><span class="p">.</span><span class="n">angle</span><span class="p">];</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Draw It!</span>
</span><span class='line'><span class="err">    </span><span class="p">[[</span><span class="n">UIColor</span> <span class="nl">colorWithWhite:</span><span class="mf">1.0</span> <span class="nl">alpha:</span><span class="mf">0.7</span><span class="p">]</span><span class="n">set</span><span class="p">];</span>
</span><span class='line'><span class="err">    </span><span class="n">CGContextFillEllipseInRect</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">handleCenter</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">handleCenter</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">TB_LINE_WIDTH</span><span class="p">,</span> <span class="n">TB_LINE_WIDTH</span><span class="p">));</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="n">CGContextRestoreGState</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体操作步骤如下：</p>

<ul>
<li>保存当前的上下文(当在一个单独的函数中进行绘制任务时，将上下文的状态进行保存是编程的一个好习惯)。</li>
<li>给手柄设置一些阴影效果</li>
<li>定义手柄的颜色，然后利用<code>CGContextFillEllipseInRect</code>将其绘制出来。</li>
</ul>


<p>我们在drawRect函数的最后调用上面这个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">drawTheHandle:</span><span class="n">ctx</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，我们就完成了绘制部分的任务。</p>

<h4>1.2 跟踪用户的操作</h4>

<p>在UIControl的子类中，我们可以<code>override</code>3个特殊的方法来提供一个自定义的跟踪行为</p>

<h5>1.2.1 开始跟踪</h5>

<p>当在控件的bound内发生了一个触摸事件，首先会调用控件的<code>beginTrackingWithTouch</code>方法。</p>

<p>我们就看看如何<code>override</code>这个方法吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">beginTrackingWithTouch:</span><span class="p">(</span><span class="n">UITouch</span> <span class="o">*</span><span class="p">)</span><span class="nv">touch</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">super</span> <span class="nl">beginTrackingWithTouch:</span><span class="n">touch</span> <span class="nl">withEvent:</span><span class="n">event</span><span class="p">];</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">    </span><span class="c1">//We need to track continuously</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>该函数返回的BOOl值决定着：当触摸事件是dragged时，是否需要响应。在我们这里的自定义控件中，是需要跟踪用户的dragging，所以返回YES。</p>

<p>上面这个函数有两个参数：touch对象和事件。</p>

<h5>1.2.2 持续跟踪</h5>

<p>在上一个方法中我们指定了这里的自定义控件需要跟踪一个持续的事件，所以当用户进行drag时，会调用一个特殊的方法：<code>continueTrackingWithTouch</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">continueTrackingWithTouch:</span><span class="p">(</span><span class="n">UITouch</span> <span class="o">*</span><span class="p">)</span><span class="nv">touch</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span>
</span></code></pre></td></tr></table></div></figure>


<p>该方法返回的BOOL值标示是否继续跟踪touch事件。</p>

<p>通过该方法我们可以根据touch位置对用户的操作进行过滤。例如，我们可以：仅当touch位置与手柄位置相交的时候才激活控件(activate control)。不过在这里我们的控制逻辑并不是这样的，我们希望用户点击任何位置都能对手柄做出相应的位置处理。</p>

<p>本文的该方法负责更新手柄的位置(在后面的一节中会看到我们把该位置信息传递给对应的target上)。</p>

<p>对上面这个方法的override代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">continueTrackingWithTouch:</span><span class="p">(</span><span class="n">UITouch</span> <span class="o">*</span><span class="p">)</span><span class="nv">touch</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">super</span> <span class="nl">continueTrackingWithTouch:</span><span class="n">touch</span> <span class="nl">withEvent:</span><span class="n">event</span><span class="p">];</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Get touch location</span>
</span><span class='line'><span class="err">    </span><span class="n">CGPoint</span> <span class="n">lastPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInView:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Use the location to design the Handle</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">self</span> <span class="nl">movehandle:</span><span class="n">lastPoint</span><span class="p">];</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">        </span><span class="c1">//We&#39;ll see this function in the next section:</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">self</span> <span class="nl">sendActionsForControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，首先利用<code>locationInView</code>获取到touch的位置，然后将该位置传递给<code>moveHandle</code>方法，该方法会将传入的值转换为一个有效的手柄位置(a valid handle position)。</p>

<p>此处“a valid position”的意思是什么呢？</p>

<p>此控件的手柄只能在背景圆弧定义的边界范围内做移动，但是我们不希望强制要求用户必须在很小的圆弧内才可以移动手柄，如果非要这样的话，用户体验会非常的糟糕。</p>

<p><code>moveHandle</code>的任务就是负责把任意的位置值转变为手柄可移动的值，另外，另外，在该函数中，还对指定的滑块角度值做了转换，代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">movehandle:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">lastPoint</span><span class="p">{</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Get the center</span>
</span><span class='line'><span class="err">    </span><span class="n">CGPoint</span> <span class="n">centerPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                            </span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Calculate the direction from the center point to an arbitrary position.</span>
</span><span class='line'><span class="err">    </span><span class="kt">float</span> <span class="n">currentAngle</span> <span class="o">=</span> <span class="n">AngleFromNorth</span><span class="p">(</span><span class="n">centerPoint</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                                </span><span class="n">lastPoint</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                                </span><span class="n">NO</span><span class="p">);</span>
</span><span class='line'><span class="err">    </span><span class="kt">int</span> <span class="n">angleInt</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">currentAngle</span><span class="p">);</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Store the new angle</span>
</span><span class='line'><span class="err">    </span><span class="n">self</span><span class="p">.</span><span class="n">angle</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">-</span> <span class="n">angleInt</span><span class="p">;</span>
</span><span class='line'><span class="err"> </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Update the textfield </span>
</span><span class='line'><span class="err">    </span><span class="n">_textField</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span><span class="err"> </span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span>
</span><span class='line'><span class="err">                                                                                                    </span><span class="n">self</span><span class="p">.</span><span class="n">angle</span><span class="p">];</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Redraw</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">self</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码中，实际上主要任务都是在<code>AngleFromNorth</code>方法中处理的：根据两个point，就会返回一个连接这两点对应的一个角度关系，<code>AngleFromNorth</code>方法的实现如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kr">inline</span> <span class="kt">float</span> <span class="nf">AngleFromNorth</span><span class="p">(</span><span class="n">CGPoint</span> <span class="n">p1</span><span class="p">,</span> <span class="n">CGPoint</span> <span class="n">p2</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="n">flipped</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="n">CGPoint</span> <span class="n">v</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="n">p2</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">p1</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'><span class="err">    </span><span class="kt">float</span> <span class="n">vmag</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">SQR</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">SQR</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">)),</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="err">    </span><span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">/=</span> <span class="n">vmag</span><span class="p">;</span>
</span><span class='line'><span class="err">    </span><span class="n">v</span><span class="p">.</span><span class="n">y</span> <span class="o">/=</span> <span class="n">vmag</span><span class="p">;</span>
</span><span class='line'><span class="err">    </span><span class="kt">double</span> <span class="n">radians</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="err">    </span><span class="n">result</span> <span class="o">=</span> <span class="n">ToDeg</span><span class="p">(</span><span class="n">radians</span><span class="p">);</span>
</span><span class='line'><span class="err">    </span><span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="err"> </span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="n">result</span> <span class="o">+</span> <span class="mf">360.0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>提醒：<code>angleFromNorth</code>方法并不是我的原创，我是直接从苹果提供的OSX示例clockControl中拿过来用的。</p>

<p>在上面的代码中，获得了角度值以后，将其存储到<code>angle</code>中，然后更新一下textfield的值。</p>

<p>接着调用的<code>setNeedDisplay</code>是为了确保<code>drawRect</code>被调用，以尽快在界面上做出相应的更新。</p>

<h5>1.2.3 结束跟踪</h5>

<p>当跟踪结束的时候，会调用下面这个方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">endTrackingWithTouch:</span><span class="p">(</span><span class="n">UITouch</span> <span class="o">*</span><span class="p">)</span><span class="nv">touch</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span><span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">super</span> <span class="nl">endTrackingWithTouch:</span><span class="n">touch</span> <span class="nl">withEvent:</span><span class="n">event</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在本文中，我们并不需要override该方法。如果当用户完成控件的界面操作时，你希望做一些处理，那么该方法会非常有用。</p>

<h4>1.3 Target-Action模式</h4>

<p>至此，圆形滑块控件可以工作了，你可以drag手柄，并能看到textfield中值的改变。</p>

<p>发送action——控件事件</p>

<p>如果希望自己定制的控件与UIControl行为保持一致，那么当控件的值发生变化时，需要进行通知处理：使用<code>sendActionsForControlEvents</code>方法，并制定特定的事件类型，值改变对应的事件一般是<code>UIControlEventValueChanged</code>。</p>

<p>苹果已经预定义了许多事件类型(Xcode中，在UIControlEventValueChanged上<code>cmd + 鼠标单击</code>)。如果你的控件是继承自UITextField，那么你可能会对<code>UIControlEventEdigitingDidBegin</code>感兴趣，如果你要做一个touch Up action，那么可以使用UIControlTouchUpInside。</p>

<p>如果你注意的话，在本文前部分的continueTrackingWithTouch方法里面，我们调用了<code>sendActionsForControlEvents</code>方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">sendActionsForControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样处理之后，当控件值发生变化时，每一个对象(观察者——注册该事件)都会收到响应的通知。</p>

<h3>2. 如何使用自定义控件</h3>

<p>到这里，我们的控件定制完毕，下面介绍如何在程序中使用自定义的控件。</p>

<p>打开文件<code>TBViewController.m</code>，看看<code>viewDidLoad</code>方法里面的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'><span class="err">    </span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="mf">0.1</span> <span class="nl">green:</span><span class="mf">0.1</span> <span class="nl">blue:</span><span class="mf">0.1</span> <span class="nl">alpha:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Create the Circular Slider</span>
</span><span class='line'><span class="err">    </span><span class="n">TBCircularSlider</span> <span class="o">*</span><span class="n">slider</span> <span class="o">=</span> <span class="p">[[</span><span class="n">TBCircularSlider</span> <span class="n">alloc</span><span class="p">]</span><span class="nl">initWithFrame:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="n">TB_SLIDER_SIZE</span><span class="p">,</span> <span class="n">TB_SLIDER_SIZE</span><span class="p">)];</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="c1">//Define Target-Action behaviour</span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">slider</span> <span class="nl">addTarget:</span><span class="n">self</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">newValue:</span><span class="p">)</span> <span class="nl">forControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span><span class='line'><span class="err">     </span>
</span><span class='line'><span class="err">    </span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">addSubview:</span><span class="n">slider</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，给view设置了一个背景色，并通过调用<code>initWithFrame</code>方法实例化了一个圆形滑块(自定义的控件)。</p>

<p>注意：UIControl继承自UIView，所以它继承了UIView的所有方法。</p>

<p>接着定义了如何与该控件进行交互：使用<code>addTarget:action:forControlEvent:</code>方法。</p>

<p>该方法只是给控件的特定事件设置一下target-action。如果你还记得的话，上面层介绍过，每当用户移动手柄时，圆形滑块都会发送一个UIControlEventValueChanged事件。所以我们可以通过下面的代码为该事件注册一个action：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">slider</span> <span class="nl">addTarget:</span><span class="n">self</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">newValue:</span><span class="p">)</span> <span class="nl">forControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样我们就可以创建一个<code>**newValue**</code>方法来处理值发生改变时的一些事情：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">newValue:</span><span class="p">(</span><span class="n">TBCircularSlider</span><span class="o">*</span><span class="p">)</span><span class="nv">slider</span><span class="p">{</span>
</span><span class='line'><span class="err">    </span><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Slider Value %d&quot;</span><span class="p">,</span><span class="n">slider</span><span class="p">.</span><span class="n">angle</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合Target-Action，所以函数会受到action的发送者，此处是slider，通过这个slider，就能直接获取到角度值。</p>

<h3>3. 总结</h3>

<p>根据本文的具体步骤，你可以构建<code>任意你想要的控件</code>。</p>

<p>当然，也有其它一些方法来构建自定控件，不过本文基本上是按照苹果的建议来做的。</p>

<p>点击下图，下载代码</p>

<h3>4. 代码下载</h3>

<p><a href="https://github.com/ariok/TB_CircularSlider"><img src="http://BeyondVincent.github.io/images/2013/11/34.jpg" alt="" /></a></p>

<p>本文由破船译自<a href="http://www.thinkandbuild.it/how-to-build-a-custom-control-in-ios/">How to build a custom control in iOS</a>。大家要是有什么问题，可以直接在<a href="https://twitter.com/bitwaker">twitter</a>上联系原作者，当然也可以在下面的评论中回复我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我写的第一本书：Windows 8开发实战体验]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/16/for-my-first-book/"/>
    <updated>2014-01-16T17:55:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/16/for-my-first-book</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2014/01/9.png" alt="" /></p>

<!--more-->


<p>2013年我写了一本书，书名叫做<a href="http://www.amazon.cn/dp/B00EOF7XKC">Windows 8开发实战体验</a>。在刚开始写该书的时候，我对Windows 8的前景还是看好的，每天经常写到半夜2-3点中。但是等书写完，出版出来的时候，我的心情确高兴不起来，因为此时大家都知道，windows 8不足以与iOS和Android抗衡，好多开发者都不看好它了，自然也就不在这方面发力。</p>

<p>还记得2012年下半年的时候，国内还是有许多开发者投入Windows 8的，不过到现在，基本已经没什么了。不知道Windows 8怎么了。是否值得期待Windows 9呢？</p>

<p>每当大家问起这书的销量时，我在想，Windows 8都这样了，还有人舍得去投资吗？估计对Windows 8的投入，也就是大公司为了各自产品的布局而没有舍弃的了。</p>

<p>如果你希望支持我一下的话，也可以去<a href="http://www.amazon.cn/dp/B00EOF7XKC">亚马逊</a>上买几本哟。</p>

<p>惯例，上几张图片：</p>

<p><img src="http://BeyondVincent.github.io/images/2014/01/11.png" alt="" /></p>

<p>下面是公司内刊《云电同方人》曾经对我的一个采访函，贴出来，就当纪念吧：</p>

<p>采访人物： 周智勋</p>

<p>采访问题：</p>

<p>1、    为什么会写这本书？写作的主要灵感源于何处？</p>

<p><code>其实本书涉及到的许多内容首先是发布到我博客中的，后来随着文章数量的增加，就有了出版的想法，进而开始跟出版社沟通相关事情。</code></p>

<p>2、    全书从酝酿到出版，总共花费了多久的时间？能否具体谈谈这个过程</p>

<p><code>从跟出版社约谈，到最终出版大约花了半年时间。其中大致经历了大纲制定、初稿编写、初审、二审和终审，以及下厂编册。</code></p>

<p>3、    作为技术性人才，很多人在写作这一方面并非特别擅长，那么在写这本书的过程有没有让你困扰的地方？</p>

<p><code>其实我也不擅长写作，很难做到胸有成竹，一直在想许多名著是如何写成的。后来慢慢的发现，日积月累真是个好词，许多事情都不是一蹴而就的。坚持了不一定成功，但是不坚持，一定不会成功。</code></p>

<p>4、    在这一过程中，有没有特别想要感谢的人？</p>

<p><code>当然要感谢我的家人和同事对我的技术支持和人文关怀</code></p>

<p>5、    这本书的完成对于你个人、团队、公司的意义分别是怎样的？</p>

<p><code>这本书对于我来说就是成长路上的一抹云彩，点缀了我的工作与生活，增加我人生阅历。由于公司和团队的良好氛围，让我能够得到茁壮成长，相信在这良好的土壤下，能够培养出更多、更优秀的人才。</code></p>

<p>6、    平时有没有什么兴趣爱好？你觉得这样的兴趣爱好对于你的工作和生活有什么影响吗？</p>

<p><code>跑步是我近些年养成的一个习惯。我不知道是不是真的喜欢跑步，因为在篮球和跑步面前，我几乎都会首选篮球。不过我享受跑步带给我的变化，在跑步沿途中不仅能欣赏到各种风景，还能让我身体健康。</code></p>

<p>7、    对你影响最大的一本书是什么？</p>

<p><code>谭浩强的《C程序设计》，是它让我踏上了IT这条不归路。</code></p>

<p>8、    能完成这样一本技术专著，可以说在IT业界也取得了一定成就，你有没有什么心得想与他人分享的？</p>

<p><code>成就谈不上，我只是沧海一粟。想跟大家说的一句话就是“坚持就有收获。</code></p>

<p>9、    对于现在很多刚入职或者已入职一段时间的IT人士深觉IT行业枯燥、乏味，你怎么看待？你能理解他们吗？</p>

<p><code>兴趣是最好的老师。当你对某件事情感兴趣，那么就会主动去接触它，了解它。如果觉得IT行业枯燥和乏味，最好的办法就是培养兴趣或者乘早转行。</code></p>

<p>10、 你个人觉得IT行业未来的发展趋势是怎样的？</p>

<p><code>这个话题有点hold不住！仅从个人角度来看，移动技术、智能客厅、物流整合、大数据和人工智能等都很有发展前景。</code></p>

<p>2014年我计划写一本iOS 8方面的书籍，按照惯例，要等到6月份苹果才会对开发者放出iOS 8的SDK，所以上半年主要做一些准备性的任务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[迟到的Windows 8]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/15/127-my-book-windows-8-developer/"/>
    <updated>2014-01-15T12:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/15/127-my-book-windows-8-developer</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/12/26.png" alt="" /></p>

<!--more-->


<p>目录</p>

<ol>
<li>小引</li>
<li>Windows 8简介</li>
<li>从用户的角度来看</li>
<li>从开发者的角度来看</li>
<li>微软的生态圈</li>
<li>小结</li>
</ol>


<h3>小引</h3>

<p>最近两年，移动互联网成了兵家必争之地，为了能够在移动互联网的浪潮中获得一席之地，各厂商正所谓八仙过海各显神通，腾讯首当其中，通过微信拿到了第一张船票，百度19亿美元拿下91助手，豪赌移动互联网，阿里巴巴入主高德，加快移动互联网布局，雷军借助小米手机，在国内已经与”中华酷联”并驾齐驱。当然，有成功，必然有失败，诺基亚本想借助微软的Windows Phone重拾当年王者之位，哪知最后埃洛普就是一个”间谍”，在诺基亚市值触底之际，反被微软低价收购，360与搜狗的恋爱谈了很久，结局是搜狗与腾讯联姻了。在这瞬息万变的朝代，人们似乎已经忘却了微软，其实微软对这一切的发生是看在眼里急在心里，但罗马不是一日建成的。今天我们就来看看微软在移动平台中打的一张牌——Windows 8。</p>

<h3>Windows 8简介</h3>

<p>Windows 8是微软在2012年10月25日正式发布的一款操作系统。该系统定义了用户与移动终端设备交互的全新概念——以内容为导向，结合简单、迅速和快捷的操作方式。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/17.png" alt="图1-1 Windows 8开始屏幕" /></p>

<p>为迎合用户的需求，微软在Windows 8的设计与研发上全力以赴，力图为用户打造出一款全新的操作系统，为人们提供高效易行的工作环境。从图1-1中，可以明显地感觉到Windows 8的用户界面与之前Windows版本的巨大差别。下面我们分别从用户和开发者的角度来了解一下Windows 8。</p>

<h3>从用户的角度来看</h3>

<ol>
<li>磁贴Windows 8的开始屏幕功能与之前Windows 版本的开始菜单类似，都是能启动某一个程序，不过开始屏幕还有更多的个性化功能。如图1-2所示，Windows 8的开始屏幕是由许多方块组成的，这些方块被称为动态磁贴(Tile)，用户可以自由调整这些方块的大小。通过点击磁贴，可以启动对应的程序。磁贴的另外一个重要功能就是内容的展现与更新。这体现出了Windows 8的一个重要设计原则—— 处处以内容为重。</li>
</ol>


<p><img src="http://BeyondVincent.github.io/images/2013/12/18.png" alt="图1-2 Windows 8开始屏幕中的磁贴" /></p>

<ol>
<li>沉浸式的用户界面Windows 8之前版本的基本用户界面如图1-3所示，是以桌面为主的应用程序界面风格——该类风格的典型特征是操作系统由不同的文件和程序软件组成。在桌面之上，可以陈列出多个窗口，一个程序对应一个窗口，或者多个窗口。<img src="http://BeyondVincent.github.io/images/2013/12/19.png" alt="图1-3 具有桌面概念的应用程序界面" /></li>
</ol>


<p>Windows 8应用商店的主界面如图1-4所示，可以看出，里面的程序像一个封闭的盒子，并且是没有边框的全屏显示，我们只能看到一个正在运行的程序界面。实际上，这种设计语言和风格是微软专门为Windows 8配备的，它是基于平面设计的，设计灵感来源于机场和地铁的指示牌。图1-4展现的信息可以概括为：大字体、强调信息本身、无冗余的界面元素。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/20.png" alt="图1-4 Windows 8应用商店的主界面" /></p>

<p>再如图1-5所示的是Windows 8中的天气程序，该程序以大号字体显示出天气信息，在程序中没有冗余的界面元素。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/21.png" alt="图1-5 Windows 8中的天气程序" /></p>

<p>从图1-4和图1-5可以明显地感觉到，当用户使用Windows 8商店应用程序时，是完全沉浸在整个程序中，且在使用过程中，不会被别的程序干扰或者强制中断，从而不会对用户造成任何的分心。</p>

<h3>从开发者的角度来看</h3>

<ol>
<li>Windows应用商店从苹果做的应用商店效果来看，这真是一个好舞台，个人开发者通过这个舞台发布个人应用的同时，还能带来乐观收入，苹果也能从中收取一定的费用，再者对用户来说不用漫天寻找需要的应用，只需要通过应用商店就可以获得需要的应用了。
当然，微软也搭建了自己的商店——Windows应用商店，运营模式与苹果的应用商店类似。如图1-6所示。<img src="http://BeyondVincent.github.io/images/2013/12/22.png" alt="图1-6 开始屏幕中的应用商店" /></li>
</ol>


<p>到这里，或许大家对微软的这张牌已经有所了解，更有甚者可能会嗤之以鼻，曰：这不就是在抄袭苹果的模式吗？没错，微软此举确有抄袭之嫌疑，不过，大家别忘了，腾讯刚开始不就是这么干的吗？当然，干这一行，是讲究互联网基因的，例如，中国移动的飞信就是因为缺乏互联网基因——它并不具备运营互联网产品的基本经验，虽手握绝对优势，但最终未免被其它IM蚕食，再说了，诺基亚之前也有自己的OVI商店，但是结果同样销声匿迹了。2. 开发框架与编程语言Windows 8商店应用程序开发支持多种编程语言，其中最重要的3种编程方式为：XAML + C#/VB、XAML/DirectX + C++、HTML5 + JS + CSS。
Windows 8对多种编程语言的支持，降低了开发者开发Windows 8商店应用程序的门槛，开发者可以利用之前已经掌握的语言来开发程序。1）开发框架
在Windows 8中开发的应用程序分为两种类型：
* Windows商店应用程序* 桌面应用程序其中桌面应用程序与之前Windows版本中的开发模式基本没有变化，这里重点介绍Windows商店应用程序的开发框架(如图1-7所示)，它具有如下两个重要特点：<img src="http://BeyondVincent.github.io/images/2013/12/23.png" alt="图1-7 Windows 8应用程序开发框架" /></p>

<ul>
<li>Windows Runtime。在Windows商店应用程序中只有一个主要的API层，这就是Windows Runtime，Windows Runtime负责与Windows Core OS Services进行通讯。开发者只需要与Windows Runtime交互即可。</li>
<li><p>多语言的支持。Windows商店应用程序开发很重要的一个特点就是在一个编程API（Windows Runtime APIs）上对多种语言的支持。在Windows 8中，微软已经把基于WPF和Silverlight的XAML用本地语言重写了一遍，C++、C、C#和VB编写的应用程序UI界面可以用XAML来定义。另外，在Windows 8中，微软增强了JavaScript的功能，通过JS Engine，JavaScript可以与Windows Runtime提供的APIs进行交互。这样一来，众多开发者（特别是会利用HTML和CSS开发网站和网页的开发者）也可以结合HTML/CSS和JavaScript来开发Windows商店应用程序。2）编程语言选择由于Windows 8应用程序开发支持多种编程语言，那么在具体的开发过程中，开发者就需要在多种编程语言之间选择适合的一种。图1-8简要描述了如何选择编程语言。<img src="http://BeyondVincent.github.io/images/2013/12/24.png" alt="图1-8 Windows商店应用程序开发编程语言的选择" />
一般在创建应用程序时，是基于开发者已经掌握的技术；如果是在移植已有的应用程序，则主要基于原有程序的类型。下面是在选择编程语言时需要注意的一些细节：</p></li>
<li><p>根据开发者已经掌握的技术做决定。如果擅长于JavaScript，那么建议选择HTML5和JavaScript作为编程语言。如果之前创建过Windows Phone程序或者WPF程序，那么使用C#/VB和XAML语言进行开发会更好。<em> 在决定移植程序时，则需要好好考虑一番。这种情况下，不能依赖所掌握的技术，而主要取决于将要移植的程序的类型。如果要将Windows Phone(Windows Phone 8以前的版本)程序进行移植，那么必须选择使用C#和XAML，这样之前的代码和功能才能重用，如果Windows Phone程序使用了类似MVVM的设计模式，那么可以在程序中使用对应的设计模式。而如果需要移植基于C++开发的游戏引擎等，就需要使用C++和XAML了。</em> 如果既掌握web开发，也熟悉C#  XAML开发，那么建议使用HTML5和JavaScript进行程序开发。因为JS Engine提供的控件与XAML控件一样，不用额外去编写控件。<em> 如果要创建高效的游戏程序，那么建议考虑使用C++和XAML。</em> 如果曾是.NET开发者，并且也熟练掌握HTML和JavaScript，建议使用C#和XAML。开发程序时会发现，这与.NET开发非常相似。例如，可以使用相同的设计模式（例如MVVM等）来创建程序。通过上面的分析，相信在开发过程中应该如何在开发中选择编程语言，读者已经心中有数了。下面我们来看看微软的生态圈。</p></li>
</ul>


<h3>微软的生态圈</h3>

<p>在互联网环境中，良好的生态圈，对企业的发展至关重要，腾讯在社交上、百度在搜索上和阿里在电商上等能站稳脚，都是因为他们在各自的阵营中建立起了良性的生态圈，让对此垂涎的企业难以对其撼动。我们也可以来看看苹果创建的生态圈：为了给用户最佳的体验，从硬件到软件，苹果层层把控，对别的厂商进行封闭不开放，利用自己的优势，为开发者和用户提供一个应用发布销售和购买下载的大舞台——苹果应用商店。这不仅让自己的利益最大化，也能够极好“绑架”开发者和用户，并对其它厂商做到排斥。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/25.png" alt="图1-8 Windows商店应用程序开发编程语言的选择" /></p>

<p>说了这么多，读者可能不乐意了，你不是要谈论微软的生态圈吗，干嘛东扯西扯的呢？其实不然，微软在生态圈上的想法实际上跟苹果雷同。涉及到的几个主体无非就是开发者、用户和自己，另外与苹果有一大区别就是其它厂商。我们都知道，微软在Windows 8之前主打的是软件，硬件则由其它各厂商生产。而在Windows 8中则不同了，微软开始涉水硬件了，它也想像苹果一样把软件和硬件牢牢握在自己手中，因此Surface面世了，再过几天Surface2也可以预定到了。其实我并不关心什么时候能买到Surface2，我在意的是微软如何找准与各硬件厂商的利益平衡点。</p>

<h3>小结</h3>

<p>Windows 8发布至今(2014年1月)，过去一年多了，或许你在感悟时间过得太快，但我想说，Windows 8来得太迟了，要不是Windows 8有这么强大的一个爹，在这战火纷飞的移动平台，想必Windows 8还没开始就已经谢幕了。
在这一年时间里，我们看到Windows 8交出的成绩其实并不如人意，想必用惨不忍睹来形容也不为过。用户和开发者的热衷度已经在大幅下降，甚至各厂商都在持观望的态度，相信他们都是有底线的。至于Windows 8操作系统能否在众多竞争平台中突出重围，留给微软的时间已经不多了，随着PC市场趋于饱和，在移动平台上，如果微软再拿不出杀手锏的话，或许微软真要重演诺基亚的悲剧了。</p>

<p>当然，移动互联网的这番厮杀与角逐，无论谁赢谁输，我相信最大的获益者之一将会是用户。作为用户，我们就在台下，好好欣赏这一幕幕好戏吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给tableview cell添加动画]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/13/animation-tableview-cell/"/>
    <updated>2014-01-13T17:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/13/animation-tableview-cell</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2014/01/5.png" alt="" /></p>

<!--more-->


<h3>小引</h3>

<p>本文介绍如何利用给tableview cell添加动画。其实只需要很少的代码量就可以。本文参考<a href="http://www.thinkandbuild.it/animating-uitableview-cells/">Animating UITableView cells</a></p>

<p>下面先来看看最终的效果：</p>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNjYxMTgxOTQw" frameborder=0 allowfullscreen></iframe>


<p>从上面的视频中，可以看出，当cell显示出来的时候，是在Y和Z轴上进行3D旋转。</p>

<p>下面来看看是如何实现的：</p>

<p>首先假设你已经能够熟练使用UITableView了。那么我们只需要实现UITableViewDelegate中的tableView:WillDisplayCell:ForRowAtIndexPath:即可。当cell显示之前，会先调用该方法，因此给cell添加动画，在这个方法里面即可。</p>

<p>如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">tableView:</span><span class="p">(</span><span class="n">UITableView</span> <span class="o">*</span><span class="p">)</span><span class="nv">tableView</span> <span class="nf">willDisplayCell:</span><span class="p">(</span><span class="n">UITableViewCell</span> <span class="o">*</span><span class="p">)</span><span class="nv">cell</span> <span class="nf">forRowAtIndexPath:</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="p">)</span><span class="nv">indexPath</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 1. 配置CATransform3D的内容</span>
</span><span class='line'>    <span class="n">CATransform3D</span> <span class="n">transform</span><span class="p">;</span>
</span><span class='line'>    <span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DMakeRotation</span><span class="p">(</span> <span class="p">(</span><span class="mf">90.0</span><span class="o">*</span><span class="n">M_PI</span><span class="p">)</span><span class="o">/</span><span class="mi">180</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">);</span>
</span><span class='line'>    <span class="n">transform</span><span class="p">.</span><span class="n">m34</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span> <span class="o">-</span><span class="mi">600</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 2. 定义cell的初始状态</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIColor</span> <span class="n">blackColor</span><span class="p">]</span><span class="n">CGColor</span><span class="p">];</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">transform</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 3. 定义cell的最终状态，并提交动画</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">beginAnimations:</span><span class="s">@&quot;transform&quot;</span> <span class="nl">context:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="nl">setAnimationDuration:</span><span class="mf">0.5</span><span class="p">];</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CATransform3DIdentity</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">cell</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cell</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">cell</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">cell</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[</span><span class="n">UIView</span> <span class="n">commitAnimations</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一步：使用CATransform3D在Y和Z轴上做旋转设置。</p>

<p>第二步：定义cell的初始状态，添加了一些阴影，并将第一步中的transform设置给cell中layer的transform matrix。然后将anchor设置为0.0, 0.5，也就是说让cell围绕着左边进行旋转。</p>

<p>第三步：通过动画，将cell设置为原始状态。此处利用了UIView的beginAnimations:context方法来更新cell中layer的值。当然还有别的方法来执行动画，不过这种方法比较简单，我们可以设置持续时间。代码里面将transform设置为CATransform3DIdentity。</p>

<p>这样通过第二步和第三步的状态就能够引导动画，以此完成最终效果。</p>

<p>完整代码工程下载地址：
<a href="https://github.com/BeyondVincent/BVTableViewAnimation">BVTableViewAnimation</a></p>

<p>下面是网上看到的两个内容，可以参考：</p>

<p><a href="http://www.raywenderlich.com/49311/advanced-table-view-animations-tutorial-drop-in-cards">From RW：Table View Animations Tutorial: Drop-In Cards</a><a href="http://weibo.com/522056706"><code>@bluesea哈哈哈</code></a>推荐本链接</p>

<p><a href="http://maniacdev.com/2013/05/library-allowing-you-to-create-table-views-with-wacky-highly-detailed-ripple-cell-animations">Library Allowing You To Create Table Views With Wacky Highly Detailed Ripple Cell Animations
</a></p>

<p><a href="http://maniacdev.com/2012/05/drop-in-open-source-library-for-creating-wacky-animated-uitableviews">Drop-In Open Source Library For Creating Wacky Animated UITableViews</a></p>

<p>希望上面介绍对你有帮助，如果有问题，可以在下面的回复我。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-3-iOS开发个人提升]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/11/129-my-iOS-growth-path-3/"/>
    <updated>2014-01-11T03:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/11/129-my-iOS-growth-path-3</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/12/11.png" alt="" /></p>

<!--more-->


<p>注1：这篇文章是我的iOS成长之路系列文章中的第三篇文章，第一篇文章：<a href="http://beyondvincent.com/blog/2013/12/17/125-my-iOS-growth-path-1/">iOS成长之路-1-入门</a>，第二篇文章：
<a href="http://beyondvincent.com/blog/2014/01/06/126-my-iOS-growth-path-2/">iOS成长之路-2-我的第一个iOS Demo</a>。</p>

<p>通过两周时间来学习iOS，我慢慢的叩开了iOS开发的大门，接下来就是一个积累的过程，我主要经历了如下几个过程：</p>

<ul>
<li>饱览群书</li>
<li>跟着项目一起成长</li>
<li>与同行交流</li>
<li>做一些分享</li>
</ul>


<h3>饱览群书</h3>

<p><img src="http://BeyondVincent.github.io/images/2014/01/2.jpg" alt="" /></p>

<p>  在初期，我认为多看书对于个人提升有很大的帮助，从某方面来说，这主要扩展了个人对iOS开发的理解广度(初期，先不要急于往最深处研究)，接着把书上的讲解与动手编程结合起来，这样可以加强编程理解能力。</p>

<p>  我们在选择书籍的时候，一定要注重质量，如果英文阅读能力没问题的话，建议直接上英文书籍(不解释)，例如iOS 7 Programming Cookbook，或者iOS7 by Tutorials(最新版)，如果英文有点吃力的话，我还是建议看英文书籍，看不懂的可以用google翻译，记得我在搞Symbian开发时，看英文书籍的时候，就是经常开着<a href="http://translate.google.cn/?hl=en">google翻译</a>。相信硬着头皮看上1个月，你会有各种感受，慢慢的，你会觉得英文内容读起来非常的行云流水，理解起来也要比中文书籍更加容易。</p>

<p>  另外，这里所说的饱览群书，还包括网络中的学习资料，你可以订阅一些iOS开发相关的博文，我曾在<a href="http://beyondvincent.com/blog/2013/07/18/106/">这里汇总了一些不错的博文</a>，你可以去订阅一下。</p>

<p>  还有两个好去处就是苹果每年WWDC上出的大量参考资料，最新的是<a href="https://developer.apple.com/wwdc/videos/">WWDC2013</a>，值得拥有。再一个就是来自斯坦福大学的公开课<a href="https://itunes.apple.com/us/course/developing-ios-7-apps-for/id733644550">Developing iOS 7 Apps for iPhone and iPad</a>，也非常适合初学者。</p>

<p>  最后，你还需要知道两个网站：<a href="https://github.com/">github</a>和<a href="http://stackoverflow.com/">stackoverflow</a>，其中github主要用来存放开源项目，你可以在这里学习到别人的好多精华，好多内容都可以拿过来直接使用。另外stackoverflow是国外一个非常著名的问答网站，学习初期，基本上你遇到的问题，都能在这里搜索到相关解答。</p>

<h3>跟着项目一起成长</h3>

<p>  我觉得做项目对个人成长非常快，特别如果你是初学者的话，因为你是带着问题去学习和思考，同时也会有一定的项目压力，迫使你不断向前进。当然，大多数项目涉及到的知识点都会有一定的局限性，例如音乐类软件，主要涉及到多媒体相关的知识，而阅读类的软件可能对于图形渲染要求要多一点。虽说项目涉及到的知识有一定的局限性，但是它需要有一定的深度，所以对个人能力的提升也非常有效。</p>

<p>  另外，各项目之间也会有一些共性，只要你熟悉了这些共性，那么在项目之间可以拿来即用，例如网络模块、数据存储模块，有些项目可能就是业务需求不同而已。</p>

<p>  如果你是初学者的话，要是有机会做项目，千万不要错过学习提升的好机会，不要因为项目压力，有什么想法，相信顶住各种压力和想法，最后你会感谢曾经努力的你。</p>

<h3>与同行交流</h3>

<p><img src="http://BeyondVincent.github.io/images/2014/01/3.jpg" alt="" /></p>

<p>  有时候，你一个人在做项目，或者学习时，或许会感觉到特别的孤独，有一颗特别强烈的心，迫切想跟外界进行交流：这个功能点的实现可行吗？有人遇到同样的问题吗？别人是如何做的？</p>

<p>  其实，在开发或学习过程中，多与同行进行交流是非常有帮助的，交流过程中，有时候一个问题，一个想法，经他人指点，会有茅塞顿开的感觉。当然，交流的对象最好是经验丰富的喽。这样你更加容易信任对方，可以把他当做你前进的灯塔。</p>

<p>  不过交流也需要一定的技巧的，遇到问题不是一味的去咨询别人，你可以首先尝试自己解决，别忘记google可是万能的。当然也并不是任何时候都有交流的对象。</p>

<h3>做一些分享</h3>

<p><img src="http://BeyondVincent.github.io/images/2014/01/4.jpg" alt="" /></p>

<p>  我曾经翻译过一些文章和书籍，本来看起很简单的事情，内容也看得懂，但是要想再次用中文表达，其实并没有想象中的简单，好多时候，你需要反复的推敲，并查阅更多的资料，以确保你所翻译出来的内容是正确的。</p>

<p>  一句话，这东西需要坚持，到最后，你会发现收获颇多，另外，当你的成果得到别人的认可，对你也会是一个不小的鼓舞。</p>

<p>  当然，要是能做一些原创内容分享，是再好不过的了，因为在写原创内容的时候，你首先需要做一个构思和规划，并会查阅大量在资料，以此来支撑自己分享的内容。这要比翻译文章高级多了，翻译那是跟着别人的思路走。</p>

<p>  或许你想说，你是程序员，只会写代码，不擅长写文章，写总结，那反过来，试问谁有天生会呢？相信熟能生巧，你所需要做的就是大胆的迈出第一步，然后坚持走下去！</p>

<h3>小结</h3>

<p>上面写了一些关于iOS开发提升方面的内容，实际上这不仅针对iOS，其它平台或者技术同样可行。希望文中的内容对你有些许帮助，如果有任何疑问，可以在下方给我留言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-2-我的第一个iOS Demo]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/06/126-my-iOS-growth-path-2/"/>
    <updated>2014-01-06T23:57:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/06/126-my-iOS-growth-path-2</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/12/10.png" alt="" /></p>

<!--more-->


<p>注1：本文是我在2011年9月花了两周时间做了我的第一个iOS Demo。这篇文章是我的iOS成长之路系列文章中的第二篇文章，第一篇文章请来这里看<a href="http://beyondvincent.com/blog/2013/12/17/125-my-iOS-growth-path-1/">iOS成长之路-1-入门</a></p>

<p>下面先来看看本文的目录</p>

<ol>
<li>概述</li>
<li>业务需求</li>
<li>框架</li>
<li>UML图(用例图、类图和时序图)</li>
<li>小结</li>
</ol>


<p>通过2周时间的开发，我的第一个iOS程序基本做成。下面对此次开发进行一个总结。以便清楚的认识到开发中的一些不足之处，并积累下经验，为后续的开发提供参考依据。</p>

<h3>概述</h3>

<p>由于时间紧迫，在这里做了一个精简版的移动办公软件。主要功能有如下：</p>

<ol>
<li>登录</li>
<li>查看公司发文待办</li>
<li>查看文件单信息(包括意见信息)</li>
<li>浏览正文</li>
<li>浏览附件</li>
<li>填写意见</li>
<li>发送文件</li>
</ol>


<p>下面将主要从此次开发涉及到的业务，结合使用到的框架、类图和时序图进行优势和缺陷总结。</p>

<h3>业务需求</h3>

<p>本次开发中涉及到的业务逻辑并不复杂，可以用下图进行表述：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/12.png" alt="" /></p>

<p>我们可以把整个过程理解为：数据获取->数据展现->数据采集->数据反馈</p>

<p>根据以往开发经验，手机终端的移动办公业务逻辑基本上都可以从上图中的流程演变而来。针对这样的业务需求，下面进行适合这种业务的框架设计介绍。针对不同的开发平台，这种框架会有一些缺陷，同样也会在此进行描述，并希望能够找到相关好的解决方案。</p>

<h3>框架</h3>

<p>下图是此次MOA开发过程中的整体框架图。此图分为3个层面。最上面一层是UI显示层，在这一层主要是做UI方面的显示，是直接面向用户的。中间一层是DataAccess层，该层主要的职责是把所有的数据访问都封装起来。第三层封装了网络访问、文件操作、XML文件解析等。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/13.png" alt="" /></p>

<p>下面将根据此次开发的情况，说一下该框架的优点和缺陷</p>

<p>优点：</p>

<ol>
<li>整体层次清晰，不复杂，无论是老手还是新手，都能够很容易的理解并在上面进行开发。</li>
<li>实现了UI与数据的分离，降低了业务数据与UI界面的耦合度，无论是UI需求的变更，还是业务数据逻辑的变化，都减小了UI与数据之间的影响。</li>
<li>模块的独立性，各个模块之间能够做到到低耦合、高内聚，这样不仅在此次开发中方便使用，在今后的相关开发项目中，也可以直接拿过来就使用，加强了软件的复用性原则。</li>
</ol>


<p>缺陷：</p>

<ol>
<li>数据的凌乱性。在此次开发中，数据全部放在DataAccess里面，这样加深了UI界面与DataAccess层的耦合度，在一定程度上，不利于UI与数据分离。</li>
<li>有时会导致级联修改。尤其是体现在至上而下的方向。如果在表示层需要增加一个功能，为保证其设计符合分层结构，可能在第二层，第三层都需要做相应的调整。</li>
<li>第三层里面的封装性不强，特别是XML解析的封装。在针对面向对象开发，应该加强XML解析的抽象封装力度，否则编写的代码就是一次性的，不符合软件开发的复用性原则，同时也增加了代码的无用性，并不利于后期的变更维护。</li>
<li>目前设计中存在一个严重的缺陷，现在只能同时并发一个网络异步请求。这在前期的设计中没有做详细的考虑，下一步需要对此进行改进，已达到支持多个异步请求操作。</li>
</ol>


<p>一些思考：</p>

<ol>
<li>为了加强UI与数据之间的高度分离，有必要对DataAccess进行职责细化。在第二层里面增加一个模块：model[数据模型]，把DataAccess中的数据提取到model里面，DataAccess和UI涉及到的数据都存放在model模块中。这样更加利于DataAccess层的职责单一，以及数据与UI能够更好的进行交互。</li>
<li>在第三层里面，涉及到的一些数据操作，需要加强抽象封装力度，尽量做到软件的复用性。此次开发中，特别是xml数据的解析，前期没有做好充分的考虑与设计，导致后期出现了单纯的copy and paste。非常不好。需要想办法改进。</li>
<li>在iOS中，cocoa touch层已经为开发者提供了视图控制器功能，这在简单UI开发中已经非常够用并实用了。在此，有个预想，如果在遇到UI比较复杂的应用场景时，cocoa touch提供的视图控制器不能满足，可能需要在框架中增加视图管理模块。</li>
<li>UI方面积累：iOS在UI方面做得非常到位，做iOS开发，必须在UI方面做出特色，根据相关业务(移动办公)特点，真正使做出的产品是用户需要的、用户想要的。因此，在UI方面，必须要加强技术与经验的积累。</li>
</ol>


<h3>UML图(用例图、类图和时序图)</h3>

<h4>用例图</h4>

<p>此次实现的功能，可以用下图进行描述。主要涉及到的业务是公司的发文。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/14.png" alt="" /></p>

<p>在此版中，没有进行考虑，并且在今后的版本中需要进行考虑的功能如下：</p>

<ol>
<li>消息的及时推送功能。此功能非常的有必要去思考并实现。一条待办事项，极有可能是紧急待办处理的，这是就需要用户在第一时间得知消息，并及时的进行处理。并且，在消息的传递过程中，消息应该主动被用户所感知。
所以一条新消息来了，不能依赖于用户主动的去服务器刷新数据进行检测新消息，应该提供一种机制，当服务器上有某个用户的新消息时，能够及时的传达给用户。</li>
<li>用户使用环境的可配置型。随着用户的办公场景变化、所处网络变化，我们的移动办公系统，最理想的要求就是根据所述变化，智能的进行选择用户环境，最低要求是能够方便用户进行环境的可配置。</li>
<li>日志。把用户的登录、操作信息记录并归档。</li>
<li>意见反馈。通过意见反馈窗口，用户可以方便的把自己对使用软件上的一些想法、建议、问题反馈给我们，我们也能够及时的了解到用户的意见，并对用户意见进行考虑，对我们的软件进行更新升级。</li>
</ol>


<p>在此版中已经存在的，但是在今后版本中需要加强考虑的功能：</p>

<ol>
<li>应用与用户交互体验方面(界面易操作、功能易理解、应用的鲁棒性等)</li>
</ol>


<h4>类图</h4>

<p>下图展示了此次开发中的类图结构，为了图的层次清晰，图中绘制了主要的相关类，有些使用到的类在图中并没有绘制出来，但他们同样是此次开发中重要的一部分。此次涉及到的类图并不复杂，在此次总结中，不做类图的详细介绍。通过下图，很容易理解类图的结构。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/15.png" alt="" /></p>

<h4>时序图</h4>

<p>下面涉及到的内容比较偏重与细节。基于以下原因，在这里只针对登录操作的时序图进行介绍。</p>

<ol>
<li>本次开发涉及到比较复杂的时序是网络的请求过程。</li>
<li>登录请求的完整过程，与其他请求(待办请求、文件单信息请求等)基本相同。</li>
</ol>


<p>当用户点击登录按钮进行登录操作时，会走如下流程(正常情况下，即网络通畅，用户名和密码正确)
首先LoginViewController通过DataAccess，调用XMLHandle的方法，组合出请求的数据内容(下图中的第3、4步骤)。</p>

<p>然后DataAccess调用ASIHTTPRequest方法(下图中第5、6步骤)，发起异步登录请求。</p>

<p>其次，当网络请求完毕，ASIHTTPRequest的delegate(第7步骤[DataAccess遵从])会被调用，DataAccess会调用XMLHandle的方法(第8步骤)进行数据解析。</p>

<p>最后DataAccess会调用DataAccess的delegate（第10步骤），通知LoginViewController，登录请求结果，LoginViewController根据请求的结果，如果登录成功，则进入待办列表画面(第11步骤)。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/16.png" alt="" /></p>

<h3>小结</h3>

<p>以上就是我在学习iOS开发初期，写的第一个iOS Demo，功能虽然略显粗糙，希望对初学者有一个参考作用，如果你对文中的内容有想法，可以在下面的回复中，与我交流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我在2014年中的一些计划]]></title>
    <link href="http://BeyondVincent.github.io/blog/2014/01/01/129-some_of_my_plan_in_2014/"/>
    <updated>2014-01-01T23:59:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2014/01/01/129-some_of_my_plan_in_2014</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2014/01/1.png" alt="" /></p>

<!--more-->


<p>现在已经是2014年了，一直以来都是按照年来做计划的，虽然还不知道2014年里会发生的全部事情，但是我心里还是有一些计划想要去做，暂且先把想到的列举出来，等2014年12月31日时，可以回头看看，年初的计划，有多少已经实现了，有多少半途而废，又有多少一直没有启动。</p>

<p>注意：此处只对8小时之外做计划。最近会对此计划做更新。</p>

<ul>
<li>完婚：把终生大事搞定</li>
<li>跑步：2014年跑量达到1500km，完成一次马拉松</li>
<li>写书：筹备写一本关于iOS 8开发方面的书</li>
<li>读书：5本非技术类书籍</li>
<li>翻译：翻译一本外文书籍</li>
<li>博客：不低于每周写一篇博文</li>
<li>考证：把信息系统项目管理师拿下</li>
</ul>


<p>hello 2014！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的2013时间线]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/12/31/128-all_my_2013/"/>
    <updated>2013-12-31T23:59:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/12/31/128-all_my_2013</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/12/27.png" alt="" /></p>

<!--more-->


<p>下面列出了2013年中，我的8小时之外都做了些什么重要的事情，每月列一项重要的：</p>

<ul>
<li>2013年1月：从北京回到昆明</li>
<li>2013年2月：开始筹备新书的编写：Windows 8实战体验</li>
<li>2013年3月：备战2013年昆明高原国际半程马拉松</li>
<li>2013年4月：日以继夜撰写书籍Windows 8实战体验</li>
<li>2013年5月：昆明马拉松完赛</li>
<li>2013年6月：在我的博客中写了一些关于iOS 7的文章</li>
<li>2013年7月：微信公众账号使用体验</li>
<li>2013年8月：Windows 8实战体验正式出版</li>
<li>2013年9月：运动无极限</li>
<li>2013年10月：完成订婚</li>
<li>2013年11月：吃遍广西米粉</li>
<li>2013年12月：参与raywenderlich发起的关于iOS 7 by Tutorials相关章节翻译</li>
</ul>


<p>2013年做了好多事情，也有好多事情没有展开，也有好多事情半程搁置了。总的来说，达到预期效果，书出了，马拉松完成了，外文翻译也有一定的数量啦。</p>

<p>2013 goodbye！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的iOS成长之路-1-入门]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/12/17/125-my-iOS-growth-path-1/"/>
    <updated>2013-12-17T21:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/12/17/125-my-iOS-growth-path-1</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/12/9.png" alt="" /></p>

<!--more-->


<p>注1：我是从2011年8月份开始接触iOS开发的，到现在(2013年12月)有2年多时间了，我计划用3篇文章来总结一下我的iOS成长之路：入门、我的第一个iOS Demo和iOS开发个人提升，本文就是这个系列中的第一篇文章。</p>

<p>注2：本文主要以日志的形式记录我的iOS入门。共计2周时间。由于时间有点久远了，可能有些内容已经过时了。</p>

<h3>第一周</h3>

<p><code>2011年8月15日</code>：今天第一次接触苹果电脑，还是一体机。在开电脑的时候遇到了一个笑话，居然找不到苹果一体机的开机键在哪里。后来还是谷歌大神告诉了我——在背后。这事太囧了。你也跟我遇到一样的笑话吗？</p>

<p><code>2011年8月16日</code>：iOS开发环境熟悉。电脑已经安装配置好了iPhone开发环境，但是作为一名入门级选手，还是从环境的搭建开始比较好。所以我还是先来熟悉一下iOS开发环境。</p>

<p>iPhone开发环境通常有两种</p>

<ol>
<li>一种是在windows xp下通过虚拟机安装苹果操作系统——俗称黑苹果，然后在进行开发环境的配置。</li>
<li>另外一种就是购置一台苹果电脑，在里面配置开发环境（推荐此方法）。</li>
</ol>


<p>在配置开发环境的时候需要用到iOS SDK和Xcode。开发环境提供了一个模拟器，大多数情况下开发的应用可以在模拟器上进行测试，有些涉及到3G网络等实际环境下测试的，就需要一台iPhone手机。也建议及早的把应用部署到真机上进行测试，以避免后期部署出现不可预测的情况，来降低风险。</p>

<p>我今天制定的学习路线是这样的：学习obj-c开发语言，熟悉iPhone-SDK，掌握iOS开发框架。</p>

<p><code>2011年8月17日</code>：今天完成了iPhone下HelloWorld程序编写，初步了解在iPhone中开发应用的流程。还有一些疑问需要解决：delegate的使用、mvc在iPhone下应用、Interface Builder的入门操作、iPhone应用程序框架的了解。</p>

<p><code>2011年8月18日</code>：今天主要学习了如下内容：</p>

<ol>
<li>iOS技术概览： iOS操作系统是iPhone、iPod touch 以及iPad设备的核心，下图是iOS的框架图，由4层构成。其中Cocoa Touch层是我们在今后开发中主要接触的一层，并且建议能用这层提供的服务，尽量不用底层的，因为这样不仅可以减少代码量，也可以减少程序的复杂度。</li>
</ol>


<p><img src="http://BeyondVincent.github.io/images/2013/12/8.jpg" alt="" /></p>

<p>2、对iOS中插座变量、动作、视图控制器和视图切换进行了学习。</p>

<p>A:插座变量(IBOutlet):是在视图控制器中定义的变量，通过IBOutlet关键字在控制器里面定义之后，在IB(Interface Builder)里面可以体现出来。</p>

<p>B:控制器中定义的动作主要用来响应IB里面设计好的按钮对应的事件，当然，在响应事件之前，需要需要将IB中的控件事件连接到控制器中定义的动作。</p>

<p>C、视图控制器：视图控制器的主要作用如下1）、创建和管理视图；2）、管理视图上显示的数据；3）、设备方向变化、调整视图大小以适应屏幕；4）、负责视图和模型之间的数据传递</p>

<p>在debug代码的时候遇到一个问题，就是界面上的按钮按下去了，但是写好的动作代码没有执行。得出的结论是：IB和XCode之间没有做好相关的关联（有时候会忘记了进行关联，相信熟能生巧！）</p>

<p><code>2011年8月18日</code>：今天主要学习了iPhone开发中的两项内容，键盘的输入和屏幕旋转。</p>

<p>1、键盘输入：在iPhone中，用户数据的输入主要是通过触摸键盘。由于在iPhone上的应用程序受到屏幕大小的限制，有时候当输入面板弹出来的时候，会将文本控件遮挡，这时候就需要对程序进行调整。首先是通过观察键盘的状态（显示\隐藏），然后对UI重新进行布局。观察键盘状态的时候，用到了iOS里面提供的NSNotificationCenter,它的原理就是观察者模式，提供了注册、通知、删除事件三个重要功能，当键盘状态发生改变了，就是通过它告诉我们的，然后我们在根据具体情况进行UI调整。实际上，NSNotificationCenter在iOS里面用得比较多，比如说网络状况的、打电话的状态等一些系统属性都会在这里获得。</p>

<p>键盘状态的监听关键代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span>
</span><span class='line'>         <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class='line'>         <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">keyboardWillShow:</span><span class="p">)</span>
</span><span class='line'>         <span class="nl">name:</span><span class="n">UIKeyboardWillShowNotification</span>
</span><span class='line'>         <span class="nl">object:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">window</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span>
</span><span class='line'>         <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class='line'>         <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">keyboardWillHide:</span><span class="p">)</span>
</span><span class='line'>         <span class="nl">name:</span><span class="n">UIKeyboardWillHideNotification</span>
</span><span class='line'>         <span class="nl">object:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>2、屏幕旋转：在iPhone手机上，可能会面对不同方向屏幕上显示的UI要保持一致性。在此，我们需要知道屏幕何时方向改变了，然后对UI进行调整。</p>

<p><code>一周学习总结</code>：通过这一周的iPhone开发学习，给我的感觉是在iPhone上做应用比较方便快捷，特别是做UI设计的时候，SDK提供了良好的环境（IB），让我在入门的阶段也能够感觉到乐趣。这不得不抱怨一下Symbian了，开发入门门槛高，UI界面开发忒不友好，程序调试让人奔溃。</p>

<p><code>下周计划</code>：</p>

<ol>
<li>系统的学习obj-c语言。obj-c语言是iOS中推荐使用的开发语言。</li>
<li>学习iOS中的视图控制器、页签栏控制器、导航控制器等，以便能构建出不同类型的应用程序。</li>
<li>学习表视图的使用，SQLite3数据库的了解，文件的读写等。</li>
</ol>


<h3>第二周</h3>

<p><code>2011年8月22日</code>：今天主要学习了Objective-C 里面的如下内容（协议和分类还没有详细的学习）：</p>

<ol>
<li>类和对象（类的定义、继承、实例化、类内存的释放）。类的定义与C++等面向对象语言定义类似，都是先声明，然后实现。不过Objective-C只支持单继承，这跟C++有区别。类的扩展可以通过继承、分类和协议来进行。</li>
<li>消息。在Objective-C里面，想让对象完成某个处理时，需要给对象发送一条消息，这类似与C++里面的函数调用，但是与之有很大的区别，函数通常是静态绑定的，在编译程序的时候函数所执行的代码已经确定（多态除外）。而消息则是在执行时才确定的。</li>
<li>内存管理。通过引用计数和自动释放池来对内存进行管理。</li>
<li>类对象。在Objective-C中类自身就是对象，经常用来实例化一个对象，如下面的消息使用（类作为消息的接受者）：[Class alloc];</li>
</ol>


<p>Objective-C在C的基础上，实现了面向对象。其比较大的特点有：内存管理使用引用技术、自动释放池和运行时确定消息执行者、协议、分类等。</p>

<p><code>2011年8月23日</code>：今天主要学习了Objective-C的如下内容：</p>

<pre><code> 分类、协议、属性和页签栏视图使用学习
</code></pre>

<ol>
<li>分类：当我们想给某个类加一些方法时，如果不想通过继承这个类来实现，可以通过分类给这个类加一些行为，这个过程与继承相比更加轻量化。下面的代码演示了如何进行分类：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">NSString</span> <span class="nl">(SubClass)</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">DoSomething</span><span class="p">();</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">NSString</span> <span class="nl">(SubClass)</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">DoSomething</span><span class="p">(){</span>
</span><span class='line'><span class="c1">// do something...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，第一行，SubClass为分类名字，NSString为需要增加行为的类。分类的实现与一般类的实现类似。</p>

<ol>
<li>协议：协议是一组预定义的行为方法，这类似于java中的接口。协议分为正式协议和非正式协议，前者为采用该协议的类必须实现它定义的方法，后者为可选。协议的定义如下代码所示：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@protocol</span> <span class="nc">HandleEvent</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">HandleKeyUpEvent</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">HandleKeyDownEvent</span> <span class="o">:</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="n">sender</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>属性：属性的作用是用来访问对象的实例变量。使用方法是在头文件(.h)中用@property来声明一个属性，然后在实现文件(.m)中用@synthesize来告诉编译器自动生成某个变量的访问器方法。如下：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">retain</span><span class="p">)</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@synthesize</span> <span class="n">name</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>页签栏视图使用：使用sdk提供的Tab Bar Application模板来创建页签栏视图，然后可以通过自己加入页签栏项目（TarBarItem控件）。</li>
</ol>


<p><code>2011年8月24日</code>：今天主要学习了基于导航栏视图的应用程序开发和对学习iOS中的视图控制器进行了一个回顾</p>

<ol>
<li>基于导航栏视图的应用程序开发。页签栏应用程序适用于包含多个视图，用户可以在不同的视图间进行快速切换，这些视图涉及到的数据迁移关系不强。如果我们遇到的数据具有层次关系，比如：邮件列表视图和邮件详细信息视图两个画面具有紧密的逻辑关系【选择邮件列表中的某邮件，进入到邮件详细信息】，此时使用基于导航的视图应用程序是最好的选择。</li>
</ol>


<p>在导航应用程序中，使用的是UINavigationController特殊视图控制器，这方便管理层次内容的导航。</p>

<ol>
<li>iOS中视图控制器学习回顾。iOS中的视图控制器主要作用是创建和管理视图，负责视图和模型中数据的交互和响应视图中的交互事件。UIViewController是iOS里面的视图控制器基本类型，还有UINavigationController和UITabBarController等集合控制器类型的视图控制器。</li>
</ol>


<p><code>2011年8月25日</code>：今天主要学习了如下内容：表视图(UITableView)sqlite数据库的使用</p>

<ol>
<li><p>表视图(UITableView)的使用：表视图一般用在基于导航视图控制器应用中，在UIKit框架中，表视图以行的形式展现UI，其中每一行我们可以对其进行个性化，比如添加图标之类的。在我们的程序中也会经常用到表视图，在使用表视图的时候我们要注意两个概念：1）表视图的数据源(UITableViewDataSource)，主要是为表视图提供数据的一个协议。2）表视图代理(UITableViewDelegate)，主要用来处理表视图的一些事件，并对表视图进行一些编辑和删除操作。</p></li>
<li><p>iPhone中sqlite数据库的使用。sqlite支持在iPhone中使用。sqlite是一款轻型的数据库，主要运用在嵌入式设备中，在使用中，不需要对其进行配置和管理配置，并且可以支持到2TB大的数据文件。不仅支持常用的sql语句：增删改查，还有其它一些丰富的功能：事物等。
 在iPhone中使用sqlite数据库与在其它平台中使用sqlite数据库基本不需要变化多少。这也方便在不同平台间进行复用。
 基本使用步骤：创建数据库，创建表，插入数据，查询数据。
 打开数据库代码：
通过调用sqlite3_open函数，打开一个已经存在的数据库，如果不存在，则创建它。如下代码所示：</p></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="nf">openDB</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">sqlite3_open</span><span class="p">([[</span><span class="n">self</span> <span class="n">filePath</span><span class="p">]</span> <span class="n">UTF8String</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">db</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SQLITE_OK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">sqlite3_close</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>
</span><span class='line'>                <span class="n">NSAssert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">@&quot;Database failed to open.&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建表和插入表：组合出了sql语句，然后执行sqlite提供的方法sqlite3_exec即可。如果过程中出现错误，sqlite3_exec方法也会有错误反馈。
查询内容：先组合一个查询语句，例如：@&ldquo;SELECT * FROM TABLENAME&#8221;，然后实例化一个sqlite3_stmt对象，查询出来的数据放在这里面，再通过调用sqlite3_prepare_v2，和sqlite3_step两个方法对数据进行查询，查询出来的内容还需要sqlite3_column_text方法进行内容的提取。</p>

<p><a href="http://www.sqlite.org/">sqlite</a> 这是sqlite的官方网站，相关的内容，我们在使用过程中，可以在这里进行查阅。</p>

<p><code>2011年8月26日</code>：今天主要学习了如下内容：iOS中文件的使用。
iOS提供了如下方法来进行文件的读写和管理</p>

<ol>
<li>Foundation 框架：</li>
</ol>


<p>1)如果应用程序的数据表现形式为属性列表（property list），则可以使用NSPopertyListSerializaitonAPI把属性列表转换为NSData对象，然后可以使用NSData类提供的方法把数据写到磁盘中。</p>

<p>2) Foundation 框架提供了NSFileHandle类进行文件的存取操作，也提供了NSFileManager类在文件系统里面进行文件的创建和操作(删除，重命名等)。</p>

<ol>
<li>Core OS：
1)支持C语言的接口对文件进行操作：fopen、fread和fwrite（需要import头文件：stdio.h）
2)支持mmap和munmap，以高效的load大容量文件到内存中，以进行内容的存取。(需要import头文件：mman.h)。</li>
</ol>


<p>下面是一些文件访存的原则，我们在创建文件或者把数据写入到文件中时，最好遵循下面的原则：
写入disk中的数据量最小化。文件的操作相对来说慢，并且是写到Flash disk中，Flash disk的寿命是有限（可擦写约1000000次）的。一些具体的细节有利于我们最小化对文件相关的操作：</p>

<p>1)只写文件修改过的那一部分。避免把只修改了几个字节的文件全部进行写操作。</p>

<p>2)当定义文件内容格式时，把需要平凡修改的内容进行分组，从而在每一次进行disk写操作时，最小化需要写入到disk中的块数。</p>

<p>3)如果是结构化内容组成的数据进行随机存取，则存储在SQLite数据库中。特别是，当处理的数据可能会增长到几百M时，这非常重要。</p>

<p>避免把缓存文件写到disk中。此规则的唯一例外是，当应用程序退出，下次再启动时，需要上次退出时的程序状态，则可以把程序退出时的状态进行存储。</p>

<p><code>基于iPhone OS-based设备的文件系统是区分大小写的，这有别于xp系统，无论什么时候，只要是在进行文件名的编码时，必须确保大小写的精确匹配，否则代码不能打开或访问文件。</code></p>

<p><code>一周学习总结</code></p>

<p>本周主要学习了如下内容：</p>

<ol>
<li>Objective-C语言学习，对iOS中开发使用的语言进行了全面的学习，了解了其中的基本使用。</li>
<li>页签栏视图控制器、导航栏视图控制器和表视图的使用，视图控制器在iOS应用中，起到非常重要的作用，是与UI进行衔接的重要部件。</li>
<li>iOS中sqlite的使用，文件的操作。在iOS中，我们可以使用sqlite进行数据的存取，iOS也提供了对文件的操作。</li>
<li>iPhone应用程序的首选项，在iOS中，我们可以把应用程序的一些配置数据存储在首选项中，通过首选项，进行配置。 通过本周的学习，对iOS开发有了进一步的掌握。</li>
</ol>


<p><code>下周学习计划</code></p>

<ol>
<li>学习iOS中的网络开发、多线程、事件处理和媒体（图像&amp;声音），进一步学习iOS中的UI</li>
<li>开发一个iOS Demo</li>
</ol>


<h3>第三周</h3>

<p>没有第三周啦！！！
上周计划iOS中的网络开发、多线程、事件处理和媒体（图像&amp;声音）就在后续的日子里面学习吧。</p>

<h3>总结</h3>

<p>iOS开发的学习我感觉还是比较容易上手的，由于开发环境的限制，对于初学者来说最大的困难可能在于设备，不过相信想要学习该平台的人来说，初期的投入还是值得的。还记得毕业那会刚参加工作就学习Symbian开发，Symbian虽然有3个大分支：诺基亚支持的S60，索爱的UIQ和DoCoMo的MOAP，它们都由全球的通信巨头掌控着，但是Symbian对于初学者太难以入门了，这无疑将许多开发者挡在大门之外。当时一个HelloWorld例子就足足让我啃上一个月。紧接着二阶段构造、活动对象、调度器等都是让人头晕目眩的东西。其实心里对Symbian一直恋恋不忘，这不又多说了几句，哎！大浪淘沙！</p>

<p>下一篇文章我将介绍第三周和第四周做的事情：我写的第一个iOS Demo。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中消息的传递机制]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/12/14/124-communication-patterns/"/>
    <updated>2013-12-14T23:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/12/14/124-communication-patterns</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/12/1.png" alt="" /></p>

<!--more-->


<p>注1：本文由破船译自<a href="http://www.objc.io/issue-7/communication-patterns.html">Communication Patterns</a>。</p>

<p>本文目录如下所示：</p>

<ol>
<li><a href="#1">可用的机制</a></li>
<li><a href="#2">做出正确的选择</a></li>
<li><a href="#3">Framework示例</a></li>
<li><a href="#4">小结</a></li>
</ol>


<p>  每个应用程序或多或少，都由一些松耦合的对象构成，这些对象彼此之间要想很好的完成任务，就需要进行消息传递。本文将介绍所有可用的消息传递机制，并通过示例来介绍这些机制在苹果的Framework中如何使用，同时，还介绍了一些最佳实践建议，告诉你什么时机该选择使用什么机制。</p>

<p>  虽然这一期的主题是关于Foundation Framework的，不过本文中还介绍了一些超出Foundation Framework(KVO和Notification)范围的一些消息传递机制，另外还介绍了delegation，block和target-action。</p>

<p>  大多数情况下，消息传递该使用什么机制，是很明确的了，当然了，在某些情况下该使用什么机制并没有明确的答案，需要你亲自去尝试一下。</p>

<p>  本文中，会经常提及<code>接收者[recipient]</code>和<code>发送者[sender]</code>。在消息传递机制中具体是什么意思，我们可以通过一个示例来解释：一个table view是发送者，而它的delegate就是接收者。Core Data managed object context是notification的发送者，而获取这些notification的主体则是接收者。一个滑块(slider)是action消息的发送者，而在代码里面对应着实现这个action的responder就是接收者。对象中的某个属性支持KVO，那么谁修改这个值，谁就是发送者，对应的观察者(observer)则是接收者。</p>

<h3><a id="1"></a>可用的机制</h3>

<p>首先我们来看看每种机制的具体特点。在下一节中，我会结合一个流程图来介绍如何在具体情况下，选择正确的消息传递机制。最后，将介绍一些来自苹果Framework中的示例，并会解释在某种确定情况下为什么要选择固定的机制。</p>

<h4>KVO</h4>

<p>KVO提供了这样一种机制：当对象中的某个属性值发生了改变，可以对这些值的观察者做出通知。KVO的实现包含在Foundation里面，基于Foundation构建的许多Framework对KVO都有所依赖。要想了解更多关于如何使用KVO，可以阅读本期由Daniel写的的<a href="http://www.objc.io/issue-7/key-value-coding-and-observing.html">KVO和KVC</a>文章。</p>

<p>如果对某个对象中值的改变情况感兴趣，那么可以使用KVO消息传递机制。这里有两个要求，首先，接收者(会接收到值发生改变的消息)必须知道发送者(值将发生改变的那个对象)。另外，接收者同样还需要知道发送者的生命周期，因为在销毁发送者对象之前，需要取消观察者的注册。如果这两个要求都满足了，消息传递过程中可以是1对多(多个观察者可以注册某个对象中的值)。</p>

<p>如果计划在Core Data对象上使用KVO，需要知道这跟一般的KVO使用方法有点不同。那就是必须结合Core Data的故障机制(faulting mechanism)，一旦core data出现了故障，它将会触发其属性对应的观察者(即使这些属性值没有发生改变)。</p>

<h4>Notification</h4>

<p>在不相关的两部分代码中要想进行消息传递，通知(notifacation)是非常好的一种机制，它可以对消息进行广播。特别是想要传递丰富的信息，并且不一定指望有谁对此消息关心。</p>

<p>通知可以用来发送任意的消息，甚至包含一个userInfo字典，或者是NSNotifacation的一个子类。通知的独特之处就在于发送者和接收者双方并不需要相互知道。这样就可以在非常松耦合的模块间进行消息的传递。记住，这种消息传递机制是单向的，作为接收者是不可以回复消息的。</p>

<h4>delegation</h4>

<p>在苹果的Framework中，delegation模式被广泛的只用着。delegation允许我们定制某个对象的行为，并且可以收到某些确定的事件。为了使用delegation模式，消息的发送者需要知道消息的接收者(delegate)，反过来就不用了。这里的发送者和接收者是比较松耦合的，因为发送者只知道它的delegate是遵循某个特定的协议。</p>

<p>delegate协议可以定义任意的方法，因此你可以准确的定义出你所需要的类型。你可以用函数参数的形式来处理消息内容，delegate还可以通过返回值的形式给发送者做出回应。如果只需要在相对接近的两个模块之间进行消息传递，那么Delegation是一种非常灵活和直接方式。</p>

<p>不过，过渡使用delegation也有一定的风险，如果两个对象的耦合程度比较紧密，相互之间不能独立存在，那么此时就没有必要使用delegate协议了，针对这种情况，对象之间可以知道相互间的类型，进而直接进行消息传递。例如UICollectionViewLayout和NSURLSessionConfiguration。</p>

<h4>block</h4>

<p>Block相对来说，是一种比较新的技术，它首次出现是在OS X 10.6和iOS 4中。一般情况下，block可以满足用delegation实现的消息传递机制。不过这两种机制都有各自的需求和优势。</p>

<p>当不考虑使用block时，一般主要是考虑到block极易引起<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/memorymgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-1000810">retain环</a>。如果发送者需要reatain block，而又不能确保这个引用什么时候被nil，这样就会发生潜在的retain环。</p>

<p>假设我们想要实现一个table view，使用block替代delegate，来当做selection的回调，如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">myTableView</span><span class="p">.</span><span class="n">selectionHandler</span> <span class="o">=</span> <span class="o">^</span><span class="kt">void</span><span class="p">(</span><span class="n">NSIndexPath</span> <span class="o">*</span><span class="n">selectedIndexPath</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// handle selection ...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的问题在于self retain了table view，而table view为了之后能够使用block，进而 retain了block。而table view又不能把这个引用nil掉，因为它不知道什么时候不在需要这个block了。如果我们保证不了可以打破这个retain环，而我们又需要retain发送者，此时block不是好的选择。</p>

<p>NSOperation就可以很好的使用block，因为它能再某个时机打破retain环：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">MyOperation</span> <span class="o">*</span><span class="n">operation</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">operation</span><span class="p">.</span><span class="n">completionBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">finishedOperation</span><span class="p">];</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">queue</span> <span class="nl">addOperation:</span><span class="n">operation</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>乍一看这似乎是一个retain环：self retain了queue，queue retain了operation，而operation retain了completion block，而completion blockretain了self。不过，在这里，将operation添加到queue时，会使operation在某个时机被执行，然后从queue中remove掉（如果没有被执行，就会有大问题了）。一单queue移除了operation之后，retain环就被打破了。</p>

<p>再来一个示例：这里实现了一个视频编码器的类，里面有一个名为<code>encodeWithCompletionHandler:</code>的方法。为了避免出现retain环，我们需要确保编码器这个对象能够在某个时机nil掉其对block的引用。其内部代码如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">Encoder</span> <span class="p">()</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">copy</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">completionHandler</span><span class="p">)();</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">Encoder</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeWithCompletionHandler:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)())</span><span class="nv">handler</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="n">handler</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// do the asynchronous processing...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// This one will be called once the job is done</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">finishedEncoding</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span><span class="p">();</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">completionHandler</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span> <span class="c1">// &lt;- Don&#39;t forget this!</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，一旦编码任务完成，就会调用complietion block，进而把引用nil掉。</p>

<p>如果我们发送的消息属于一次性的(具体到某个方法的调用)，由于这样可以打破潜在的retain环，那么使用block是非常不错的选择。另外，如果为了让代码可读性更强，更有连贯性，那最好是使用block了。根据这个思路，block经常可以用于completion handler、error handler等。</p>

<h4>Target-Action</h4>

<p>Target-Action主要被用于响应用户界面事件时所需要传递的消息中。iOS中的UIControl和Mac中的NSControl/NSCell都支持这种机制。Target-Action在消息的发送者和接收者之间建立了一个非常松散耦合。消息的接收者不知道发送者，甚至消息的发送者不需要预先知道消息的接收者。如果target是nil，action会在<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/Devpedia-CocoaApp/Responder.html">响应链(responder chain)</a>中被传递，知道找到某个能够响应该aciton的对象。在iOS中，每个控件都能关联多个target-action。</p>

<p>基于target-action消息传递的机制有一个局限就是发送的消息不能携带自定义的payload。在Mac的action方法中，接收者总是被放在第一个参数中。而在iOS中，可以选择性的将发送者和和触发action的事件作为参数。除此之外，没有别的办法可以对发送action消息内容做控制。</p>

<h3><a id="2"></a>做出正确的选择</h3>

<p>根据上面讨论的结果，这里我画了一个流程图，来帮助我们何时使用什么消息传递机制做出更好的决定。忠告：流程图中的建议并非最终的答案；可能还有别的选项依然能实现目的。只不过大多数情况下此图可以引导你做出正确的决定。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/2.png" alt="" /></p>

<p>上图中，还有一些细节需要做更近一步的解释：</p>

<p>上图中的有个盒子这样说到：sender is KVO compliant(发送者支持compliant)。这不仅以意味着当值发生改变时，发送者会发送KVO通知，并且观察者还需要知道发送者的生命周期。如果发送者被存储在一个weak属性中，那么发送者有可能被nil掉，进而引起观察者发生leak。</p>

<p>另外底部的一个盒子说到：message is direct response to method call(消息直接在方法的调用代码中响应)。也就是说处理消息的代码跟方法的调用代码处于相同的地方。</p>

<p>最后，在左下角，处于一个决策问题的判断状态：sender can guarantee to nil out reference to block?(发送者能够确保nil掉到block的引用吗？)，这实际上涉及到之前我们讨论到基于block 的APIs已经潜在的retain环。使用block时，如果发送者不能保证在某个实际能够把对block的引用nil掉，那么将会遇到retain环的问题。</p>

<h3><a id="3"></a>Framework示例</h3>

<p>本节我们通过一些来自苹果Framework的示例，来看看在实际使用某种机制之前，苹果是处于何种原因做出选择的。</p>

<h5>KVO</h5>

<p>NSOperationQueue就是lion给了KVO来观察队列中operation状态属性的改变情况(isFinished, isExecuting, isCancelled)。当状态发生了改变，队列会受到一个KVO通知。为什么operationqueue要是用KVO呢？</p>

<p>消息的接收者(operation queue)明确的知道发送者(opertation)，以及通过retain来控制operation的生命周期。另外，在这种情况下，只需要单向的消息传递机制。当然，如果这样考虑：如果operation queue只关心operation值的改变情况，可能还不足以说服大家使用KVO。但是我们至少可以这样理解：什么机制可以对值的改变进行消息传递呢。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/3.png" alt="" /></p>

<p>当然KVO也不是唯一的选择。我们可以这样设计：operation queue作为operation的delegate，operation会调用类似operationDidFinish: 或 operationDidBeginExecuting: 这样的方法，来将它的state传递给queue。这样一来，就不太方便了，因为operation需要将其state属性保存下来，一遍调用这些delegate方法。另外，由于queue不能主动获取state信息，所以queue也必须保存着所有operation的state。</p>

<h5>Notifications</h5>

<p>Core Data使用notification来传递事件(例如一个managed object context内部的改变——NSManagedObjectContextDidChangeNotification)。</p>

<p>change notification是由managed object context发出的，所以我们不能确定消息的接收者一定知道发送者。如果消息并不是一个UI事件，而有可能多个接收者对该消息感兴趣，并且消息的传递属于单向(one-way communication channel)，那么notification是最佳选择。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/4.png" alt="" /></p>

<h5>Delegation</h5>

<p>Table view的delegate有多种功能，从accessory view的管理，到屏幕中cell显示的跟踪，都与delegate的功劳。例如，我们来看看 tableView:didSelectRowAtIndexPath: 方法。为什么要以delegate调用的方式来实现？而又为啥不用target-action方式？</p>

<p>正如我们在流程图中看到的一样，使用target-action时，不能传递自定义的数据。而在选中table view的某个cell时，collection view不仅仅需要告诉我们有一个cell被选中了，还需要告诉我们是哪个cell被选中了(index path)。按照这样的一种思路，那么从流程图中可以看到应该使用delegation机制。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/5.png" alt="" /></p>

<p>如果消息传递中，不包含选中cell的index path，而是每当选中项改变时，我们主动去table view中获取到选中cell的相关信息，会怎样呢？其实这会非常的麻烦，因为这样一来，我们就必须记住当前选中项相关数据，以便获知被选中的cell。</p>

<p>同理，虽然我们也可以通过观察table view中选中项的index paths属性值，当该值发生改变时，获得一个选中项改变的通知。不过，我们会遇到与上面同样的问题：不做任何记录的话，我们如何获知被选中项的相关信息。</p>

<h5>Blocks</h5>

<p>关于block的介绍，我们来看看[NSURLSession dataTaskWithURL:completionHandler:]吧。从URL loading system返回到调用者，这个过程具体是如何传递消息的呢？首先，作为这个API的调用者，我们知道消息的发送者，但是我们并没有retain这个发送者。另外，这属于单向消息传递——直接调用dataTaskWithURL:方法。如果按照这样的思路对照着流程图，我们会发现应该使用基于block消息传递的机制。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/6.png" alt="" /></p>

<p>还有其它可选的机制吗？当然有了，苹果自己的NSURLConnection就是最好的例子。NSURLConnection在block问世之前就已经存在了，所以它并没有利用block进行消息传递，而是使用delegation机制。当block出现之后，苹果在NSURLConnection中添加了sendAsynchronousRequest:queue:completionHandler:方法(OSX 10.7 iOS 5)，因此如果是简单的task，就不必在使用delegate了。</p>

<p> 在OS X 10.9 和 iOS 7中，苹果引入了一个非常modern的API：NSURLSession，其中使用block当做消息传递机制(NSURLSession仍然有一个delegate，不过是用于别的目的)。</p>

<h5>Target-Action</h5>

<p>Target-Action用的最明显的一个地方就是button(按钮)。button除了需要发送一个click事件以外，并不需要再发送别的信息了。所以Target-Action在用户界面事件传递过程中，是最佳的选择。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/12/7.png" alt="" /></p>

<p>如果taget已经明确指定了，那么action消息回直接发送给指定的对象。如果taget是nil，action消息会以冒泡的方式在响应链中查找一个能够处理该消息的对象。此时，我们拥有一种完全解耦的消息传递机制——发送者不需要知道接收者，以及其它一些信息。</p>

<p>Target-Action非常适用于用户界面中的事件。目前也没有其它合适的消息传递机制能够提供同样的功能。虽然notification最接近这种在发送者和接收者解耦关系，但是target-action可以用于响应链(responder chain)——只有一个对象获得action并作出响应，并且action可以在响应链中传递，直到遇到能够响应该action的对象。</p>

<h3><a id="4"></a>小结</h3>

<p>首次接触这些机制，感觉它们都能用于两个对象间的消息传递。但是仔细琢磨一番，会发现它们各自有其需求和功能。</p>

<p>文中给出的决策流程图可以为我们选择使用何种机制提供参考，不过图中给出的方案并不是最终答案，好多地方还需要亲自去实践。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS探索：iOS程序的Build过程]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/21/123-build-process/"/>
    <updated>2013-11-21T22:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/21/123-build-process</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/11/45.png" alt="" /></p>

<!--more-->


<p>注1：本文由破船译自<a href="http://www.objc.io/issue-6/build-process.html">The Build Process</a>。</p>

<p>注2：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>本文将轻度解密Xcode build日志，还原iOS程序build的过程。
</span><span class='line'>另外将介绍如何对build过程的控制，进而定制出自己希望的流程，
</span><span class='line'>例如通过Build phase的定制，给app icon打水印(包括版本号和日期)。
</span><span class='line'>
</span><span class='line'>通过对工程文件的解读，为你揭开工程文件(.pbxproj)与
</span><span class='line'>build settings的关系。这对于解决工程文件的merge冲突非常有帮助。
</span><span class='line'>
</span><span class='line'>PS：实际上各开发平台的build过程都比较相似，如果你熟悉了
</span><span class='line'>某个平台的build过程，那么同样的原理也适用于别的平台。
</span><span class='line'>可以说换汤不换药，本质是一样的。</span></code></pre></td></tr></table></div></figure>


<p>下面开始吧：</p>

<p>本文目录如下所示：</p>

<ol>
<li><a href="#1">解密Build日志</a></li>
<li><a href="#2">Build过程的控制</a></li>
<li><a href="#3">工程文件</a></li>
<li><a href="#4">小结</a></li>
</ol>


<p>当我们进行开发时，如果需要运行程序，只要在Xcode中点击运行按钮(这个按钮看起来有点像在播放音乐)，过一会，我们的程序就会运行在设备或者模拟器上了，看似简单的操作过程，不过在这背后隐藏了许多步骤！当然，有时候也会遇到一些错误。</p>

<p>本文，我将从稍微高一点的角度来解读整个Build过程，并探索一下Build过程与Xcode界面上显示的project setting有多大关系。当然，为了更加深入的了解每一步实际执行的任务，我会适当的引入一些别的文章。</p>

<h3><a id="1"></a>解密Build日志</h3>

<p>为了了解Xcode build过程的内部工作原理，我们首先把突破点放在完整的log文件上。打开<code>Log Navigator</code>，从列表中选择一个Build，Xcode就会通过很漂亮的一种格式将log文件显示出来。如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/41.png" alt="" /></p>

<p>默认情况下，XCode会把大量的log信息隐藏起来，你只需要点击选中某条log，然后点击右边的展开按钮，就能看到该条log的详细信息了。当然，你也可以选中一条或者多条日志，然后通过Cmd+C，就能将相关的所有文本信息拷贝到粘贴板上。另外，还可以通过菜单Editor中的<code>Copy transcript for shown results</code>将所有的log信息复制到粘贴板上。</p>

<p>在我这儿的示例中，将近有10000行log信息(当然，大多数信息是由OpenSSL带来的，并非来自我们的代码)。下面我们就开始吧！</p>

<p>首先，你可能会发现输出的log信息，被工程中对应的target分割开了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">Makefile</span><span class="o">-</span><span class="n">openssl</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">Pods</span><span class="o">-</span><span class="n">AFNetworking</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">crypto</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">Pods</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">ssl</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">Build</span> <span class="n">target</span> <span class="n">objcio</span>
</span></code></pre></td></tr></table></div></figure>


<p>在我这的工程中有好几个依赖项：如包含在Pods中的AFNetworking 和 SSZipArchive, 已经以子工程形式存在的OpenSSL等。</p>

<p>针对这里的每个target，Xcode都会执行一些列的操作，以将相关的源代码转换为机器可读的二进制(于所选平台相关)。我们来亲密接触一下第一个targetSSZipArchive吧。</p>

<p>在这个target的log输出中，我们可以看到每个任务执行的详细情况。例如，第一个是处理一个预编译头文件(为了增加其可读性，我省略了许多细节)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="n">ProcessPCH</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span><span class="p">.</span><span class="n">pch</span> <span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span> <span class="n">normal</span> <span class="n">armv7</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span> <span class="n">com</span><span class="p">.</span><span class="n">apple</span><span class="p">.</span><span class="n">compilers</span><span class="p">.</span><span class="n">llvm</span><span class="p">.</span><span class="n">clang</span><span class="mf">.1</span><span class="n">_0</span><span class="p">.</span><span class="n">compiler</span>
</span><span class='line'>    <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="n">cd</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Dev</span><span class="o">/</span><span class="n">objcio</span><span class="o">/</span><span class="n">Pods</span>
</span><span class='line'>        <span class="n">setenv</span> <span class="n">LANG</span> <span class="n">en_US</span><span class="p">.</span><span class="n">US</span><span class="o">-</span><span class="n">ASCII</span>
</span><span class='line'>        <span class="n">setenv</span> <span class="n">PATH</span> <span class="s">&quot;...&quot;</span>
</span><span class='line'>    <span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Xcode</span><span class="p">.</span><span class="n">app</span><span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">clang</span>
</span><span class='line'>            <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">-</span><span class="n">x</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span><span class="o">-</span><span class="n">header</span>
</span><span class='line'>            <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span><span class="n">arch</span> <span class="n">armv7</span>
</span><span class='line'>            <span class="p">...</span> <span class="n">configuration</span> <span class="n">and</span> <span class="n">warning</span> <span class="n">flags</span> <span class="p">...</span>
</span><span class='line'>            <span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">-</span><span class="n">DDEBUG</span><span class="o">=</span><span class="mi">1</span> <span class="o">-</span><span class="n">DCOCOAPODS</span><span class="o">=</span><span class="mi">1</span>
</span><span class='line'>            <span class="p">...</span> <span class="n">include</span> <span class="n">paths</span> <span class="n">and</span> <span class="n">more</span> <span class="p">...</span>
</span><span class='line'>            <span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">-</span><span class="n">c</span>
</span><span class='line'>            <span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span>
</span><span class='line'>            <span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span><span class="p">.</span><span class="n">pch</span>
</span></code></pre></td></tr></table></div></figure>


<p>在build过程中，每个任务都会出现类似上面的这些log信息，我们就通过上面的log信息了解详情吧。</p>

<ol>
<li>每个log都会以这样的一行来对任务进行描述。</li>
<li>接着下面带缩进的这3行会被输出。此处，修改了工作路径，并对PANG和PATH环境变量进行设置。</li>
<li>这里才是真正焕发出魔力的地方。为了处理一个<code>.pch</code>文件，调用了clang，并且附带了大量的选项。这行log信息显示出了所有的调用参数，我们稍微看几个参数吧：</li>
<li>-x标示符用来指定语言，此时是<code>objective-c-header</code>。</li>
<li>目标架构指定为<code>armv7</code>。</li>
<li>标示#defines的内容已经被添加了。</li>
<li>-c标示符用来告诉clang具体如何运行。-c意味着：运行预处理器、词法分析、类型检查LLVM的生成和优化，以及特定target相关汇编代码的生成阶段，最后，运行这个汇编代码以生成.o目标文件。</li>
<li>输入文件。</li>
<li>输出文件。</li>
</ol>


<p>虽然有大量的log信息，不过我不会把每个log信息都做详解。我们的目的是让你了解在build过程中，完整的了解什么工具被调用，以及都使用了什么参数。</p>

<p>针对这个target，虽然只有一个.pch文件，但实际上这里对objective-c-header文件处理了两次。下面来看看log信息告诉我们的详细情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ProcessPCH</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span><span class="p">.</span><span class="n">pch</span> <span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span> <span class="n">normal</span> <span class="n">armv7</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span> <span class="p">...</span>
</span><span class='line'><span class="n">ProcessPCH</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span><span class="p">.</span><span class="n">pch</span> <span class="n">Pods</span><span class="o">-</span><span class="n">SSZipArchive</span><span class="o">-</span><span class="n">prefix</span><span class="p">.</span><span class="n">pch</span> <span class="n">normal</span> <span class="n">armv7s</span> <span class="n">objective</span><span class="o">-</span><span class="n">c</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，build了两种target：armv7和armv7s，所以clang为每种架构处理了一次这个文件。</p>

<p>紧接着预编译头文件的处理之后，我们可以找到SSZipArchive target相关的其它一些任务：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CompileC</span> <span class="p">...</span>
</span><span class='line'><span class="n">Libtool</span> <span class="p">...</span>
</span><span class='line'><span class="n">CreateUniversalBinary</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过名称，我们基本能够知道个大概：<code>CompileC</code>用来编译.m和.c文件，<code>Libtool</code>根据目标文件创建出一个库，而<code>CreateUniversalBinary</code>则将上一阶段产生的两个.a文件(对应着两个不同的架构)合并为一个通用的二进制文件(可以运行在armv7和armv7s上)。</p>

<p>上面这些类似的步骤会出现在工程中所有其它的依赖项中。</p>

<p>当所有的依赖项都准备好了，就可以开始构建我们程序的target了。针对该target输出的log信息包含了之前没有出现过的内容，这些内容非常有价值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">PhaseScriptExecution</span> <span class="p">...</span>
</span><span class='line'><span class="n">DataModelVersionCompile</span> <span class="p">...</span>
</span><span class='line'><span class="n">Ld</span> <span class="p">...</span>
</span><span class='line'><span class="n">GenerateDSYMFile</span> <span class="p">...</span>
</span><span class='line'><span class="n">CopyStringsFile</span> <span class="p">...</span>
</span><span class='line'><span class="n">CpResource</span> <span class="p">...</span>
</span><span class='line'><span class="n">CopyPNGFile</span> <span class="p">...</span>
</span><span class='line'><span class="n">CompileAssetCatalog</span> <span class="p">...</span>
</span><span class='line'><span class="n">ProcessInfoPlistFile</span> <span class="p">...</span>
</span><span class='line'><span class="n">ProcessProductPackaging</span> <span class="o">/</span><span class="p">...</span><span class="o">/</span><span class="n">some</span><span class="o">-</span><span class="n">hash</span><span class="p">.</span><span class="n">mobileprovision</span> <span class="p">...</span>
</span><span class='line'><span class="n">ProcessProductPackaging</span> <span class="n">objcio</span><span class="o">/</span><span class="n">objcio</span><span class="p">.</span><span class="n">entitlements</span> <span class="p">...</span>
</span><span class='line'><span class="n">CodeSign</span> <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的任务中，可能Ld不能一眼看出是什么意思，此处它是一个linker工具，跟libtool类似。实际上libtool会简单的调用ld和lipo。而ld用来构建可执行文件。更多编译和链接相关的文章可以看看 <a href="http://www.objc.io/issue-6/mach-o-executables.html">Daniel</a> 和 <a href="http://www.objc.io/issue-6/compiler.html">Chris</a>写的。</p>

<p>上面这些步骤，实际上都会调用相关的命令行工具来做实际的工作，这跟之前我们看的步骤ProcessPCH类似。至此，我将不会继续介绍这些log信息了，我将带来大家从另外一个不同的角度来继续探索这些任务：Xcode是如何知道哪些任务需要被执行？</p>

<h3><a id="2"></a>Build过程的控制</h3>

<p>当你选中在Xcode 5中的一个工程时，project editor会在顶部显示出6个tabs：General, Capabilities, Info, Build Settings, Build Phases 以及 Build Rules。如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/42.png" alt="" /></p>

<p>其中最后3项与build过程的相关度最大。</p>

<h4>Build Phases</h4>

<p>Build Phases代表着将代码构建为一个可执行文件的规则。它描述了build过程中必须执行的不同任务。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/43.png" alt="" /></p>

<p>首先，指定了target的依赖项。这将告诉build系统在当前target可以build之前，必须先build target的依赖项。实际上这并不属于真正的build phase，在这里，Xcode只不过将其与build phase显示到一块罢了。</p>

<p>接着是一个CocoaPods相关的脚本需要在build phase执行——更多CocoaPods相关信息可以查看<a href="http://www.objc.io/issue-6/cocoapods-under-the-hood.html">Michele的文章</a>。</p>

<p>然后在<code>Compile Sources</code>中指定了所有必须进行编译的文件。更多相关内容我们将在build rules和build settings中研究。在<code>Compile Sources</code>中指定的文件将根据这些rule和setting被处理。</p>

<p>当编译结束，下一步就是将所有的内容链接到一块：<code>Link Binary with Libraries</code>。在这里面列出了所有的静态库和动态库，这些库会与上面编译阶段生成的目标文件进行链接。实际上静态库和动态库的处理过程有非常大的区别，相关内容可以参考Daniel的文章 <a href="http://www.objc.io/issue-6/mach-o-executables.html">Mach-O executables</a>。</p>

<p>当链接完成之后，build phase中最后需要处理的就是将静态资源（例如图片和字体）拷贝到app bundle中。需要注意的是，如果图片资源是PNG格式，那么不仅仅对其进行拷贝，还会做一些优化(如果build settings中的PNG优化是打开的)。</p>

<p>虽然静态资源的拷贝是build phase中的最后一步，但这并不代表build过程已经完成了。例如，还没有进行code signing(这并不是build phase考虑的范畴)，code signing属于build步骤中的最后一步<code>Packaging</code>。</p>

<h4>定制Build Phases</h4>

<p>至此，你已经完全可以掌控build phases相关内容(先不考虑默认的设置项)，例如，你可以在build phases中添加运行自定义脚本，就像<a href="http://www.objc.io/issue-6/cocoapods-under-the-hood.html">CocoaPods</a>使用的一样，来做额外的工作。当然也可以添加一些资源的拷贝任务，当你需要将某些确定的资源拷贝到制定的target目录中，这非常有用。</p>

<p>另外你可以通过定制build phase来添加带有水印(包括版本号和commit hash)的app icon。只需要在build phase中添加一个<code>Run Script</code>，然后用下面的命令来获取版本号和commit hash：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">version</span><span class="o">=</span><span class="err">`</span><span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">libexec</span><span class="o">/</span><span class="n">PlistBuddy</span> <span class="o">-</span><span class="n">c</span> <span class="s">&quot;Print CFBundleVersion&quot;</span> <span class="s">&quot;${INFOPLIST_FILE}&quot;</span><span class="err">`</span>
</span><span class='line'><span class="n">commit</span><span class="o">=</span><span class="err">`</span><span class="n">git</span> <span class="n">rev</span><span class="o">-</span><span class="n">parse</span> <span class="o">--</span><span class="kt">short</span> <span class="n">HEAD</span><span class="err">`</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后可以使用ImageMagick来修改app icon。这里有一个<a href="https://github.com/krzysztofzablocki/IconOverlaying">完整的示例</a>，可以参考。</p>

<p>如果你希望编写的代码比较简洁点，那么可以添加一个<code>Run Script</code>，如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为200。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">find</span> <span class="s">&quot;${SRCROOT}&quot;</span> <span class="err">\</span><span class="p">(</span> <span class="o">-</span><span class="n">name</span> <span class="s">&quot;*.h&quot;</span> <span class="o">-</span><span class="n">or</span> <span class="o">-</span><span class="n">name</span> <span class="s">&quot;*.m&quot;</span> <span class="err">\</span><span class="p">)</span> <span class="o">-</span><span class="n">print0</span> <span class="o">|</span> <span class="n">xargs</span> <span class="o">-</span><span class="mi">0</span> <span class="n">wc</span> <span class="o">-</span><span class="n">l</span> <span class="o">|</span> <span class="n">awk</span> <span class="err">&#39;</span><span class="n">$1</span> <span class="o">&gt;</span> <span class="mi">200</span> <span class="o">&amp;&amp;</span> <span class="n">$2</span> <span class="o">!=</span> <span class="s">&quot;total&quot;</span> <span class="p">{</span> <span class="n">print</span> <span class="n">$2</span> <span class="s">&quot;:1: warning: file more than 200 lines&quot;</span> <span class="p">}</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Build Rules</h4>

<p>Build rules指定了不同文件类型该如何编译。一般来说，开发者并不需要修改这里面的内容。如果你需要对特定的文件类型添加处理方法，那么可以在此处天剑一条新的规则。</p>

<p>一条build rule指定了其应用于那种文件类型，该文件类型是如何被处理的，以及输出内容被放置到何处。比方说，我们创建了一条预处理规则，该规则将Objective-C的实现文件当做输入，然后解析文件内部的注释内容，最后再输出一个.m文件，文件中包含了生成的代码。由于我们不能将.m文件既当做输入又当做输出，所以我使用了.mal后缀，定制的build rule如下所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/44.png" alt="" /></p>

<p>上面的规则应用于所有后缀为*.mal的文件，这些文件会被自定义的脚本处理(调用我们的预处理器，并附带上输入和输出参数)。最后，该规则告诉build system在哪里可以找到此规则的输出文件。</p>

<p>由于这里的输出是一个.m文件，那么build使这些.m文件会被编译处理(就如刚开始介绍的那些预处理步骤)。</p>

<p>在脚本中，我使用了少量的变量来指定正确的路径和文件名。在苹果的<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference.</a>文档中可以找到所有可用的变量。build过程中，要想观察所有已存在的环境变量，你可以添加一个<code>Run Script</code> build phase，并勾选上<code>Show environment variables in build log</code>。</p>

<h4>Build Settings</h4>

<p>至此，我们已经了解到build phases是如何被用来定义build 过程的步骤，以及build rules是如何指定哪些文件类型在编译阶段需要被预处理。在build settings中，我们可以配置每个任务(之前在build log输出中看到的任务)的详细内容。</p>

<p>在这里，你会发现build 过程的每一个阶段，都有许多选项：从编译、链接一直到code signing和packaging。注意，settings被分割为不同的部分，大部分会于build phases有关联，有时候也会指定编译的文件类型。</p>

<p>这些选项基本都有不错的文档介绍，你可以在右边面板中的quick help inspector或者 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW105">Build Setting Reference</a>中查看到。</p>

<h3><a id="3"></a>工程文件</h3>

<p>上面我们介绍的所有内容都被保存在工程文件(.pbxproj)中，除了其它一些工程相关信息(例如file groups)，我们很少会深入该文件内部，除非在代码merge时发生冲突，或许会进去看看。</p>

<p>我建议你用文本编辑器打开一个工程文件，从头到尾的看一遍里面的内容。它的可读性非常高，里面的许多内容一看就知道什么意思了，不会存在太大的问题。通过阅读并完全理解工程文件，这对于合并工程文件的冲突非常有帮助。</p>

<p>首先，我们来看看文件中叫做<code>rootObject</code>的entry。在我的工程中，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">rootObject</span> <span class="o">=</span> <span class="mi">1793817</span><span class="n">C17A9421F0078255E</span> <span class="cm">/* Project object */</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据这个ID(1793817C17A9421F0078255E)，我们可以找到main工程的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* Begin PBXProject section */</span>
</span><span class='line'>    <span class="mi">1793817</span><span class="n">C17A9421F0078255E</span> <span class="cm">/* Project object */</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">isa</span> <span class="o">=</span> <span class="n">PBXProject</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这部分section中包含了一些keys，顺从这些key，我们可以了解到更多关于这个工程文件的组成。例如，<code>mainGroup</code>指向了root file group。如果你按照这个思路，你可以快速了解到在.pbxproj文件中工程的结构。下面我要来介绍一些与build过程相关的内容。其中<code>target</code> key指向了build target的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">targets</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>    <span class="mi">1793818317</span><span class="n">A9421F0078255E</span> <span class="cm">/* objcio */</span><span class="p">,</span>
</span><span class='line'>    <span class="mf">170E83</span><span class="n">CE17ABF256006E716E</span> <span class="cm">/* objcio Tests */</span><span class="p">,</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据第一个id，我们找到一个target的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mi">1793818317</span><span class="n">A9421F0078255E</span> <span class="cm">/* objcio */</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">isa</span> <span class="o">=</span> <span class="n">PBXNativeTarget</span><span class="p">;</span>
</span><span class='line'>    <span class="n">buildConfigurationList</span> <span class="o">=</span> <span class="mi">179381</span><span class="n">B617A9421F0078255E</span> <span class="cm">/* Build configuration list for PBXNativeTarget &quot;objcio&quot; */</span><span class="p">;</span>
</span><span class='line'>    <span class="n">buildPhases</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>        <span class="n">F3EB8576A1C24900A8F9CBB6</span> <span class="cm">/* Check Pods Manifest.lock */</span><span class="p">,</span>
</span><span class='line'>        <span class="mi">1793818017</span><span class="n">A9421F0078255E</span> <span class="cm">/* Sources */</span><span class="p">,</span>
</span><span class='line'>        <span class="mi">1793818117</span><span class="n">A9421F0078255E</span> <span class="cm">/* Frameworks */</span><span class="p">,</span>
</span><span class='line'>        <span class="mi">1793818217</span><span class="n">A9421F0078255E</span> <span class="cm">/* Resources */</span><span class="p">,</span>
</span><span class='line'>        <span class="n">FF25BB7F4B7D4F87AC7A4265</span> <span class="cm">/* Copy Pods Resources */</span><span class="p">,</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>    <span class="n">buildRules</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>    <span class="n">dependencies</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>        <span class="mi">1769</span><span class="n">BED917CA8239008B6F5D</span> <span class="cm">/* PBXTargetDependency */</span><span class="p">,</span>
</span><span class='line'>        <span class="mi">1769</span><span class="n">BED717CA8236008B6F5D</span> <span class="cm">/* PBXTargetDependency */</span><span class="p">,</span>
</span><span class='line'>    <span class="p">);</span>
</span><span class='line'>    <span class="n">name</span> <span class="o">=</span> <span class="n">objcio</span><span class="p">;</span>
</span><span class='line'>    <span class="n">productName</span> <span class="o">=</span> <span class="n">objcio</span><span class="p">;</span>
</span><span class='line'>    <span class="n">productReference</span> <span class="o">=</span> <span class="mi">1793818417</span><span class="n">A9421F0078255E</span> <span class="cm">/* objcio.app */</span><span class="p">;</span>
</span><span class='line'>    <span class="n">productType</span> <span class="o">=</span> <span class="s">&quot;com.apple.product-type.application&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>buildConfigurationList</code>指向了可用的配置项，一般包括<code>Debug</code>和<code>Release</code>。根据debug对应的id，我们可以找到build setting tab中所有选项存储的位置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mi">179381</span><span class="n">B717A9421F0078255E</span> <span class="cm">/* Debug */</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">isa</span> <span class="o">=</span> <span class="n">XCBuildConfiguration</span><span class="p">;</span>
</span><span class='line'>    <span class="n">baseConfigurationReference</span> <span class="o">=</span> <span class="mo">05</span><span class="n">D234D6F5E146E9937E8997</span> <span class="cm">/* Pods.xcconfig */</span><span class="p">;</span>
</span><span class='line'>    <span class="n">buildSettings</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ALWAYS_SEARCH_USER_PATHS</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME</span> <span class="o">=</span> <span class="n">LaunchImage</span><span class="p">;</span>
</span><span class='line'>        <span class="n">CODE_SIGN_ENTITLEMENTS</span> <span class="o">=</span> <span class="n">objcio</span><span class="o">/</span><span class="n">objcio</span><span class="p">.</span><span class="n">entitlements</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>而<code>buildPhases</code>属性则简单的列出了在Xcode中定义的所有build phases。这非常容易识别出来(Xcode中的参数使用了它们原本真正的名字，并以C风格进行注释)。</p>

<p><code>buildRules</code>属性是空的：因为在该工程中，我没有自定义build rules。</p>

<p><code>dependencies</code>列出了在Xcode build phase tab中列出的target依赖项。</p>

<p>没那么吓人，不是吗？工程中剩下的内容就留给你去当做练习来了解吧。只需要顺着ID走，即可，一旦你找到了敲门，理解了Xcode中工程设置的不同section，那么对于merge工程文件的冲突时，将变得非常简单。甚至可以在GitHub中就能阅读工程文件，而不用将工程文件clone到本地，并用Xcode打开。</p>

<h3><a id="4"></a>小结</h3>

<p>当今的软件是都用其它复杂的一些软件和资源开发出来的，例如library和build工具等。反过来，这些工具是构建于底层架构的，这犹如剥洋葱一样，一层包着一层。虽然这样一层一层的，给人感觉太复杂，但是你完全可以去深入了解它们，这非常有助于你对软件的深入理解，实际上当你了解之后，这并没有想象中的那么神奇，只不过它是一层一层堆砌起来的，每一层都是基于下一层构建起来的。</p>

<p>在这里，我们只是轻微的探究了一下build过程，当我们点击Xcode中的允许按钮时，并没必要深入了解内部具体发生了什么。只需要了解到build的过程，以及可控的一些操作顺序即可。当然，要想进一步深入了解，可以试着阅读其它一些文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7 教程：让程序同时支持iOS 6和iOS 7]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/19/122-working-with-ios-6-and-7/"/>
    <updated>2013-11-19T22:18:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/19/122-working-with-ios-6-and-7</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/11/35.png" alt="" /></p>

<!--more-->


<p>注：本文由破船译自<a href="http://blog.ittybittyapps.com/blog/2013/11/08/working-with-ios-6-and-7/">Itty Bitty Labs</a>。</p>

<ol>
<li><a href="#1">iOS 7中的布局问题</a></li>
<li><a href="#2">iOS 6运行异常</a></li>
<li><a href="#3">Xcode 4编译错误</a></li>
<li><a href="#4">UILabel不一致的background</a></li>
<li><a href="#5">全屏时隐藏状态栏</a></li>
<li><a href="#6">UIToolbar barStyle</a></li>
<li><a href="#7">更多</a></li>
</ol>


<p>由于各种原因，我们的程序需要同时支持iOS 7以及之前的版本(例如iOS 6)，也就是说开发者不得不同时在iOS 7和iOS 6之间进行开发。实际上开发者对此是比较讨厌的。</p>

<h3><a id="1"></a>iOS 7中的布局问题</h3>

<p>下面是非常简单的一个程序，运行在iOS 6中的界面：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/36.png" alt="" /></p>

<p>而要是运行在iOS 7的模拟器中，会看不到label了：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/37.png" alt="" /></p>

<p>这是为什么呢？我们对其reveal一下看看吧：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/38.png" alt="" /></p>

<p>从上图可以看出，实际上label躲在NavigationBar后面了。在iOS 7中，苹果引入了一个新的属性，叫做<code>[UIViewController setEdgesForExtendedLayout:]</code>，它的默认值为<code>UIRectEdgeAll</code>。当你的容器是navigation controller时，默认的布局将从navigation bar的顶部开始。这就是为什么所有的UI元素都往上漂移了44pt。</p>

<p>修复这个问题的快速方法就是在方法<code>- (void)viewDidLoad</code>中添加如下一行代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">edgesForExtendedLayout</span> <span class="o">=</span> <span class="n">UIRectEdgeNone</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样问题就修复了。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/39.png" alt="" /></p>

<h3><a id="2"></a>iOS 6运行异常</h3>

<p>现在如果在iOS 6中运行程序，会遇到下面这样的运行时异常错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">LAViewController</span> <span class="nl">setEdgesForExtendedLayout:</span><span class="p">]</span><span class="o">:</span> <span class="n">unrecognized</span> <span class="n">selector</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">instance</span> <span class="mh">0x778a210</span>
</span></code></pre></td></tr></table></div></figure>


<p>所有只能在iOS 7中运行的API需要重新封装一下，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">self</span> <span class="nl">respondsToSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">setEdgesForExtendedLayout:</span><span class="p">)])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">edgesForExtendedLayout</span> <span class="o">=</span> <span class="n">UIRectEdgeNone</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="3"></a>Xcode 4编译错误</h3>

<p>有些机器可能还在使用Xcode 4.6，当用4.6来编译代码时，会遇到下面的编译错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Property</span> <span class="err">&#39;</span><span class="n">edgesForExtendedLayout</span><span class="err">&#39;</span> <span class="n">not</span> <span class="n">found</span> <span class="n">on</span> <span class="n">object</span> <span class="n">of</span> <span class="n">type</span> <span class="err">&#39;</span><span class="n">LAViewController</span> <span class="o">*</span><span class="err">&#39;</span>
</span><span class='line'><span class="n">Use</span> <span class="n">of</span> <span class="n">undeclared</span> <span class="n">identifier</span> <span class="err">&#39;</span><span class="n">UIRectEdgeNone</span><span class="err">&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了避免这个错误，可以创建下面的这个宏：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span>
</span><span class='line'><span class="cp">#define IOS7_SDK_AVAILABLE 1</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在需要的地方将iOS 7的代码包装一下即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#ifdef IOS7_SDK_AVAILABLE</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="4"></a>UILabel不一致的background</h3>

<p>对于UILabel，在iOS 7中它的background颜色默认是clearColor，而在iOS 6中默认的是白色。所以，我们最好在代码中对label的background颜色进行明确的设置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">view</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">clearColor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="5"></a>全屏时隐藏状态栏</h3>

<p>在iOS 6中，当调用<code>presentViewController</code>时，默认的modal screen将是全屏(<code>UIModalPresentationFullScreen</code>)。为了在iOS 7中也能获得相同的效果，我们可以在modal controller中添加如下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">prefersStatusBarHidden</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="6"></a>UIToolbar barStyle</h3>

<p>有时候，我们会将UIToolbar与系统键盘结合起来使用。而在iOS 6中的键盘是黝黑色的，此时toolbar的style一般也是类似的，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">barStyle</span> <span class="o">=</span> <span class="n">UIBarStyleBlack</span><span class="p">;</span><span class="c1">// or UIBarStyleBlackTranslucents</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在iOS 7中，键盘变为了亮色，因此我们需要根据不同的iOS 版本，设置不同的bar style。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">([[[</span><span class="n">UIDevice</span> <span class="n">currentDevice</span><span class="p">]</span> <span class="n">systemVersion</span><span class="p">]</span> <span class="nl">compare:</span><span class="s">@&quot;7.0&quot;</span> <span class="nl">options:</span><span class="n">NSNumericSearch</span><span class="p">]</span> <span class="o">!=</span> <span class="n">NSOrderedAscending</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">barStyle</span> <span class="o">=</span> <span class="n">UIBarStyleDefault</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">barStyle</span> <span class="o">=</span> <span class="n">UIBarStyleBlack</span><span class="p">;</span><span class="c1">//or UIBarStyleBlackTranslucent</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="7"></a>更多</h3>

<p>上面这些技巧是我目前在开发中遇到的，肯定还有更多的技巧，大家要是知道的话可以告诉我。</p>

<p>最后送大家一个图，看看相关差异吧：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/40.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7 教程：浅析Text Kit]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/12/121-brief-analysis-text-kit/"/>
    <updated>2013-11-12T12:55:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/12/121-brief-analysis-text-kit</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/11/22.png" alt="" /></p>

<!--more-->


<p>注：本文由破船原创，并投稿至<a href="http://tiny4cocoa.com/thread/show/57/">Tiny4Cocoa iOS开发杂志</a>。</p>

<p>Text Kit是iOS 7中引入的一个新功能，非常值得开发者使用，下面先看看本文的目录结构：</p>

<ol>
<li><a href="#1">什么是Text Kit</a></li>
<li><a href="#2">Text Kit架构</a></li>
<li><a href="#3">Text Kit特点</a></li>
<li><a href="#4">Text Kit功能概述</a></li>
<li><a href="#5">Text Kit中重要的一些对象</a></li>
<li><a href="#6">Text Kit示例</a></li>
<li><a href="#7">小结</a></li>
<li><a href="#8">推荐Text Kit学习资源</a></li>
</ol>


<h3><a id="1"></a>什么是Text Kit</h3>

<p>在iOS7中，苹果引入了<code>Text Kit</code>——Text Kit是一个快速而又现代化的文字排版和渲染引擎。Text Kit在UIKit framework中的定义了一些类和相关协议，它最主要的作用就是为程序提供文字排版和渲染的功能。在程序中，通过Text Kit可以对文字进行存储(store)、布局(lay out)，以及用最精细的排版方式(例如文字间距、换行和对齐等)来显示文本内容。
苹果引入Text Kit的目的并非要取代已有的Core Text，Core Text的主要作用也是用于文字的排版和渲染中，它是一种先进而又处于底层技术，如果我们需要将文本内容直接渲染到图形上下文(Graphics context)时，从性能和易用性来考虑，最佳方案就是使用Core Text。而如果我们直接利用苹果提供的一些控件(例如UITextView、UILabel和UITextField等)对文字进行排版，无疑就是借助于UIkit framework中Text Kit提供的API。</p>

<h3><a id="2"></a>Text Kit架构</h3>

<p>下面，我们通过图1(此图来自WWDC2013 Session 210)来了解一下Text Kit的架构。图1是基于iOS 7绘制的，从图中，我们可以看到Text Kit是基于Core Text构建的，它通过Core Text与Core Graphics进行交互。而UI控件(UILabel、UITextField和UITextView)则构建于Text Kit之上，可见这些文本控件可以利用Text Kit提供的API来对文字进行排版和渲染处理。
从图中我们也可以看到SDK提供的UIWebView是基于WebKit的，它不能使用Text Kit提供的功能。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/23.jpg" alt="图1 Text Kit在iOS 7 SDK中的位置" /></p>

<p>我们再来看看图1中的相关组件在iOS6里面是如何对应的，如图2所示，可以看出在iOS 6中是没有Text Kit，并且UILabel、UIText和UITextView是基于String Drawing和WebKit构建的。其中String Drawing是与Core Graphics直接通讯。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/24.jpg" alt="图2 在iOS 6中并没有Text Kit" /></p>

<h3><a id="3"></a>Text Kit特点</h3>

<p>从上面的介绍中，我们可以了解到Text Kit在UIKit中的作用非常重要。Text Kit在实际开发中具有如下特点：</p>

<ul>
<li>在UI控件中Text Kit完全掌控着文字的排版和渲染</li>
<li>UITextView、UITextField和UILabel是构建于Text Kit之上的</li>
<li>能够与动画、UICollectionView和UITableView做到无缝集成</li>
<li>Text Kit具有这样一些能力：Subclassing、Delegation和Notifcation。</li>
</ul>


<h3><a id="4"></a>Text Kit功能概述</h3>

<p>下面我们看看通过Text Kit，都能实现那些功能(这里列出了是一些常用和重要功能)：</p>

<ul>
<li>对文字进行分页或多列排版</li>
<li>支持文字的换行、折叠和着色等处理</li>
<li>可以调整字与字之间的距离、行间距、文字大小、指定特定的字体</li>
<li>支持富文本编辑，可以自定义文字截断</li>
<li>支持凸版印刷效果(letterpress)</li>
<li>支持数据类型的检测(例如链接、附件等)</li>
</ul>


<p>如图3，是利用Text Kit对文字做的分页排版</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/25.jpg" alt="图3 利用Text Kit做的分页排版效果" /></p>

<p>再看图4，是利用Text Kit做的换行处理，其中对某个路径范围做了排除。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/26.jpg" alt="图4 利用Text Kit做的换行处理效果" /></p>

<p>再来看看利用Text Kit做的凸版印刷效果，如图5所示</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/27.jpg" alt="图5 利用Text Kit做的凸版印刷效果" /></p>

<h3><a id="5"></a>Text Kit中重要的一些对象</h3>

<p>下面我们来看看Text Kit中重要的几个对象。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/28.jpg" alt="图6 Text Kit中重要的几个对象" /></p>

<p>如图6所示，Text Kit中主要有4个重要的对象。</p>

<ul>
<li>Text View是用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。</li>
<li>Text containers对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素(例如图片，如图4所示)。</li>
<li>Layout manager对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。</li>
<li>Text storage对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。</li>
</ul>


<p>通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应的。如图7所示关系：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/29.jpg" alt="图7 普通排版" /></p>

<p>当然，如果需要将文字显示为多列，或多页，可以按照如图8所示关系——使用多个NSTextContainer。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/30.jpg" alt="图8 多页或者多列排版" /></p>

<p>如果针对不同的排版方式，则可以使用多个NSLayoutManager，如图9所示</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/31.jpg" alt="图9 不同的排版方式" /></p>

<p>如图10所示，通过形象的方式，对UITextView的组成做了分解。通常，我们在设备上只能看到最右边的文本显示界面，而内部的NSTextStorage、NSLayoutManager和NSTextContainer是看不出来的。通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer结合UITextView将最终效果显示出来。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/32.jpg" alt="图10 UITextView的分解" /></p>

<h3><a id="6"></a>Text Kit示例</h3>

<p>前面对Text Kit做了一些介绍，下面我们配合一个例子(图文排版)，来进一步加深对Text Kit的认识。具体实现步骤如下</p>

<ol>
<li>打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。</li>
<li>打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。</li>
<li>打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法：</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//创建一个平移手势对象，该对象可以调用imagePanned：方法</span>
</span><span class='line'>    <span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">panGes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIPanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">imagePanned:</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">imageView</span> <span class="nl">addGestureRecognizer:</span><span class="n">panGes</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">textContainer</span><span class="p">.</span><span class="n">exclusionPaths</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">self</span> <span class="n">translatedBezierPath</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。</p>

<ol>
<li>下面来看一下translatedBezierPath方法的实现，如下代码所示</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIBezierPath</span> <span class="o">*</span><span class="p">)</span><span class="nf">translatedBezierPath</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CGRect</span> <span class="n">butterflyImageRect</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">textView</span> <span class="nl">convertRect:</span><span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">frame</span> <span class="nl">fromView:</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="n">UIBezierPath</span> <span class="o">*</span><span class="n">newButterflyPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIBezierPath</span> <span class="nl">bezierPathWithRect:</span><span class="n">butterflyImageRect</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">newButterflyPath</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。
5. 还记得第3步中创建的平移手势吗。里面有一个action需要实现imagePanned:，下面来看看这个方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">imagePanned:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">sender</span> <span class="nl">isKindOfClass:</span><span class="p">[</span><span class="n">UIPanGestureRecognizer</span> <span class="n">class</span><span class="p">]])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">localSender</span> <span class="o">=</span> <span class="n">sender</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">localSender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateBegan</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">localSender</span> <span class="nl">translationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">];</span>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingCenter</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">center</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">localSender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateChanged</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CGPoint</span> <span class="n">currentPoint</span> <span class="o">=</span> <span class="p">[</span><span class="n">localSender</span> <span class="nl">translationInView:</span><span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">CGFloat</span> <span class="n">distanceX</span> <span class="o">=</span> <span class="n">currentPoint</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>            <span class="n">CGFloat</span> <span class="n">distanceY</span> <span class="o">=</span> <span class="n">currentPoint</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">CGPoint</span> <span class="n">newCenter</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingCenter</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">newCenter</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">distanceX</span><span class="p">;</span>
</span><span class='line'>            <span class="n">newCenter</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">distanceY</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">newCenter</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">textView</span><span class="p">.</span><span class="n">textContainer</span><span class="p">.</span><span class="n">exclusionPaths</span> <span class="o">=</span> <span class="err">@</span><span class="p">[[</span><span class="n">self</span> <span class="n">translatedBezierPath</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">localSender</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'>            <span class="n">self</span><span class="p">.</span><span class="n">gestureStartingCenter</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。
6. 至此代码编写完毕，下面来运行程序，看看实际效果。如图11所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/33.gif" alt="图11 运行效果" /></p>

<ol>
<li>点击下图，下载代码</li>
</ol>


<p><a href="https://github.com/BeyondVincent/iOS7-new-feature/tree/master/code/TextKit/ExclusionPath"><img src="http://BeyondVincent.github.io/images/2013/11/34.jpg" alt="" /></a></p>

<h3><a id="7"></a>小结</h3>

<p>实际上，上面的示例，只是揭秘了Text Kit功能的冰山一角。从iOS7及以后的版本中，Text Kit在UIKit framework里面占据重要的地位，Text Kit在文字处理方面，具有非常强大的功能，并且开发者可以对Text Kit进行定制和扩展。据悉，苹果利用了2年的时间来开发Text Kit，相信这对许多开发者来说都是福音。</p>

<h3><a id="8"></a>推荐Text Kit学习资源</h3>

<p>更多关于Text Kit的学习资料，请参考下面的内容：</p>

<p>wwdc视频:</p>

<ul>
<li>Introducing Text Kit</li>
<li>Advanced Text Layouts and Effects with Text Kit</li>
<li>Using Fonts with Text Kit</li>
</ul>


<p>苹果官方参考文档：</p>

<ul>
<li>Text Programming Guide for iOS.pdf</li>
<li>NSLayoutManager Class Reference for iOS.pdf</li>
<li>NSLayoutManagerDelegate Protocol Reference for iOS.pdf</li>
<li>NSTextContainer Class Reference for iOS.pdf</li>
<li>NSTextStorage Class Reference for iOS.pdf</li>
<li>NSTextStorageDelegate Protocol Reference for iOS.pdf</li>
</ul>


<p>苹果官方示例：</p>

<ul>
<li>IntroToTextKit</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 7 教程：定制iOS 7中的导航栏和状态栏]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/03/120-customize-navigation-status-bar-ios-7/"/>
    <updated>2013-11-03T22:55:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/03/120-customize-navigation-status-bar-ios-7</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/11/7.png" alt="" /></p>

<!--more-->


<p>注：本文译自<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/"><code>Customizing Navigation Bar and Status Bar in iOS 7</code></a></p>

<p>近期，跟大多数开发者一样，我也正忙于对程序进行升级以适配iOS 7。最新的iOS 7外观上有大量的改动。从开发者的角度来看，导航栏和状态栏就发生了明显的变化。状态栏现在是半透明的了，这也就意味着导航栏会显示在状态栏后面。有些情况下，导航栏的背景图片可以延伸显示到状态栏后面。</p>

<p>之前我曾经写过一篇关于<a href="http://www.appcoda.com/customize-navigation-bar-back-butto/">如何定制导航栏</a>的文章。不过现在是时候对其进行更新了。下面就是本文将要介绍的内容：</p>

<ul>
<li><a href="#0">iOS 7中默认的导航栏</a></li>
<li><a href="#1">设置导航栏的背景颜色</a></li>
<li><a href="#2">在导航栏中使用背景图片</a></li>
<li><a href="#3">定制返回按钮的颜色</a></li>
<li><a href="#4">修改导航栏标题的字体</a></li>
<li><a href="#44">修改导航栏标题为图片</a></li>
<li><a href="#5">添加多个按钮</a></li>
<li><a href="#6">修改状态栏的风格</a></li>
<li><a href="#7">隐藏状态栏</a></li>
<li><a href="#8">总结</a></li>
</ul>


<p><img src="http://BeyondVincent.github.io/images/2013/11/9.jpg" alt="" /></p>

<p>本文提供的代码需要用Xcode 5来执行。如果你还在使用老版本的Xcode，那么在运行示例之前请将Xcode升级到Xcode 5。</p>

<h3><a id="0"></a>iOS 7中默认的导航栏</h3>

<p>在开始定制之前，我们先来看看iOS 7中默认导航栏的外观。通过Xcode用<code>Single View Controller</code>模板创建一个工程。然后将view controller嵌入到一个navigation controller中。如果你不想从头开始，那么也可以在这里下载到这个<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程</a>。</p>

<p>Xcode 5包含有iOS 6和iOS 7模拟器，我们可以在这两个不同的模拟器版本中运行示例程序，进行对比，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/10.jpg" alt="" /></p>

<p>如上图所示，在iOS 7中的导航栏默认情况下跟状态栏是交织在一起的，并且它的颜色也被修改为亮灰色。</p>

<h3><a id="1"></a>设置导航栏的背景颜色</h3>

<p>在iOS 7中，不再使用tintColor属性来设置导航栏的颜色，而是使用barTintColor属性来修改背景色。我们可以在<code>AppDelegate.m</code>文件中的方法<code>didFinishLaunchingWithOptions:</code>里面添加如下代码来修改颜色：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBarTintColor:</span><span class="p">[</span><span class="n">UIColor</span> <span class="n">yellowColor</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>效果如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/11.jpg" alt="" /></p>

<p>一般情况，我们都会使用自己的颜色，下面这个宏用来设置RGB颜色非常方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define UIColorFromRGB(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]</span>
</span></code></pre></td></tr></table></div></figure>


<p>将上面这个宏放到<code>AppDelegate.m</code>文件中，然后通过这个宏来创建一个UIColor对象(根据指定的RGB)。如下示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBarTintColor:</span><span class="n">UIColorFromRGB</span><span class="p">(</span><span class="mh">0x067AB5</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p>默认情况下，导航栏的translucent属性为YES。另外，系统还会对所有的导航栏做模糊处理，这样可以让iOS 7中导航栏的颜色更加饱和。如下图，是translucent值为NO和YES的对比效果：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/12.jpg" alt="" /></p>

<p>要想禁用translucent属性，可以在Storyboard中选中导航栏，然后在Attribute Inspectors中，取消translucent的勾选。</p>

<h3><a id="2"></a>在导航栏中使用背景图片</h3>

<p>如果希望在导航栏中使用一个图片当做背景，那么你需要提供一个稍微高一点的图片(这样可以延伸到导航栏背后)。导航栏的高度从44 points(88 pixels)变为了64 points(128 pixels)。</p>

<p>我们依然可以使用<code>setBackgroundImage:</code>方法为导航栏设置自定义图片。如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBackgroundImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;nav_bg.png&quot;</span><span class="p">]</span> <span class="nl">forBarMetrics:</span><span class="n">UIBarMetricsDefault</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>示例工程中提供了两个背景图片：nav_bg.png 和 nav_bg_ios7.png。运行一下试试看吧，如下效果：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/13.jpg" alt="" /></p>

<h3><a id="3"></a>定制返回按钮的颜</h3>

<p>在iOS 7中，所有的按钮都是无边框的。其中返回按钮会有一个V型箭头，以及上一个屏幕中的标题(如果上一屏幕的标题是空，那么就显示&#8221;返回&#8221;)。要想给返回按钮着色，可以使用tintColor属性。如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setTintColor:</span><span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了返回按钮，tintColor属性会影响到所有按钮标题和图片。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/14.jpg" alt="" /></p>

<p>如果想要用自己的图片替换V型，可以设置图片的<code>backIndicatorImage</code>和<code>backIndicatorTransitionMaskImage</code>。如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBackIndicatorImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;back_btn.png&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBackIndicatorTransitionMaskImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;back_btn.png&quot;</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>图片的颜色是由tintColor属性控制的。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/15.jpg" alt="" /></p>

<h3><a id="4"></a>修改导航栏标题的字体</h3>

<p>跟iOS 6一样，我们可以使用导航栏的<code>titleTextAttributes</code>属性来定制导航栏的文字风格。在text attributes字典中使用如下一些key，可以指定字体、文字颜色、文字阴影色以及文字阴影偏移量：</p>

<ul>
<li>UITextAttributeFont – 字体key</li>
<li>UITextAttributeTextColor – 文字颜色key</li>
<li>UITextAttributeTextShadowColor – 文字阴影色key</li>
<li>UITextAttributeTextShadowOffset – 文字阴影偏移量key</li>
</ul>


<p>如下代码所示，对导航栏的标题风格做了修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSShadow</span> <span class="o">*</span><span class="n">shadow</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSShadow</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">shadow</span><span class="p">.</span><span class="n">shadowColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="mf">0.0</span> <span class="nl">green:</span><span class="mf">0.0</span> <span class="nl">blue:</span><span class="mf">0.0</span> <span class="nl">alpha:</span><span class="mf">0.8</span><span class="p">];</span>
</span><span class='line'>    <span class="n">shadow</span><span class="p">.</span><span class="n">shadowOffset</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">UINavigationBar</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setTitleTextAttributes:</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjectsAndKeys:</span>
</span><span class='line'>                                                           <span class="p">[</span><span class="n">UIColor</span> <span class="nl">colorWithRed:</span><span class="mf">245.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">green:</span><span class="mf">245.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">blue:</span><span class="mf">245.0</span><span class="o">/</span><span class="mf">255.0</span> <span class="nl">alpha:</span><span class="mf">1.0</span><span class="p">],</span> <span class="n">NSForegroundColorAttributeName</span><span class="p">,</span>
</span><span class='line'>                                                           <span class="n">shadow</span><span class="p">,</span> <span class="n">NSShadowAttributeName</span><span class="p">,</span>
</span><span class='line'>                                                           <span class="p">[</span><span class="n">UIFont</span> <span class="nl">fontWithName:</span><span class="s">@&quot;HelveticaNeue-CondensedBlack&quot;</span> <span class="nl">size:</span><span class="mf">21.0</span><span class="p">],</span> <span class="n">NSFontAttributeName</span><span class="p">,</span> <span class="nb">nil</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行效果如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/16.jpg" alt="" /></p>

<h3><a id="44"></a>修改导航栏标题为图片</h3>

<p>如果要想将导航栏标题修改为一个图片或者logo，那么只需要使用下面这行代码即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">titleView</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage:</span><span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageNamed:</span><span class="s">@&quot;appcoda-logo.png&quot;</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码简单的修改了titleView属性，将一个图片赋值给它。
注意：这不是iOS 7中的新功能，之前的iOS版本就可以已经有了。</p>

<p>具体效果如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/17.jpg" alt="" /></p>

<h3><a id="5"></a>添加多个按钮</h3>

<p>同样，这个技巧也不是iOS 7的，开发者经常会在导航栏中添加多个按钮，所以我决定在这里进行介绍。我们可以在导航栏左边或者右边添加多个按钮。例如，我们希望在导航栏右边添加一个照相机和分享按钮，那只需要使用下面的代码即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIBarButtonItem</span> <span class="o">*</span><span class="n">shareItem</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBarButtonSystemItem:</span><span class="n">UIBarButtonSystemItemAction</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">action:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'><span class="n">UIBarButtonItem</span> <span class="o">*</span><span class="n">cameraItem</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBarButtonSystemItem:</span><span class="n">UIBarButtonSystemItemCamera</span> <span class="nl">target:</span><span class="n">self</span> <span class="nl">action:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">actionButtonItems</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="n">shareItem</span><span class="p">,</span> <span class="n">cameraItem</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">rightBarButtonItems</span> <span class="o">=</span> <span class="n">actionButtonItems</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如下效果：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/18.jpg" alt="" /></p>

<h3><a id="6"></a>修改状态栏的风格</h3>

<p>在老版本的iOS中，状态栏永远都是白色风格。而在iOS 7中，我们可以修改每个view controller中状态栏的外观。通过UIStatusBarStyle常量可以指定状态栏的内容是暗色或亮色。默认情况下，状态栏的显示是暗色。也就是说，状态栏上的时间、电池指示器和Wi-Fi信号显示为暗色。如果导航栏中使用暗色为背景，那么看起来的效果如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/19.jpg" alt="" /></p>

<p>如上图这种情况下，我们可能希望将导航栏的风格修改为亮色。这里有两个方法可以实现。在iOS 7中，我们可以在每个view controller中overriding<code>preferredStatusBarStyle:</code>方法，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="n">UIStatusBarStyle</span><span class="p">)</span><span class="nf">preferredStatusBarStyle</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">UIStatusBarStyleLightContent</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面代码的效果如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/20.jpg" alt="" /></p>

<p>在iOS 7中，通过上面的方法来修改状态栏风格非常的棒。另外，我们也可以使用UIApplication的statusBarStyle方法来设置状态栏，不过，首先需要停止使用<code>View controller-based status bar appearance</code>。在project target的Info tab中，插入一个新的key，名字为<code>View controller-based status bar appearance</code>，并将其值设置为NO。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/21.jpg" alt="" /></p>

<p>然后就可以使用下面的代码来设置状态栏风格了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">setStatusBarStyle:</span><span class="n">UIStatusBarStyleLightContent</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="7"></a>隐藏状态栏</h3>

<p>有时候我们需要隐藏状态栏，那么此时我们在view controller中override方法prefersStatusBarHidden:即可，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">prefersStatusBarHidden</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a id="8"></a>总结</h3>

<p>iOS 7给开发者提供了一些新的自由度来定制导航栏和状态栏的外观。希望上面的这些技巧能对你有用。</p>

<p>这里可以下载到<a href="https://dl.dropboxusercontent.com/u/2857188/NavigationBarDemo.zip">示例工程源码</a>。只需要取消相关代码注释即可进行测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：制作一个通用程序 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/11/02/119-sprite-kit-tutorial-making-a-universal-app-part-2/"/>
    <updated>2013-11-02T18:55:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/11/02/119-sprite-kit-tutorial-making-a-universal-app-part-2</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/10/25.png"></p>

<!--more-->


<p>注1：本文译自<a href="http://www.raywenderlich.com/49697/sprite-kit-tutorial-making-a-universal-app-part-2"><code>Sprite Kit Tutorial: Making a Universal App: Part 2</code></a></p>

<p>注2：我最近长时间在广西南宁出差，比较忙，跑步和篮球都歇着了，博客更新频率也有点慢。下周⑥又是某某人的生日，估计是回不去了%>_&lt;%，下半年还有一些重要的事情要做，时间太少！加油！</p>

<p>上周发现住的附近有一个公园，考察了一下，适合跑步，所以呢，我计划本周末去买点运动的衣服，重启跑步计划 :]</p>

<p>看吧，下图就是公园照的</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/1.jpg" alt="南宁市人民公园" /></p>

<p>好啦，下面开始本文正题：</p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#dhkx">动画的定义：可行性</a></li>
<li><a href="#sxlb">属性列表</a></li>
<li><a href="#yxlj">添加游戏逻辑</a></li>
<li><a href="#tjyx">添加音效</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p><a href="http://beyondvincent.com/blog/2013/10/27/118-sprite-kit-tutorial-making-a-universal-app-part-1/">上一篇文章中</a>，创建了一个基本的游戏程序：一些可爱的鼹鼠从洞里面跳出来。并且为了能够让程序很好的运行在iPhone 3.5英寸，iPhone 4英寸，iPad和iPad Retina上，还花费了大量的篇幅介绍UI设计和坐标系相关知识。</p>

<p>本文，将给鼹鼠添加一些可爱的动画：笑和被打时的表情，并添加一种玩法：可以通过敲打鼹鼠来赚取点数，另外还会添加一些音效。</p>

<h3><a id="dhkx"></a>动画的定义：可行性</h3>

<p>为了让游戏更加有趣，我们将在游戏中给鼹鼠添加两个动画。首先，当鼹鼠从洞里面跳出来时是笑的动画，然后，当你敲打它们的时候，是一个被敲打的表情。</p>

<p>在开始之前，我们先来看看在代码里面定义动画的可行性。</p>

<p>鼹鼠笑的动画需要用到的图片和相关顺序是这样的：
mole_laugh1.png, mole_laugh2.png mole_laugh3.png, mole_laugh2.png, mole_laugh3.png, mole_laugh1.png。</p>

<p>我们可以通过硬编码的方式来配置我们的动画，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">animFrames</span> <span class="nl">addObject:</span>
</span><span class='line'>    <span class="p">[</span><span class="n">SKTexture</span> <span class="nl">textureWithImageNamed:</span><span class="s">@&quot;mole_laugh1.png&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="p">[</span><span class="n">animFrames</span> <span class="nl">addObject:</span>
</span><span class='line'>    <span class="p">[</span><span class="n">SKTexture</span> <span class="nl">textureWithImageNamed:</span><span class="s">@&quot;mole_laugh2.png&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="p">[</span><span class="n">animFrames</span> <span class="nl">addObject:</span>
</span><span class='line'>    <span class="p">[</span><span class="n">SKTexture</span> <span class="nl">textureWithImageNamed:</span><span class="s">@&quot;mole_laugh3.png&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="p">[</span><span class="n">animFrames</span> <span class="nl">addObject:</span>
</span><span class='line'>    <span class="p">[</span><span class="n">SKTexture</span> <span class="nl">textureWithImageNamed:</span><span class="s">@&quot;mole_laugh2.png&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="c1">// And so on...</span>
</span></code></pre></td></tr></table></div></figure>


<p>不过，这很容易让我们的代码剧增。为了简洁一点，此处我们不用上面的代码来定义动画，而是使用属性列表来代替。</p>

<h3><a id="sxlb"></a>属性列表</h3>

<p>如果之前你没有用过属性列表，也没关系。属性列表就是一个特殊的文件，可以用Xcode创建，文件按照一定的格式包含数组、字典、字符串和数字，所以非常容易创建，并且在代码中叶能够方便的读取到这些值。</p>

<p>下面我们在Xcode中试试吧。右键单击ShackAMole，选择&#8221;New File…&#8221;，接着选择 “iOS\Resource\Property List”，然后单击&#8221;Next&#8221;。将文件命名为&#8221;laughAnim.plist&#8221;，最后单击创建。现在可以在Xcode中看到laughAnim.plist的可视化编辑界面，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/2.png" alt="南" /></p>

<p>每个属性列表都有一个root element。一般这是一个数组或者字典。在我们创建的这个文件中，将包含让鼹鼠笑起来所需动画的所有图片名称，是一个数组，所以点击root element的第二列(Type，当前为Dictionary)，将其修改为Array。</p>

<p>接着，单击Root单词右边的加号按钮，以在数组中添加一个新的entry。默认情况下，entry的类型是String(刚好是我们想要的).将这个entry的值修改为&#8221;mole_laugh1.png&#8221;。</p>

<p>继续点击加号按钮添加新的一条记录，直到所有的图片名称都添加进来了，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/3.png" alt="" /></p>

<p>接着添加一个鼹鼠被打击所需要图片的属性列表文件，跟上面的步骤一样，不过记得将文件命名为hitAnim.plist文件，如下所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/4.png" alt="" /></p>

<p>下面，我们就在代码中加载这些图片吧。打开MyScene.h文件，并为每个动画动作添加对应的属性，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Inside @interface MyScene</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">SKAction</span> <span class="o">*</span><span class="n">laughAnimation</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">SKAction</span> <span class="o">*</span><span class="n">hitAnimation</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们用上面这两个属性记录每个SKAction，这样可以在代码中方便的查找和重用。</p>

<p>接着在MyScene.m中添加一个方法，方法中的代码根据传入的属性列表创建并返回SKAction，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">SKAction</span> <span class="o">*</span><span class="p">)</span><span class="nf">animationFromPlist:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">animPlist</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">plistPath</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">pathForResource:</span><span class="n">animPlist</span> <span class="nl">ofType:</span><span class="s">@&quot;plist&quot;</span><span class="p">];</span> <span class="c1">// 1</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">animImages</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSArray</span> <span class="nl">arrayWithContentsOfFile:</span><span class="n">plistPath</span><span class="p">];</span> <span class="c1">// 2</span>
</span><span class='line'>    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">animFrames</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span> <span class="c1">// 3</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="k">in</span> <span class="n">animImages</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 4</span>
</span><span class='line'>        <span class="p">[</span><span class="n">animFrames</span> <span class="nl">addObject:</span><span class="p">[</span><span class="n">SKTexture</span> <span class="nl">textureWithImageNamed:</span><span class="n">imageName</span><span class="p">]];</span> <span class="c1">// 5</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">float</span> <span class="n">framesOverOneSecond</span> <span class="o">=</span> <span class="mf">1.0f</span><span class="o">/</span><span class="p">(</span><span class="kt">float</span><span class="p">)[</span><span class="n">animFrames</span> <span class="n">count</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">animateWithTextures:</span><span class="n">animFrames</span> <span class="nl">timePerFrame:</span><span class="n">framesOverOneSecond</span> <span class="nl">resize:</span><span class="n">NO</span> <span class="nl">restore:</span><span class="n">YES</span><span class="p">];</span> <span class="c1">// 6</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>理解上面的代码很重要，我们一行一行的来看看吧：</p>

<ol>
<li>由于属性列表是包含在工程里面的，所以它应该在程序的&#8221;main bundle&#8221;中。这个helper方法计算出了属性列表文件在main bundle中的全路径。</li>
<li>这行代码是读取属性列表文件中的内容。NSArray中有一个名为arrayWithContentsOfFile的方法，此处将文件名传递进去，就可以将属性列表中的内容读取到数组中了。（注意，之所以可以这样，是因为属性列表中的root element设置为NSArray），如果是一个字典的话，可以使用[NSDictionary dictionaryWithContentsOfFile…]。</li>
<li>创建一个空的数组，用来存储动画的每一帧。</li>
<li>循环遍历数组获得每个图片名字。</li>
<li>获得每个图片的纹理，然后将其添加到数组中。</li>
<li>根据纹理数组返回一个SKAction。</li>
</ol>


<p>接下来，在init方法的尾部为每个动画调用上面这个helper方法，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">laughAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">animationFromPlist:</span><span class="s">@&quot;laughAnim&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">hitAnimation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">animationFromPlist:</span><span class="s">@&quot;hitAnim&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后一步：使用动画(让鼹鼠笑起来)。修改popMole方法，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popMole:</span><span class="p">(</span><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="p">)</span><span class="nv">mole</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveUp</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">mole</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>  <span class="n">easeMoveUp</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>  <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveDown</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>  <span class="n">easeMoveDown</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">easeMoveUp</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">laughAnimation</span><span class="p">,</span> <span class="n">easeMoveDown</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mole</span> <span class="nl">runAction:</span><span class="n">sequence</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码与之前唯一不同的就是用laughAnimation action替代了pop down之前的延迟一秒。laughAnimation action会使用laughAnim.plist中的纹理，注意之前已经把restore设置为YES了，所以当动画播放完之后，鼹鼠会回到正常的表情。</p>

<p>现在编译并运行程序，可以看到鼹鼠跳出来，并笑了！如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/5.png" alt="" /></p>

<p>下面我们来看看如何停止鼹鼠的<code>微笑</code>动画，并开始敲打它们。</p>

<h3><a id="yxlj"></a>添加游戏逻辑</h3>

<p>现在我们准备给游戏添加玩法，也就是游戏逻辑。基本想法就是会有一定数量的鼹鼠出现，当玩家打击到这些出现的鼹鼠时，就会获得相应的点数，玩家将尽力获得最多的点数。</p>

<p>因此，我们需要记录分数，并将分数显示在屏幕中。当鼹鼠显示完毕时候，我们将对用户做出提示。</p>

<p>先打开MyScene.h文件，并将下面这些实例变量添加到之前写的action后面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">SKLabelNode</span> <span class="o">*</span><span class="n">scoreLabel</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">score</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSInteger</span> <span class="n">totalSpawns</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">gameOver</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>有一个用于显示分数的label，一个记录当前分数的变量，一个记录已经弹出了多少个鼹鼠，以及游戏是否结束。</p>

<p>接着，将下面的代码添加到文件MyScene.m文件中initWithSize:方法尾部：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Add score label</span>
</span><span class='line'><span class="kt">float</span> <span class="n">margin</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKLabelNode</span> <span class="nl">labelNodeWithFontNamed:</span><span class="s">@&quot;Chalkduster&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Score: 0&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span><span class="p">.</span><span class="n">fontSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">convertFontSize:</span><span class="mi">14</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span><span class="p">.</span><span class="n">horizontalAlignmentMode</span> <span class="o">=</span> <span class="n">SKLabelHorizontalAlignmentModeLeft</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span> <span class="n">margin</span><span class="p">);</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码创建了一个用于分数显示的label。label位于屏幕的左下角，并且距离左下角的边距为10 point。并将label的属性horizontalAlignmentMode设置为SKLabelHorizontalAlignmentModeLeft，这样可以让label的文字从左侧对齐。</p>

<p>另外，此处并没有直接给label设置字体大小，而是先通过一个helper函数将字体大小做转换。这是因为在iPad和iPad retina上字体的尺寸要大一点。下面是convertFontSize方法的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nf">convertFontSize:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">fontSize</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UI_USER_INTERFACE_IDIOM</span><span class="p">()</span> <span class="o">==</span> <span class="n">UIUserInterfaceIdiomPad</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">fontSize</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">fontSize</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上代码所示，如果是iPad和iPad retina，那么就将字体尺寸变为原来的两倍，否则保持原样。</p>

<p>接着，我们需要添加触摸检测的代码，用来判断是否打击了某个鼹鼠。不过在开始之前，我们需要给鼹鼠添加一个flag，以此知道鼹鼠当前是否可以点击(tappable)。只有当鼹鼠笑的时候才可以点击，而当它移动或者在底下时是不可以点击的，也就是“安全的”。</p>

<p>我们可以创建一个SKSpriteNode的子类来记录这个flag，不过在此我们只需要存储一个信息，因此我们可以使用SKSpriteNode中的userData属性来代替。如下，再次将popMole做修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popMole:</span><span class="p">(</span><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="p">)</span><span class="nv">mole</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">totalSpawns</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">totalSpawns</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Reset texture of mole sprite</span>
</span><span class='line'>    <span class="n">mole</span><span class="p">.</span><span class="n">texture</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">moleTexture</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveUp</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">mole</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>    <span class="n">easeMoveUp</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveDown</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>    <span class="n">easeMoveDown</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">setTappable</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">runBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mole</span><span class="p">.</span><span class="n">userData</span> <span class="nl">setObject:</span><span class="err">@</span><span class="mi">1</span> <span class="nl">forKey:</span><span class="s">@&quot;tappable&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">unsetTappable</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">runBlock:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mole</span><span class="p">.</span><span class="n">userData</span> <span class="nl">setObject:</span><span class="err">@</span><span class="mi">0</span> <span class="nl">forKey:</span><span class="s">@&quot;tappable&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">easeMoveUp</span><span class="p">,</span> <span class="n">setTappable</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">laughAnimation</span><span class="p">,</span> <span class="n">unsetTappable</span><span class="p">,</span> <span class="n">easeMoveDown</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mole</span> <span class="nl">runAction:</span><span class="n">sequence</span> <span class="nl">completion:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mole</span> <span class="n">removeAllActions</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要做了如下修改：</p>

<ul>
<li>如果显示的鼹鼠数量有50个，那么立即返回，也就是说，在游戏中，50是最大的上限。</li>
<li>在函数开头，重置一下鼹鼠的图片(&ldquo;mole_1.png&rdquo;)。这样做是因为如果鼹鼠在上一次显示的时候被击打了，它仍然显示被击打的图片，所以在这里显示之前，需要重置一下。</li>
<li>在鼹鼠笑之前，先运行一个action，该action会在block中运行一段代码。该block将userData字典中名为tappable的key值设置为1，这样就可以表示鼹鼠可以被击打了。</li>
<li>类似的，当鼹鼠笑过之后，同样运行一个action：将tappable的值设置为0.</li>
</ul>


<p>现在，鼹鼠有一个flag可以表示它是否可以被击中了。接着我们可以添加touchesBegan:方法了。将如下代码添加到文件中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="p">[</span><span class="n">touches</span> <span class="n">anyObject</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInNode:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">nodeAtPoint:</span><span class="n">touchLocation</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">node</span><span class="p">.</span><span class="n">name</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;Mole&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">mole</span> <span class="o">=</span> <span class="p">(</span><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[[</span><span class="n">mole</span><span class="p">.</span><span class="n">userData</span> <span class="nl">objectForKey:</span><span class="s">@&quot;tappable&quot;</span><span class="p">]</span> <span class="n">boolValue</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">score</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">mole</span><span class="p">.</span><span class="n">userData</span> <span class="nl">setObject:</span><span class="err">@</span><span class="mi">0</span> <span class="nl">forKey:</span><span class="s">@&quot;tappable&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mole</span> <span class="n">removeAllActions</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveDown</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="p">(</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">mole</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>        <span class="n">easeMoveDown</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Slow down the animation by half</span>
</span><span class='line'>        <span class="n">easeMoveDown</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">hitAnimation</span><span class="p">,</span> <span class="n">easeMoveDown</span><span class="p">]];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mole</span> <span class="nl">runAction:</span><span class="n">sequence</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的touchesBegan:方法首先获得触摸的位置，然后找到触摸位置对于的SKNode，如果node的名字是Mole，那么会进一步判断这个鼹鼠的tappable。</p>

<p>如果鼹鼠被击中，会将该鼹鼠设置为不可再被击中，并把分数增加。然后停止所有运行的action，并播放被击中的动画，动画播放完毕之后，就立即把鼹鼠放回洞中。</p>

<p>最后一步：添加一些代码对分数进行更新，并且做一个级别完成条件的检查，如下代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">gameOver</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">totalSpawns</span> <span class="o">&gt;=</span> <span class="mi">50</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKLabelNode</span> <span class="o">*</span><span class="n">gameOverLabel</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKLabelNode</span> <span class="nl">labelNodeWithFontNamed:</span><span class="s">@&quot;Chalkduster&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="n">gameOverLabel</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Level Complete!&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">gameOverLabel</span><span class="p">.</span><span class="n">fontSize</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
</span><span class='line'>    <span class="n">gameOverLabel</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</span><span class='line'>    <span class="n">gameOverLabel</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">),</span>
</span><span class='line'>                                         <span class="n">CGRectGetMidY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">gameOverLabel</span> <span class="nl">setScale:</span><span class="mf">0.1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">gameOverLabel</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">gameOverLabel</span> <span class="nl">runAction:</span><span class="p">[</span><span class="n">SKAction</span> <span class="nl">scaleTo:</span><span class="mf">1.0</span> <span class="nl">duration:</span><span class="mf">0.5</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">gameOver</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">scoreLabel</span> <span class="nl">setText:</span><span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;Score: %d&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">score</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>搞定！编译并运行程序，应该可以击打鼹鼠，并看到分数在增加！如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/11/6.png" alt="" /></p>

<h3><a id="tjyx"></a>添加音效</h3>

<p>为了让程序更加有趣，下面我们给这游戏添加音效。先来这里下载<a href="http://cdn5.raywenderlich.com/downloads/WhackAMoleSKSounds.zip">音效</a>吧。加压出文件，并把声音资源拖拽到WhackAMole文件件中。确保勾选上<code>Copy items into destination group’s folder</code>，然后单击Finish。</p>

<p>将下面声明语句添加到MyScene.h文件顶部：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;AVFoundation/AVFoundation.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着将如下属性添加到@end前面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">AVAudioPlayer</span> <span class="o">*</span><span class="n">audioPlayer</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">SKAction</span> <span class="o">*</span><span class="n">laughSound</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">SKAction</span> <span class="o">*</span><span class="n">owSound</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在MyScene.m文件中做如下修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Add at the bottom of your initWithSize: method</span>
</span><span class='line'><span class="c1">// Preload whack sound effect</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">laughSound</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">playSoundFileNamed:</span><span class="s">@&quot;laugh.caf&quot;</span> <span class="nl">waitForCompletion:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">owSound</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">playSoundFileNamed:</span><span class="s">@&quot;ow.caf&quot;</span> <span class="nl">waitForCompletion:</span><span class="n">NO</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="nl">URLForResource:</span><span class="s">@&quot;whack&quot;</span> <span class="nl">withExtension:</span><span class="s">@&quot;caf&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">audioPlayer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">AVAudioPlayer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentsOfURL:</span><span class="n">url</span> <span class="nl">error:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">audioPlayer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Error creating player: %@&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">audioPlayer</span> <span class="n">play</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Add at bottom of popMole method, change the sequence action to:</span>
</span><span class='line'><span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">easeMoveUp</span><span class="p">,</span> <span class="n">setTappable</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">laughSound</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">laughAnimation</span><span class="p">,</span> <span class="n">unsetTappable</span><span class="p">,</span> <span class="n">easeMoveDown</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Add inside touchesBegan: method, change the sequence action to:</span>
</span><span class='line'><span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">owSound</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">hitAnimation</span><span class="p">,</span> <span class="n">easeMoveDown</span><span class="p">]];</span>
</span></code></pre></td></tr></table></div></figure>


<p>搞定！编译并运行程序试试吧！</p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn2.raywenderlich.com/downloads/WhackAMoleSK2.zip">这里</a>。</p>

<p>至此，关于如何制作通用程序的介绍到此结束！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：制作一个通用程序 1]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/27/118-sprite-kit-tutorial-making-a-universal-app-part-1/"/>
    <updated>2013-10-27T20:30:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/27/118-sprite-kit-tutorial-making-a-universal-app-part-1</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/10/24.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/49695/sprite-kit-tutorial-making-a-universal-app-part-1"><code>Sprite Kit Tutorial: Making a Universal App: Part 1</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#msgs">UI规划：概述</a></li>
<li><a href="#msxj">UI规划：小结</a></li>
<li><a href="#ks">开始</a></li>
<li><a href="#wltj">纹理图集</a></li>
<li><a href="#bjsb">背景设置</a></li>
<li><a href="#asfz">鼹鼠的放置</a></li>
<li><a href="#tcas">弹出鼹鼠</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p>本文将介绍如何制作一个通用程序(打鼹鼠的游戏)——可以在iPhone和iPad上运行(包括retina显示的支持。)</p>

<p>学习本文之前，需要掌握以下知识：</p>

<p><a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p><a href="http://beyondvincent.com/blog/2013/10/16/115-spritekit-tutorial-animations-and-texture-atlases-1/"><code>Sprite Kit教程：动画和纹理图集 1</code></a>
<a href="http://beyondvincent.com/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2/"><code>Sprite Kit教程：动画和纹理图集 2</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<p><a href="http://beyondvincent.com/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites/"><code>Sprite Kit教程：如何拖放Sprites</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/44270/sprite-kit-tutorial-how-to-drag-and-drop-sprites"><code>Sprite Kit Tutorial: How To Drag and Drop Sprites</code></a></p>

<p>如果还没有看上面的这些文章(或者相关的知识)，建议你先去看一下。</p>

<p>本文会有两篇文章。第一篇，会先创建一个基本的游戏——可爱的小鼹鼠聪洞里面弹出来。为了让游戏在iPhone和iPad(支持retina显示)上看起来很优美，本文还花了大量的时间来考虑如何做游戏的美术规划和坐标。</p>

<h3><a id="msgs"></a>UI规划：概述</h3>

<p>我们希望程序可以在iPhone 3.5英寸，4英寸(iPhone 5)和iPad上良好的运行，所以在开始之前，我们需要认真的做好UI规划。</p>

<p>为了搞明白需要什么样的UI尺寸，我们先来看看下面的相关内容：</p>

<ul>
<li>Retina显示</li>
<li>4英寸iPhone显示</li>
<li>iPad和iPhone长宽比</li>
</ul>


<p>下面开始吧！</p>

<h4><code>Retina显示</code></h4>

<p>在iPhone中，non-retina和retina在显示上的最大区别就是retina的分辨率是non-retina的2倍。所以在non-retina上面分辨率为 480 * 320(landscape)，而retina则是960 * 640.</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/26.jpg" alt="" /></p>

<p>同样iPad也分为non-retina和retina，它们的分辨率相差也为2倍，non-retina显示的分辨率是1024 * 768像素，而retina上面则是2048 * 1536像素！</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/27.jpg" alt="" /></p>

<p>稍等，你可能在想：双倍分辨率岂不是打乱了所有已经写好的程序，例如iPhone上的480 * 320和iPad的1024 * 768？这是有可能的，除非是在Sprite Kit中设置尺寸或者坐标，此时实际上是在UIKit中进行设置，并且设置的尺寸单位叫做<code>points</code>，而不是像素(pixels)。</p>

<p>在non-retina显示上，无论是iPhone火iPad，一个point代表一个pixel，而在retina上面，一个point代表2个pixels。所以将位置设置为(10,10)point时，non-retina上将是(10,10)，而retina上则是(20,20)，所以它们依然会显示在相同的偏移量上。不错吧！</p>

<p>当使用苹果提供的控件或者Core Graphics时，苹果已经写好了相关代码，让它们在retina显示起来很好看。</p>

<p>唯一需要注意的就是关于使用的图片。比如在iPhone或iPad程序中又一个200 * 200d 图片。如果什么事情都不做的话，在retina上面会自动的将这个图片放大两倍——这看起来不是太好，因为我们并没有提供相关分辨率的图片。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/28.jpg" alt="" /></p>

<p>因此针对retina显示我们需要提供所有图片的另外一个版本，也就是说需要一个普通的版本，以及另外2倍分辨率的一个版本。如果将2倍分辨率图片命名为&#8221;@2x&#8221;后缀，那么当利用[SKSpriteNode spriteNodeWithImageNamed:&hellip;]或者类似的APIs加载sprite时，它会自动的将@2x图片加载到retina显示上。</p>

<p>所以在开发针对retina显示的Sprite Kit游戏时也很简单——只需要添加@2x的图片，基本上就搞定了。</p>

<h4><code>4英寸iPhone显示</code></h4>

<p>iPhone 5设备在屏幕上显示的分辨率比以前的更大了，对于游戏显示上来说，这非常的好。本文中的处理很简单，只需要将背景图片做一个扩展延伸即可。</p>

<p>iPhone 5的分辨率是1136 * 640——宽高比为16:9。用point来衡量的话则是568 * 320.</p>

<h3><code>iPad和iPhone的宽高比</code></h3>

<p>上面我们已经看到要处理retina显示很容易，但是要想创建一个通用的程序呢(可以运行在iPhone和iPad设备上)。</p>

<p>其实要想创建一个通用的程序还真有一个麻烦的事情——iPhone和iPad的宽高比不一样！</p>

<p>iPhone的比例是1.5(480 * 320 或960 * 640)，而iPad是1.33(768 * 1024或1536 * 2048)。</p>

<p>由于比例不同，如果一副能够在non-retina iPad(768×1024)上完整显示，你希望将其在iPhone上重用，那么不会完整的匹配上，如果将其缩放，按照宽度进行适配(乘以0.9375)，会得到720×960的尺寸，这样就会把高度剪切掉一部分。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/29.jpg" alt="" /></p>

<p>发生这种情况会让人比较烦恼，我们不仅需要处理背景图片的问题，不同的宽高比导致不同设备间使用相同的坐标比较困难。</p>

<p>下面是我了解到的一些对应的处理方法：</p>

<ul>
<li>在3.5英寸的iPhone retina显示屏幕正中间确定一个<code>可玩区域</code>。这样剩下的区域可以用一个背景图片来覆盖，不要让玩家关注这一剩下的区域。这样一来在不同设备间进行左边的转换和重用要非常方便。本文将利用这种方法。</li>
<li>让iPad显示内容的宽高比设置为跟iPhone一样：左右留出32points的边距，上下留出64point的边距，此时在正中间的区域就是1024×768 points。这样只要让游戏程序的内容显示在这1024×768的范围内，就可以在每个设备间对图片进行缩放了。</li>
<li>由于pixel和point是有区别的。那么我们就创建出iPad retina显示的图片(536×2048 px)，然后将该图片除以2，这样也就可以用于non-retina iPad显示了！</li>
</ul>


<h3><code>iOS 模拟器选项</code></h3>

<p>下面这些模拟器可以运行iOS 7：</p>

<ul>
<li>iPhone Retina (3.5-inch) – iPhone 4 和 4S</li>
<li>iPhone Retina (4-inch) – iPhone 5, 5C, 和 5S</li>
<li>iPad – iPad 1, 2, 和 Mini</li>
<li>iPad Retina – iPad 3 和 4</li>
</ul>


<p>注意：这里并没有non-retina iPhone——因为没有任何一台no-retina iPhone或iPod touch可以运行iOS 7。</p>

<p>另外由于Sprite Kit是在iOS 7中才引入的，所以就不用考虑no-retina iPhone或iPod touch设备了。</p>

<h3><a id="msxj"></a>UI规划：小结</h3>

<p>基于上面的一些讨论，下面是本文的相关计划：</p>

<ul>
<li>UI设计的范围(可玩区域)在960×640范围内，在retina iPhone(3.5英寸)中全屏显示，4英寸iPhone，iPad和retina iPad中居中显示。</li>
<li>可用的UI元素放置在纹理图集文件中。@2x表示用于iPad retina显示的图片。</li>
<li>由于需要全屏显示，所以背景图片是一个特例。创建一个1024x768 point尺寸的图片，这样可以完全显示在iPad中。并且这个图片可以缩放显示在3.5英寸的iPhone上，只不过背景图中的有些内容不能显示出来，但是这关系并不太大。</li>
<li>4英寸的iPhone将通过代码来使用<code>-568</code>的纹理图集，并将其<code>可玩区域</code>居中。</li>
<li>iPad和iPad retina通过代码使用<code>-ipad</code>的纹理图集，并将其坐标转换到<code>可玩区域</code>中，另外在使用适当的字体大小等。</li>
</ul>


<p>来这里可以下载到本文的<a href="http://cdn4.raywenderlich.com/downloads/WhackAMoleSKArt.zip">UI资源</a>。解压出下载到的文件，可以看到如下一些内容：</p>

<ul>
<li>在TextureAtlases中又3个文件夹。每个文件夹中的UI元素针对不同的显示(3.5英寸iPhone, 4英寸iPhone, 和 iPad)。</li>
<li>iPad纹理图集文件夹中包含的图片是针对non-retina和retina iPad的。</li>
<li>在foreground文件夹中，有两个前景图片(下部和上部的图片)。被分为了两部分，这样可以将鼹鼠放置在下部和上部，看起来鼹鼠就像到地下了一样。</li>
<li>4英寸的iPhone是另外一个特列。因此在这里另外构建了新的前景图，以利用上更多的空间。</li>
<li>在background文件夹中，虽然iPad的宽高比是1.33，但这里做的背景图宽高比为一半,这样做是因为背景图片基本上可以忽略不计（只是3个鼹鼠洞）。所以不值得在这上面耗费，因为只需要用小纹理的图片替代即可，在需要放大的时候放大一下。</li>
<li>在sprite文件夹中，所有的sprite尺寸都适合显示在960×640大小的可玩区域中。注意，这里有一个鼹鼠和两个相关动画(鼹鼠笑和被打)。</li>
</ul>


<p>上面搞了这么多，现在终于可以开始了！</p>

<h3><a id="ks"></a>开始</h3>

<p>打开Xcode，选择File > New > Project…，然后选中Sprite Kit Game并单击Next。将工程命名为WhackAMole，devices选中universal，接着再单击Next。选择一个路径来保存工程，然后单击Create。</p>

<p>当工程打开之后，应该能看到Project Navigator中的工程文件已经被选中了，如果没有选中，那么将其选中，然后在target中选中WhackAModle，以及选中顶部的General，在Deployment info里面可以看到一些设备朝向的勾选框。在这里我们的游戏是landscape的，所以勾选上iPhone和iPad的Landscape Left和Landscape Right。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/30.png" alt="" /></p>

<p>另外，为了让朝向正确，还需要对代码做一些修改。打开ViewController.m文件并用下面的viewWillLayoutSubviews:方法替换viewDidLoad方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillLayoutSubviews</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewWillLayoutSubviews</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Configure the view.</span>
</span><span class='line'>    <span class="n">SKView</span> <span class="o">*</span> <span class="n">skView</span> <span class="o">=</span> <span class="p">(</span><span class="n">SKView</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skView</span><span class="p">.</span><span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">skView</span><span class="p">.</span><span class="n">showsFPS</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="n">skView</span><span class="p">.</span><span class="n">showsNodeCount</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Create and configure the scene.</span>
</span><span class='line'>        <span class="n">SKScene</span> <span class="o">*</span> <span class="n">scene</span> <span class="o">=</span> <span class="p">[</span><span class="n">MyScene</span> <span class="nl">sceneWithSize:</span><span class="n">skView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">];</span>
</span><span class='line'>        <span class="n">scene</span><span class="p">.</span><span class="n">scaleMode</span> <span class="o">=</span> <span class="n">SKSceneScaleModeAspectFill</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Present the scene.</span>
</span><span class='line'>        <span class="p">[</span><span class="n">skView</span> <span class="nl">presentScene:</span><span class="n">scene</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么要这样做呢？默认情况下View Controller views是以竖直的方式加载，所以横屏模式下，当viewDidLoad被调用的时候不能保证尺寸是正确的，不过当viewWillLayoutSubviews被调用的时候view的size将是正确的。如上代码所示，大多数代码与viewdidLoad中的相同。需要关注的就是if语句中关于skView.scene的配置。当然在这里需要判断一下skView.scene是否已经存在(viewWillLayoutSubviews方法可能会被多次调用)。</p>

<h3><a id="wltj"></a>纹理图集</h3>

<p>纹理图集的配置非常简单。首选创建一个文件夹并且文件名已<code>.atlas</code>结尾。接着将那些UI元素拷贝到这个文件夹里面。然后在Xcode工程中添加这个文件夹即可！</p>

<p>简单吧！当在编译程序的时候，Xcode会把<code>.atlas</code>结尾的文件夹中的图片生成纹理图集。</p>

<p>注意：添加到<code>.atlas</code>文件夹中的图片尺寸不能超过2048×2048 pixels，否则会出错——2048×2048 pixels是自动生成纹理图集的最大尺寸。</p>

<p>下面看看具体如何做。找到之前下载的压缩文件，在压缩文件中有一个名为TextureAtlases的文件夹。这个文件夹中包含了3中设备类型的UI元素(iPad, iPhone, 和 WidescreeniPhone)。这些文件家中都包含有<code>.atlas</code>文件夹。我们将TextureAtlases文件夹拖至工程中，确保勾选上<code>Copy items into destination group’s folder (if needed)</code>。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/31.png" alt="" /></p>

<p>本文中为了让一切变得简单点，我们为每种类型的设备准备了一套纹理图集(iPhone 3.5-inch, iPhone 4-inch 和 iPads)。在iPhone 4英寸中可以重用iPhone3.5英寸中的一些纹理图集，</p>

<h3><a id="bjsb"></a>背景设置</h3>

<p>在开始修改scene中显示内容之前，我们需要添加一个宏以及一个helper方法。打开MyScene.m文件，并在文件的头部添加如下一行代码(在#import下面)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#define IS_WIDESCREEN ( fabs( ( double )[ [ UIScreen mainScreen ] bounds ].size.height - ( double )568 ) &lt; DBL_EPSILON )</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个宏可以判断程序是否允许在4英寸的屏幕中，该宏将被用在helper方法中，如果要了解上面宏的详细内容，<a href="http://stackoverflow.com/questions/12446990/how-to-detect-iphone-5-widescreen-devices">看这里</a>。</p>

<p>接着添加一个helper方法——为运行程序的设备获取正确的SKTextureAtla。这个方法接收一个文件名，并在文件名尾部添加一个正确的标示符，然后返回正确的一个SKTextureAtla。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">SKTextureAtlas</span> <span class="o">*</span><span class="p">)</span><span class="nf">textureAtlasNamed:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">fileName</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UI_USER_INTERFACE_IDIOM</span><span class="p">()</span> <span class="o">==</span> <span class="n">UIUserInterfaceIdiomPhone</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">IS_WIDESCREEN</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// iPhone Retina 4-inch</span>
</span><span class='line'>            <span class="n">fileName</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@-568&quot;</span><span class="p">,</span> <span class="n">fileName</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// iPhone Retina 3.5-inch</span>
</span><span class='line'>            <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fileName</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;%@-ipad&quot;</span><span class="p">,</span> <span class="n">fileName</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKTextureAtlas</span> <span class="o">*</span><span class="n">textureAtlas</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKTextureAtlas</span> <span class="nl">atlasNamed:</span><span class="n">fileName</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">textureAtlas</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码做了些什么？</p>

<ul>
<li>首选判断设备是否为一台iPhone。</li>
<li>如果是一台iPhone，然后利用之前定义的IS_WIDESCREEN宏判断是否为4英寸显示屏。如果是的话，就在文件名尾部添加<code>-568</code>。</li>
<li>如果设备是iPad或iPad retina，那么在文件尾部添加<code>-ipad</code>。</li>
<li>根据文件名创建并返回一个新的SKTextureAtlas。</li>
</ul>


<p>接着找到initWithSize:方法。移除掉设置背景颜色和创建Hell World lable的6行代码，然后用下面的代码替换之：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Add background</span>
</span><span class='line'><span class="n">SKTextureAtlas</span> <span class="o">*</span><span class="n">backgroundAtlas</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">textureAtlasNamed:</span><span class="s">@&quot;background&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">dirt</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="p">[</span><span class="n">backgroundAtlas</span> <span class="nl">textureNamed:</span><span class="s">@&quot;bg_dirt&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="n">dirt</span><span class="p">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</span><span class='line'><span class="n">dirt</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">),</span> <span class="n">CGRectGetMidY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'><span class="n">dirt</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">dirt</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Add foreground</span>
</span><span class='line'><span class="n">SKTextureAtlas</span> <span class="o">*</span><span class="n">foregroundAtlas</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">textureAtlasNamed:</span><span class="s">@&quot;foreground&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">upper</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="p">[</span><span class="n">foregroundAtlas</span> <span class="nl">textureNamed:</span><span class="s">@&quot;grass_upper&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="n">upper</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">);</span>
</span><span class='line'><span class="n">upper</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">),</span> <span class="n">CGRectGetMidY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'><span class="n">upper</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">upper</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">lower</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="p">[</span><span class="n">foregroundAtlas</span> <span class="nl">textureNamed:</span><span class="s">@&quot;grass_lower&quot;</span><span class="p">]];</span>
</span><span class='line'><span class="n">lower</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
</span><span class='line'><span class="n">lower</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">),</span> <span class="n">CGRectGetMidY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'><span class="n">lower</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">lower</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Add more here later...</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们来看看上面的代码都做了什么。</p>

<ul>
<li><code>Add background</code> 这部分代码使用之前的helper方法创建一个背景纹理图集。接着从背景纹理图集中构建一个dirt sprite。最后将其缩小2倍，并将其添加到scene正中间。将其缩小的目的是为了节省空间。</li>
<li><code>Add foreground</code> 这部分代码跟上面background中的十分相似，只不过这两个foreground sprite在同一个纹理图集中罢了。这里用了一种方便的方法来放置图片：设置anchor point(顶部图片设置middle/bottom，底部图片设置middle/top)。这种方法不需要做复杂的数学运算，就能在所有的设备上做出正确的显示。另外需要注意的是iPhone上的背景图片有一部分将不会显示出来，不过在这里并没有太大的影响。另外需要留意的是设置了图片的zPosition值，这样可以确保图片的正确排序。</li>
<li><code>SKSpriteNode的zPosition属性</code> 这个数学用来决定每个sprite在scene所处层次的位置。可以将其看做一个蛋糕，其中dirt sprite处于最底层，所以使用最小的一个值。添加别的层时增加相应的值，所以上半部分前景图设置为1，而下半部分设置为3，那么2呢？这个值是留给鼹鼠的——因为鼹鼠将出现在上部前景图上面，而在下部前景图后面。</li>
</ul>


<p>在运行程序之前，再做一点清理工作。找到touchesBegan:方法，并将其删除掉。</p>

<p>编译并运行程序，现在可以看到屏幕上显示出了背景图和前景图！并且在iPhone和iPad模拟器中运行，也能正确的显示！如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/32.png" alt="" /></p>

<h3><a id="asfz"></a>鼹鼠的放置</h3>

<p>在这个游戏中，我们将添加3个鼹鼠到scene中——上图中的每个洞放一个。鼹鼠默认是在地下的，偶尔会弹出来，当弹出来时，我们可以打击它们。</p>

<p>首先我们先将鼹鼠放到每个洞中。为了确保鼹鼠位置的正确，最好先把鼹鼠显示在最上面，等调好位置之后，在将其放到后台去。</p>

<p>打开MyScene.h文件，并按照如下代码进行修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;SpriteKit/SpriteKit.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="nc">MyScene</span> : <span class="nc">SKScene</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">moles</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">strong</span><span class="p">,</span> <span class="n">nonatomic</span><span class="p">)</span> <span class="n">SKTexture</span> <span class="o">*</span><span class="n">moleTexture</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码添加了一个SKTexture和一个数组。创建鼹鼠的时候会用到SKTexture，创建好的每个鼹鼠会被添加到数组中，这样方便之后循环获得每个鼹鼠。</p>

<p>在添加鼹鼠之前，首先定位到MyScene.m的顶部，并将下面这行代码添加到<code>@implementation MyScene</code>之前。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">const</span> <span class="kt">float</span> <span class="n">kMoleHoleOffset</span> <span class="o">=</span> <span class="mf">155.0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个float类型的常量，用来对鼹鼠进行定位。</p>

<p>接着，将如下代码添加到initWithSize:方法最后面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Load sprites</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">moles</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="n">SKTextureAtlas</span> <span class="o">*</span><span class="n">spriteAtlas</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">textureAtlasNamed:</span><span class="s">@&quot;sprites&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">moleTexture</span> <span class="o">=</span> <span class="p">[</span><span class="n">spriteAtlas</span> <span class="nl">textureNamed:</span><span class="s">@&quot;mole_1.png&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="kt">float</span> <span class="n">center</span> <span class="o">=</span> <span class="mf">240.0</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">UI_USER_INTERFACE_IDIOM</span><span class="p">()</span> <span class="o">==</span> <span class="n">UIUserInterfaceIdiomPhone</span> <span class="o">&amp;&amp;</span> <span class="n">IS_WIDESCREEN</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">center</span> <span class="o">=</span> <span class="mf">284.0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">mole1</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="n">self</span><span class="p">.</span><span class="n">moleTexture</span><span class="p">];</span>
</span><span class='line'><span class="n">mole1</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">convertPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">kMoleHoleOffset</span><span class="p">,</span> <span class="mf">85.0</span><span class="p">)];</span>
</span><span class='line'><span class="n">mole1</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">999</span><span class="p">;</span>
</span><span class='line'><span class="n">mole1</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Mole&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">mole1</span><span class="p">.</span><span class="n">userData</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">mole1</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">moles</span> <span class="nl">addObject:</span><span class="n">mole1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">mole2</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="n">self</span><span class="p">.</span><span class="n">moleTexture</span><span class="p">];</span>
</span><span class='line'><span class="n">mole2</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">convertPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="mf">85.0</span><span class="p">)];</span>
</span><span class='line'><span class="n">mole2</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">999</span><span class="p">;</span>
</span><span class='line'><span class="n">mole2</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Mole&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">mole2</span><span class="p">.</span><span class="n">userData</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">mole2</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">moles</span> <span class="nl">addObject:</span><span class="n">mole2</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">mole3</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="n">self</span><span class="p">.</span><span class="n">moleTexture</span><span class="p">];</span>
</span><span class='line'><span class="n">mole3</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">convertPoint:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">kMoleHoleOffset</span><span class="p">,</span> <span class="mf">85.0</span><span class="p">)];</span>
</span><span class='line'><span class="n">mole3</span><span class="p">.</span><span class="n">zPosition</span> <span class="o">=</span> <span class="mi">999</span><span class="p">;</span>
</span><span class='line'><span class="n">mole3</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Mole&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">mole3</span><span class="p">.</span><span class="n">userData</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSMutableDictionary</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">mole3</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">moles</span> <span class="nl">addObject:</span><span class="n">mole3</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码首先创建并加载一个SKTextureAtlas。接着根据sprite纹理图集中的mole_1.png 创建一个SKTexture，这将用来创建3个鼹鼠。Texture的重用性可以让Sprite Kit处理和渲染sprite更加高效。</p>

<p>接下来的这个值用来设置center。如果设备是4英寸的iPhone，那么这个center值将反映出额外的尺寸。</p>

<p>接着为每个鼹鼠创建对应的sprite，并将它们放置到scene中，还把它们添加到鼹鼠数组中。注意，每个鼹鼠的位置是利用center位置和文件头部定义的常量决定的。针对iPhone 3.5英寸的设备，鼹鼠位置处在480×320的可玩区域，而如何是iPad，相关位置需要做转换，所以下面写了一个helper方法convertPoint。</p>

<p>将下面这个方法添加到initWithSize:方法后面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nf">convertPoint:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">point</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">UI_USER_INTERFACE_IDIOM</span><span class="p">()</span> <span class="o">==</span> <span class="n">UIUserInterfaceIdiomPad</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="mi">32</span> <span class="o">+</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="mi">64</span> <span class="o">+</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">point</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个方法将可玩区域的point转换到iPad上适当的位置。记住：</p>

<ul>
<li>iPad的屏幕尺寸更大，所有的point都是双倍。</li>
<li>由于是将960×640的区域转换为1024×786的iPad区域，所以需要将左右边距分别设置为32point，而上下边距则各位64。</li>
</ul>


<p>就这样，上面的方法就是简单的给出iPad中正确的位置。</p>

<p>编译并运行程序，可以看到scene中有3个鼹鼠，它们的位置已经设置正确！你最好在iPhone 3.5-inch, iPhone 4-inch, iPad, 和 iPad Retina设备上都运行一下，以确保位置的正确。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/33.png" alt="" /></p>

<h3><a id="tcas"></a>弹出鼹鼠</h3>

<p>至此，我们已经把鼹鼠放置好了，下面我们添加一些代码让鼹鼠从洞里面跳出来吧。</p>

<p>首先，将这些sprite(鼹鼠)的zPosition从999设置为2，这样就可以把鼹鼠藏起来了。</p>

<p>然后，将下面的代码添加到update:方法中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">mole</span> <span class="k">in</span> <span class="n">self</span><span class="p">.</span><span class="n">moles</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">arc4random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mole</span><span class="p">.</span><span class="n">hasActions</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="nl">popMole:</span><span class="n">mole</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是每帧的显示都会调用update方法。该方法被调用的时候我们都会尝试着弹出一些鼹鼠。在代码中循环遍历处理了每个鼹鼠，并给每个鼹鼠1/3的机会从洞中弹出来。不过记住我们只能弹出那么还没有弹出来的鼹鼠——很简单的一个判断方法就是检查一下sprite的属性hasActions返回的值，如果还有action在运行，那么hasActions将返回YES。</p>

<p>接着，实现一下popMole方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">popMole:</span><span class="p">(</span><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="p">)</span><span class="nv">mole</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveUp</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">mole</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>    <span class="n">easeMoveUp</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">easeMoveDown</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveToY:</span><span class="n">mole</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="nl">duration:</span><span class="mf">0.2f</span><span class="p">];</span>
</span><span class='line'>    <span class="n">easeMoveDown</span><span class="p">.</span><span class="n">timingMode</span> <span class="o">=</span> <span class="n">SKActionTimingEaseInEaseOut</span><span class="p">;</span>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">delay</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">waitForDuration:</span><span class="mf">0.5f</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">easeMoveUp</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">easeMoveDown</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">mole</span> <span class="nl">runAction:</span><span class="n">sequence</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码使用了Sprite Kit中的一些action，让鼹鼠弹出洞来，并暂停半秒钟，然后在弹回去。我们来细看一下上面代码的意思：</p>

<ol>
<li>创建一个action来将鼹鼠沿着Y轴移动鼹鼠高度的距离，这样就能将鼹鼠正好放置到洞上面。</li>
<li>为了让移动行为看起来更自然一点，将action的timingMode设置为SKActionTimingEaseInEaseOut。这样可以让action在开始和结束时速度慢一点，这样鼹鼠看起来会有加速和减速的效果，看起来就会更自然一点了。</li>
<li>创建一个action将鼹鼠移回原处，这个action跟上一个类似，只不过使用鼹鼠当前Y轴的位置。</li>
<li>创建一个action，该action会让鼹鼠停留在洞口半秒钟。</li>
<li>按顺序运行这些action：move up，delay和move down。</li>
</ol>


<p>搞定！编译并运行程序，可以看到鼹鼠会从它们的洞口弹出来！</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/34.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn3.raywenderlich.com/downloads/WhackAMoleSK1.zip">这里</a>。</p>

<p>下一篇文章<code>Sprite Kit教程：制作一个通用程序 2</code>中会给鼹鼠添加一些可爱的动画(笑和被击中)，并添加一个玩法——打击鼹鼠，并赚取点数，并添加一些音效。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：如何拖放Sprites]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites/"/>
    <updated>2013-10-20T23:44:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/20/117-spritekit-tutorial-how-to-drag-and-drop-sprites</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/10/14.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/44270/sprite-kit-tutorial-how-to-drag-and-drop-sprites"><code>Sprite Kit Tutorial: How To Drag and Drop Sprites</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#ks">开始</a></li>
<li><a href="#xzjs">用触摸的方式选中sprite</a></li>
<li><a href="#ydjl">用触摸的方式移动sprite和layer</a></li>
<li><a href="#sssb">在Sprite Kit中如何使用手势识别</a></li>
<li><a href="#hqhc">何去何从</a></li>
</ul>


<p>本文中，你可以学到如下内容：</p>

<ul>
<li>利用触摸来拖放sprite的基本知识</li>
<li>利用触摸滚动view</li>
<li>How to keep coordinates straight in your head</li>
<li>如何在Sprite Kit中使用手势识别</li>
</ul>


<p>为了让本文有趣一点，这里提供了一些可爱的动物图片。</p>

<p>本文假设你已经了解了Sprite Kit的一些基本知识。如果还不了解的话，先看看下面的文章吧：</p>

<p><a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>下面我们就开始吧。</p>

<h3><a id="ks"></a>开始</h3>

<p>在实现触摸处理之前，我们先来创建一个基本的Sprite Kit工程，并在scene中显示出一些sprite(动物)和背景。</p>

<p>打开Xcode，选择<code>File\New Project\Application\SpriteKit Game</code>，然后单击<code>Next</code>。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/15.png" alt="" /></p>

<p>将工程命名为<code>DragDrop</code>，devices选择<code>iPhone</code>，然后单击<code>Next</code>，把工程保存到磁盘中。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/16.png" alt="" /></p>

<p>跟<a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>一样，我们希望这个程序只支持横屏显示(landscape)。所以在<code>Project Navigator</code>中选中<code>DragDrop</code>工程，然后选择<code>DragDrop</code> target，在弹出的画面中，只需要勾选上<code>Landscape Left</code>和<code>Landscape Right</code>。如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/17.png" alt="" /></p>

<p>打开<code>ViewController.m</code>文件，并用下面的代码替换<code>viewDidLoad</code>方法(代码跟之前的一样)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewWillLayoutSubviews</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">super</span> <span class="n">viewWillLayoutSubviews</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Configure the view.</span>
</span><span class='line'>    <span class="n">SKView</span> <span class="o">*</span> <span class="n">skView</span> <span class="o">=</span> <span class="p">(</span><span class="n">SKView</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skView</span><span class="p">.</span><span class="n">scene</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">skView</span><span class="p">.</span><span class="n">showsFPS</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>      <span class="n">skView</span><span class="p">.</span><span class="n">showsNodeCount</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Create and configure the scene.</span>
</span><span class='line'>      <span class="n">SKScene</span> <span class="o">*</span> <span class="n">scene</span> <span class="o">=</span> <span class="p">[</span><span class="n">MyScene</span> <span class="nl">sceneWithSize:</span><span class="n">skView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">];</span>
</span><span class='line'>      <span class="n">scene</span><span class="p">.</span><span class="n">scaleMode</span> <span class="o">=</span> <span class="n">SKSceneScaleModeAspectFill</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// Present the scene.</span>
</span><span class='line'>      <span class="p">[</span><span class="n">skView</span> <span class="nl">presentScene:</span><span class="n">scene</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>接着来这里下载本文需要用到的<a href="http://d1xzuxjlafny7l.cloudfront.net/downloads/DragDropImages.zip">图片资源</a>。下载并解压之后，将所有的文件拖到工程中，其中把<code>Copy items into destination group’s folder (if needed)</code>勾选上，然后单击<code>Finish</code>。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/18.png" alt="" /></p>

<p>完成上面的步骤之后，打开<code>MyScene.m</code>文件，并在<code>@implementation</code>上面添加一个class extension，并声明两个属性，如下所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">MyScene</span> <span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">background</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span> <span class="n">strong</span><span class="p">)</span> <span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">selectedNode</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>稍后会用到上面的这两个属性来存储背景图片，已经当前选中的node/sprite。接着在@interface前面添加如下这行代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">kAnimalNodeName</span> <span class="o">=</span> <span class="s">@&quot;movable&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>稍后将会用这个字符串来标示可移动的node。接着找到<code>initWithSize:</code>方法，并用下面的代码替换里面的内容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="nv">size</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithSize:</span><span class="n">size</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 1) Loading the background</span>
</span><span class='line'>        <span class="n">_background</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithImageNamed:</span><span class="s">@&quot;blue-shooting-stars&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_background</span> <span class="nl">setName:</span><span class="s">@&quot;background&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_background</span> <span class="nl">setAnchorPoint:</span><span class="n">CGPointZero</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">_background</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 2) Loading the images</span>
</span><span class='line'>        <span class="n">NSArray</span> <span class="o">*</span><span class="n">imageNames</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="s">@&quot;bird&quot;</span><span class="p">,</span> <span class="s">@&quot;cat&quot;</span><span class="p">,</span> <span class="s">@&quot;dog&quot;</span><span class="p">,</span> <span class="s">@&quot;turtle&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">[</span><span class="n">imageNames</span> <span class="n">count</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">NSString</span> <span class="o">*</span><span class="n">imageName</span> <span class="o">=</span> <span class="p">[</span><span class="n">imageNames</span> <span class="nl">objectAtIndex:</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>          <span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">sprite</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithImageNamed:</span><span class="n">imageName</span><span class="p">];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">sprite</span> <span class="nl">setName:</span><span class="n">kAnimalNodeName</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>          <span class="kt">float</span> <span class="n">offsetFraction</span> <span class="o">=</span> <span class="p">((</span><span class="kt">float</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">([</span><span class="n">imageNames</span> <span class="n">count</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>          <span class="p">[</span><span class="n">sprite</span> <span class="nl">setPosition:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">offsetFraction</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">_background</span> <span class="nl">addChild:</span><span class="n">sprite</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们来看看上面的代码都干了什么。</p>

<p>1) 加载背景图片</p>

<p>上面方法中的第一部分代码是为scene加载背景图片(blue-shooting-stars.png)。并将该note的anchor设置为图片的左下角(0, 0)。</p>

<p>在Sprite Kit中，设置一个node的位置时，实际上是设置它的anchor。默认情况下，node的anchor被设置为node的正中间。在此，将anchor设置为左下角。</p>

<p>方法中，并没有设置背景图片的position，所以背景图的的位置默认为(0,0)。最终，图片的左下角位置是(0,0)，并向右边延伸。</p>

<p>2) 加载小动物</p>

<p>函数中接下来的代码是循环遍历列表中的图片，并将其加载到scene中。为了好的布局，其中各个node根据屏幕的长度来定位，另外还将这些node的名字设置为<code>kAnimalNodeName</code>。</p>

<p>之后将创建好的node添加到<code>_background</code>中。</p>

<p>OK！编译并运行程序，会看到屏幕中已经显示出了一些可爱的动物了。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/19.png" alt="" /></p>

<h3><a id="xzjs"></a>用触摸的方式选中sprite</h3>

<p>下面我们来实现一下根据用户当前触摸的位置判断出哪个sprite应该被选中。</p>

<p>用下面的代码替换<code>touchesBegan:withEvent:</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="p">[</span><span class="n">touches</span> <span class="n">anyObject</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">positionInScene</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInNode:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="nl">selectNodeForTouch:</span><span class="n">positionInScene</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先从touches set中获得touch。然后将touch的位置转换到一个指定node中的位置，上面的代码中使用了scene。让后将获得的方法传递给<code>selectNodeForTouch:</code>方法，该方法是一个新方法，下面我们就来看看这个方法的实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">selectNodeForTouch:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">touchLocation</span> <span class="p">{</span>
</span><span class='line'>   <span class="c1">//1</span>
</span><span class='line'>   <span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">touchedNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">SKSpriteNode</span> <span class="o">*</span><span class="p">)[</span><span class="n">self</span> <span class="nl">nodeAtPoint:</span><span class="n">touchLocation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">//2</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">_selectedNode</span> <span class="nl">isEqual:</span><span class="n">touchedNode</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">_selectedNode</span> <span class="n">removeAllActions</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">_selectedNode</span> <span class="nl">runAction:</span><span class="p">[</span><span class="n">SKAction</span> <span class="nl">rotateToAngle:</span><span class="mf">0.0f</span> <span class="nl">duration:</span><span class="mf">0.1</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">_selectedNode</span> <span class="o">=</span> <span class="n">touchedNode</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">//3</span>
</span><span class='line'>      <span class="k">if</span><span class="p">([[</span><span class="n">touchedNode</span> <span class="n">name</span><span class="p">]</span> <span class="nl">isEqualToString:</span><span class="n">kAnimalNodeName</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">SKAction</span> <span class="o">*</span><span class="n">sequence</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[[</span><span class="n">SKAction</span> <span class="nl">rotateByAngle:</span><span class="n">degToRad</span><span class="p">(</span><span class="o">-</span><span class="mf">4.0f</span><span class="p">)</span> <span class="nl">duration:</span><span class="mf">0.1</span><span class="p">],</span>
</span><span class='line'>                                                    <span class="p">[</span><span class="n">SKAction</span> <span class="nl">rotateByAngle:</span><span class="mf">0.0</span> <span class="nl">duration:</span><span class="mf">0.1</span><span class="p">],</span>
</span><span class='line'>                                                    <span class="p">[</span><span class="n">SKAction</span> <span class="nl">rotateByAngle:</span><span class="n">degToRad</span><span class="p">(</span><span class="mf">4.0f</span><span class="p">)</span> <span class="nl">duration:</span><span class="mf">0.1</span><span class="p">]]];</span>
</span><span class='line'>          <span class="p">[</span><span class="n">_selectedNode</span> <span class="nl">runAction:</span><span class="p">[</span><span class="n">SKAction</span> <span class="nl">repeatActionForever:</span><span class="n">sequence</span><span class="p">]];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个helper方法，它主要做三件不同的事情：</p>

<ol>
<li>通过scene(self)获得touchLocation位置对应的node。</li>
<li>获得匹配的node之后，检查一下这个node与上一次选中的node是否相同，如果相同的话，在这里直接就返回了。如果是一个新选中的node，或者还没有选中过，这个node会有一点小小的挪动动画，以此可以看出哪个node被选中了。不过在开始动画之前，需要移除当前已经选中node上的所有running actions，并在这个node上运行一个action：<code>rotateToAngle:duration:</code>。这样可以确保只有一个node在做动画，而另外的node恢复到原样。</li>
<li>这个if语句用来判断一下选中的node是否可以进行动画(只需要检查一下node的name就可以做出判断——还记得在<code>initWithSize:</code>方法中设置的这个属性值吗？)。如果选中的node可以做动画处理，那么就创建一个sequence action——是一个动画效果，就像在主屏幕中重排/删除程序那样的效果，然后在选中的node上运行这个sequence。为了避免动画运行完毕之后会停止，在这里运行了一个一直重复的action。</li>
</ol>


<p>下面将helper函数<code>degToRad</code>添加到文件的底部：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">float</span> <span class="nf">degToRad</span><span class="p">(</span><span class="kt">float</span> <span class="n">degree</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">degree</span> <span class="o">/</span> <span class="mf">180.0f</span> <span class="o">*</span> <span class="n">M_PI</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于Sprite Kit是利用弧度来做旋转效果的，所以上面这个方法将角度转换为弧度。</p>

<p>编译并运行程序，现在可以在屏幕上tap一个动物，当选中某个动物时，该动物会做出相应的动画效果，以表示被选中！</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/20.png" alt="" /></p>

<h3><a id="ydjl"></a>用触摸的方式移动sprite和layer</h3>

<p>下面来看看如何移动这些动物！基本思路是这样的：实现<code>touchesMoved:withEvent:</code>方法，计算出距离上一次触摸移动了多远，如果有动物被选中，动物将被移动相应的距离，如果没有选中动物，那么就移动整个layer，这样用户可以从左向右的滚动layer。</p>

<p>在添加代码之前，我们先来探讨一下在Sprite Kit中，一个node是如何滚动的。</p>

<p>看看下面的图片：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/21.png" alt="" /></p>

<p>如上图所示，我们已经初始化了一个背景，所以背景的anchor点是(0, 0)，并且向右边扩展。黑色框中的区域表示当前的可视区域(window的大小)。</p>

<p>如果希望将图片往右边滚动100 points，可以通过将整个node往左边移动100 points，如第二幅图看到的效果一样。</p>

<p>当然，也可能希望不要移动太远。例如，不应该让layer可以往右边移动，否则会看到空白的点。</p>

<p>下面来看看相应的代码！将如下方法添加到文件的底部：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nf">boundLayerPos:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">newPos</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGSize</span> <span class="n">winSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">newPos</span><span class="p">;</span>
</span><span class='line'>    <span class="n">retval</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">retval</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="n">retval</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">retval</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="p">[</span><span class="n">_background</span> <span class="n">size</span><span class="p">].</span><span class="n">width</span><span class="o">+</span> <span class="n">winSize</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
</span><span class='line'>    <span class="n">retval</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="n">position</span><span class="p">].</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">panForTranslation:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">translation</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">position</span> <span class="o">=</span> <span class="p">[</span><span class="n">_selectedNode</span> <span class="n">position</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span><span class="p">([[</span><span class="n">_selectedNode</span> <span class="n">name</span><span class="p">]</span> <span class="nl">isEqualToString:</span><span class="n">kAnimalNodeName</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_selectedNode</span> <span class="nl">setPosition:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">newPos</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">translation</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">_background</span> <span class="nl">setPosition:</span><span class="p">[</span><span class="n">self</span> <span class="nl">boundLayerPos:</span><span class="n">newPos</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个方法<code>boundLayerPos:</code>是为了确保不会将layer移动到背景图片范围之外。在这里传入一个需要移动到的位置，然后该方法会对位置做适当的判断处理，以确保不会移动太远。</p>

<p>接着方法<code>panForTranslation:</code>首先判断一下_selectedNode是否为动物node，如果是的话，根据传入的参数来为node设置新的位置。如果是background layer，同样也会设置一个新的位置，只不过新的位置需要调用<code>boundLayerPos:</code>方法获得。</p>

<p>完成上面之后，可以实现<code>touchesMoved:withEvent:</code>方法了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesMoved:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">UITouch</span> <span class="o">*</span><span class="n">touch</span> <span class="o">=</span> <span class="p">[</span><span class="n">touches</span> <span class="n">anyObject</span><span class="p">];</span>
</span><span class='line'>  <span class="n">CGPoint</span> <span class="n">positionInScene</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">locationInNode:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>  <span class="n">CGPoint</span> <span class="n">previousPosition</span> <span class="o">=</span> <span class="p">[</span><span class="n">touch</span> <span class="nl">previousLocationInNode:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">CGPoint</span> <span class="n">translation</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">positionInScene</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">previousPosition</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">positionInScene</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">previousPosition</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span> <span class="nl">panForTranslation:</span><span class="n">translation</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>跟<code>touchesBegan:withEvent:</code>一样，先获得touch，然后将它的位置转换为scene中的相应位置。为了计算出移动的距离，需要上一次触摸的位置。</p>

<p>通过当前位置减去上一次的位置就可以计算出需要移动的距离了。最后调用<code>panForTransaltion:</code>方法，并将移动距离传入即可。</p>

<p>搞定！编译并运行程序，现在可以通过拖放的方式移动sprite(以及layer)了！</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/22.png" alt="" /></p>

<h3><a id="sssb"></a>在Sprite Kit中如何使用手势识别</h3>

<p>在Sprite Kit中还可以使用手势识别来处理触摸！</p>

<p>手势识别可以识别不同的手势，如tap，double tap，swipe或pan。</p>

<p>通过手势识别，我们可以不用写大量的代码来识别不同的手势（如tap，double tap，swipe或pan），只需要创建一个手势识别对象并将其添加到view中，即可进行手势识别。当有手势发生，会有一个回调。</p>

<p>下面就来看看如何在Sprite Kit中使用手势识别。</p>

<p>首先，注释掉触摸处理方法：<code>touchesBegan:withEvent:</code>和<code>touchesMoved:withEvent:</code>(因为要使用不同的处理方法啦)。</p>

<p>然后添加如下方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didMoveToView:</span><span class="p">(</span><span class="n">SKView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="n">gestureRecognizer</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIPanGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget:</span><span class="n">self</span> <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">handlePanFrom:</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">self</span> <span class="n">view</span><span class="p">]</span> <span class="nl">addGestureRecognizer:</span><span class="n">gestureRecognizer</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当scene第一次显示出来时会调用这个方法。在上面的方法中创建了一个pan手势识别器，并用当前的scene来对其做初始化，另外还传入一个callback：<code>handlePanFrom:</code>。接着把这个手势识别器添加到scene中的view里面。</p>

<p>注意：可能你会问为什么要在这里添加识别器，而不是在scene的init方法中。答案很简单：<code>SKScene</code>有一个view属性，保存着SKView——该view用来显示scene，不过只有scene显示到屏幕中时这个属性才会被初始化，所以在init方法被调用时该属性是nil的。此处的<code>didMoveToView:</code>类似于UIKit中的<code>viewDidAppear:</code>，当scene显示出来时，<code>didMoveToView:</code>会被调用。</p>

<p>接着，将下面的代码添加到<code>MyScene.m</code>文件底部：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">handlePanFrom:</span><span class="p">(</span><span class="n">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="nv">recognizer</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">recognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateBegan</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">recognizer</span> <span class="nl">locationInView:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">convertPointFromView:</span><span class="n">touchLocation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">selectNodeForTouch:</span><span class="n">touchLocation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateChanged</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">CGPoint</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">recognizer</span> <span class="nl">translationInView:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>        <span class="n">translation</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">translation</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="nl">panForTranslation:</span><span class="n">translation</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">recognizer</span> <span class="nl">setTranslation:</span><span class="n">CGPointZero</span> <span class="nl">inView:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[[</span><span class="n">_selectedNode</span> <span class="n">name</span><span class="p">]</span> <span class="nl">isEqualToString:</span><span class="n">kAnimalNodeName</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">float</span> <span class="n">scrollDuration</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">;</span>
</span><span class='line'>            <span class="n">CGPoint</span> <span class="n">velocity</span> <span class="o">=</span> <span class="p">[</span><span class="n">recognizer</span> <span class="nl">velocityInView:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>            <span class="n">CGPoint</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">_selectedNode</span> <span class="n">position</span><span class="p">];</span>
</span><span class='line'>            <span class="n">CGPoint</span> <span class="n">p</span> <span class="o">=</span> <span class="n">mult</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">scrollDuration</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">CGPoint</span> <span class="n">newPos</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">pos</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>            <span class="n">newPos</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">boundLayerPos:</span><span class="n">newPos</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">_selectedNode</span> <span class="n">removeAllActions</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">SKAction</span> <span class="o">*</span><span class="n">moveTo</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveTo:</span><span class="n">newPos</span> <span class="nl">duration:</span><span class="n">scrollDuration</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">moveTo</span> <span class="nl">setTimingMode:</span><span class="n">SKActionTimingEaseOut</span><span class="p">];</span>
</span><span class='line'>            <span class="p">[</span><span class="n">_selectedNode</span> <span class="nl">runAction:</span><span class="n">moveTo</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当手势开始、改变(例如用户持续drag)，以及结束时，上面这个callback函数都会被调用。该方法会进入不同的case，以处理不同的情况。</p>

<p>当手势开始时，将坐标系统转换为node坐标系(注意这里没有便捷的方法，只能这样处理)。然后电泳之前写的helper方法<code>selectNodeForTouch:</code>。</p>

<p>当手势发生改变时，需要计算出手势移动的量。还在手势识别器已经为我们存储了手势移动的累计量(translation)！不过考虑到效果的差异，我们需要在UIKit坐标系和Sprite Kit坐标系中对坐标进行转换。</p>

<p>平移(pan)之后，需要把手势识别器上的translation设置为0，否则该值会继续被累加。</p>

<p>当手势结束之后，上面的函数中有一些有趣的代码！UIPanGestureRecognizer可以为我们提供一个移动的速度。通过这个速度可以对node做一个动画——滑动一小点，这样用户可以对node做一个快速的摇动，就像table view上的那种效果一样。</p>

<p>所以，在这里包含的代码用来计算基于速度移动的一个point，然后运行一个moveTo action(为了更加好看，附带<code>SKActionTimingEaseOut</code>效果)。</p>

<p>接着添加如下一个方法到文件中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGPoint</span> <span class="nf">mult</span><span class="p">(</span><span class="k">const</span> <span class="n">CGPoint</span> <span class="n">v</span><span class="p">,</span> <span class="k">const</span> <span class="n">CGFloat</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="o">*</span><span class="n">s</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面这个方法是将滚动的时间乘以速度。</p>

<p>编译并运行程序，现在应该可以用手势识别器滑动和移动动物了。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/23.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从</h3>

<p>本文的代码工程在<a href="http://cdn2.raywenderlich.com/downloads/DragDropSpriteKit.zip">这里</a>。</p>

<p>至此，你应该知道如何在Sprite Kit程序中使用touch来移动node，以及如何在Sprite Kit中使用手势识别器。</p>

<p>现在，你也可以尝试利用别的手势识别器对上面的工程做扩展处理，例如pinch或rotate手势识别器——可以让猫长大哦！</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：动画和纹理图集 2]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2/"/>
    <updated>2013-10-16T23:40:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/16/116-spritekit-tutorial-animations-and-texture-atlases-2</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/10/3.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li>创建一个工程</li>
<li>纹理图集和熊</li>
<li>一个简单的动画</li>
<li><a href="#gbfx">改变动画运动的方向</a></li>
<li><a href="#ydx">在屏幕上让熊移动</a></li>
<li><a href="#hqhc">何去何从?</a></li>
</ul>


<h3><a id="gbfx"></a>改变动画运动的方向</h3>

<p>看起来不错哦！下面我们就来看看如何通过触摸屏幕上的点来控制熊的运动方向。在<code>MyScene.m</code>文件中做如下改动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Add these new methods</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGPoint</span> <span class="n">location</span> <span class="o">=</span> <span class="p">[[</span><span class="n">touches</span> <span class="n">anyObject</span><span class="p">]</span> <span class="nl">locationInNode:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">multiplierForDirection</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//walk left</span>
</span><span class='line'>        <span class="n">multiplierForDirection</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">//walk right</span>
</span><span class='line'>        <span class="n">multiplierForDirection</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">_bear</span><span class="p">.</span><span class="n">xScale</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">_bear</span><span class="p">.</span><span class="n">xScale</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiplierForDirection</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">walkingBear</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码会根据tap的位置，让<code>touchesEnded</code>方法判断tap处于屏幕正中间的左边还是右边。通过该方法，决定熊的朝向。熊的方向是通过Sprite Kit来改变的(通过负值乘以xScale就可以让熊朝向左边。)</p>

<p>编译并运行程序，一切正常的话，当你在屏幕上点击时，会发现熊的朝向发生了改变。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/12.png" alt="" /></p>

<h3><a id="ydx"></a>在屏幕上让熊移动</h3>

<p>下面我们让熊可以移动到屏幕的各个位置。</p>

<p>在<code>MyScene.m</code>文件中做如下改动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Comment out the call to start the bear walking</span>
</span><span class='line'><span class="c1">//[self walkingBear];</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesEnded:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//Stuff from below!</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">touchesBegan:</span><span class="p">(</span><span class="n">NSSet</span> <span class="o">*</span><span class="p">)</span><span class="nv">touches</span> <span class="nf">withEvent:</span><span class="p">(</span><span class="n">UIEvent</span> <span class="o">*</span><span class="p">)</span><span class="nv">event</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//add this method</span>
</span><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">bearMoveEnded</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_bear</span> <span class="n">removeAllActions</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上所示，移除了<code>touchesEnded</code>方法中的所有代码。下面我们一步一步的往里面添加代码。</p>

<p>当想要停止动画的时可以调用方法<code>bearMoveEnded</code>。</p>

<p>下面就从<code>touchesEnded</code>方法开始吧：</p>

<p><code>1) 确定触摸的位置并定义一个变量代表熊的朝向</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGPoint</span> <span class="n">location</span> <span class="o">=</span> <span class="p">[[</span><span class="n">touches</span> <span class="n">anyObject</span><span class="p">]</span> <span class="nl">locationInNode:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="n">CGFloat</span> <span class="n">multiplierForDirection</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上代码，利用常见的一个方法将触摸的位置转换为node坐标系中的位置。</p>

<p><code>2) 设置速度</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CGSize</span> <span class="n">screenSize</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span><span class='line'><span class="kt">float</span> <span class="n">bearVelocity</span> <span class="o">=</span> <span class="n">screenSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上，定义了熊移动的速度。可知熊从移动长度为屏幕宽度这么长时，需要3秒钟。由于不同设备的屏幕宽度可能会不同，所以在这里使用了self.frame.size，所以熊的速度应该是屏幕宽度/3秒。</p>

<p><code>3) 计算出熊在X和Y轴中移动的量</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="n">CGPoint</span> <span class="n">moveDifference</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">_bear</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">location</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">_bear</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过简单的利用触摸位置减去熊的位置，计算出熊在X和Y轴上应该移动的距离。</p>

<p><code>4) 计算出实际的移动距离</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">float</span> <span class="n">distanceToMove</span> <span class="o">=</span> <span class="n">sqrtf</span><span class="p">(</span><span class="n">moveDifference</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">moveDifference</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">moveDifference</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">moveDifference</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码是计算出熊实际移动的直线距离(一个直角三角形的斜边：熊当前的位置和触摸位置)。关于游戏中涉及到的数学知识可以看看这本书：<a href="http://www.raywenderlich.com/35866/trigonometry-for-game-programming-part-1">Trigonometry for Game Programming</a>。</p>

<p><code>5) 计算出移动实际距离所需要花费的时间</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">float</span> <span class="n">moveDuration</span> <span class="o">=</span> <span class="n">distanceToMove</span> <span class="o">/</span> <span class="n">bearVelocity</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过移动的实际距离除以移动速度计算出需要花费的时间。</p>

<p><code>6) 需要的话对动画做翻转(Flip)处理</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">moveDifference</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">multiplierForDirection</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">multiplierForDirection</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">_bear</span><span class="p">.</span><span class="n">xScale</span> <span class="o">=</span> <span class="n">fabs</span><span class="p">(</span><span class="n">_bear</span><span class="p">.</span><span class="n">xScale</span><span class="p">)</span> <span class="o">*</span> <span class="n">multiplierForDirection</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码：确定熊往左还是往右移动。如果小于0，则往左移动，否则往右移动。</p>

<p>在这里，你的第一直觉可能是利用图片编辑器创建并使用对应另一个方向的图片。不过，之前我们学习过了如果通过乘法来改变sprite的xScale，进而改变sprite的方向。</p>

<p><code>7) 运行一些action</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">([</span><span class="n">_bear</span> <span class="nl">actionForKey:</span><span class="s">@&quot;bearMoving&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//stop just the moving to a new location, but leave the walking legs movement running</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_bear</span> <span class="nl">removeActionForKey:</span><span class="s">@&quot;bearMoving&quot;</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span> <span class="c1">//1</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">_bear</span> <span class="nl">actionForKey:</span><span class="s">@&quot;walkingInPlaceBear&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">//if legs are not moving go ahead and start them</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span> <span class="n">walkingBear</span><span class="p">];</span>  <span class="c1">//start the bear walking</span>
</span><span class='line'><span class="p">}</span> <span class="c1">//2</span>
</span><span class='line'>
</span><span class='line'><span class="n">SKAction</span> <span class="o">*</span><span class="n">moveAction</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">moveTo:</span><span class="n">location</span> <span class="nl">duration:</span><span class="n">moveDuration</span><span class="p">];</span>  <span class="c1">//3</span>
</span><span class='line'><span class="n">SKAction</span> <span class="o">*</span><span class="n">doneAction</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">runBlock:</span><span class="p">(</span><span class="n">dispatch_block_t</span><span class="p">)</span><span class="o">^</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Animation Completed&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">self</span> <span class="n">bearMoveEnded</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span> <span class="c1">//4</span>
</span><span class='line'>
</span><span class='line'><span class="n">SKAction</span> <span class="o">*</span><span class="n">moveActionWithDone</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKAction</span> <span class="nl">sequence:</span><span class="err">@</span><span class="p">[</span><span class="n">moveAction</span><span class="p">,</span><span class="n">doneAction</span><span class="p">]];</span> <span class="c1">//5</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">_bear</span> <span class="nl">runAction:</span><span class="n">moveActionWithDone</span> <span class="nl">withKey:</span><span class="s">@&quot;bearMoving&quot;</span><span class="p">];</span> <span class="c1">//6</span>
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>停止已有的移动action(因为要准备告诉熊移动到别的地方)。这里使用的key可以开始和停止以此命名的动画的运行。</li>
<li>如果熊还没有准备移动腿，那么就让熊的腿开始移动，否则它该如何走到新的位置呢。这里使用了我们之前使用过的方法，这个方法可以确保不启动一个已经运行着的动画(以key命名)。</li>
<li>创建一个移动action，并制定移动到何处，以及需要花费的时间。</li>
<li>创建一个done action，当熊到达目的地后，该action利用一个block调用一个方法来停止动画。</li>
<li>将上面的两个action设置为一个顺序action链，就是说让这两个action按照先后顺序运行(第一个运行完之后，再运行第二个)。</li>
<li>让熊开始运行action，并制定一个key为：&#8221;bearMoving&#8221;。记住，这里的key用来判断熊是否需要移动到新的位置。</li>
</ol>


<p>注意：Sprite Kit支持两种action：<code>sequential</code>和<code>grouped</code>。<code>sequential</code> action表示action按照顺序执行。如果想要action同时运行，那么就使用<code>grouped</code>。</p>

<p>当然，也可以在sequential action中包含grouped action，反之亦然。更多相关内容请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40013043">Sprite Kit Programming Guide</a>中的<code>Adding Actions to Nodes</code>章节。</p>

<p>当动画执行完毕之后，<code>bearMoveEnded</code>会被调用，所有的动画都将被停止，并等待下一个移动方位。</p>

<p>搞定了！</p>

<p>现在编译并运行程序，一切正常的话，那么当点击屏幕时，熊会跟着移动。</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/13.png" alt="" /></p>

<h3><a id="hqhc"></a>何去何从?</h3>

<p>这里是本文涉及到的<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/09/AnimatedBear.zip">工程示例</a>。</p>

<p>下面这些想法可以让动画更加有趣：</p>

<ul>
<li>尝试在方法<code>walkingBear</code>中增加或者减慢运动的速度，看看效果</li>
<li>试着在屏幕上同时显示多个熊。提示：创建多个sprite node，并赋予action。</li>
</ul>


<p>至此，你应该已经知道如何使用动画了。</p>

<p>如果你希望学习更多相关Sprite Kit内容，可以看看这本书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials">iOS Games by Tutorials</a>。本书会告诉你需要知道的内容——从物理特性，到磁贴地图，以及粒子系统，甚至是制作自己的关卡编辑器。</p>

<p>……Sprite Kit教程：动画和纹理图集 2 结束……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sprite Kit教程：动画和纹理图集 1]]></title>
    <link href="http://BeyondVincent.github.io/blog/2013/10/16/115-spritekit-tutorial-animations-and-texture-atlases-1/"/>
    <updated>2013-10-16T12:40:00+08:00</updated>
    <id>http://BeyondVincent.github.io/blog/2013/10/16/115-spritekit-tutorial-animations-and-texture-atlases-1</id>
    <content type="html"><![CDATA[<p><img src="http://BeyondVincent.github.io/images/2013/10/2.png"></p>

<!--more-->


<p>注：本文译自<a href="http://www.raywenderlich.com/45152/sprite-kit-tutorial-animations-and-texture-atlases"><code>Sprite Kit Tutorial: Animations and Texture Atlases</code></a></p>

<h3><strong>目录</strong></h3>

<ul>
<li><a href="#cjgc">创建一个工程</a></li>
<li><a href="#wltj">纹理图集和熊</a></li>
<li><a href="#jddh">一个简单的动画</a></li>
<li>改变动画运动的方向</li>
<li>在屏幕上让熊移动</li>
<li>何去何从?</li>
</ul>


<p>从本文，可以学习到如何使用iOS 7中的Sprite Kit框架创建一个简单的动画：在屏幕上行走的熊。</p>

<p>另外还可以学习到如何使用纹理图集来制作动画效果，如何在触摸事件发生时让熊移动，以及改变熊运动的方向。</p>

<p>学习本文之前，最好先看看下面的文章：
<a href="http://beyondvincent.com/blog/2013/10/12/114-spritekit-tutorial-for-beginners-3/"><code>Sprite Kit教程：初学者 1</code></a>
<a href="http://beyondvincent.com/blog/2013/09/29/113-spritekit-tutorial-for-beginners-2/"><code>Sprite Kit教程：初学者 2</code></a>
<a href="http://beyondvincent.com/blog/2013/09/26/113-spritekit-tutorial-for-beginners-1/"><code>Sprite Kit教程：初学者 3</code></a></p>

<p>英文原文在这里：<a href="http://www.raywenderlich.com/42699/spritekit-tutorial-for-beginners"><code>Sprite Kit Tutorial for Beginners</code></a></p>

<p>下面我们就开始吧。</p>

<h3><a id="cjgc"></a>创建一个工程</h3>

<p>我们先创建好一个工程架子——选择<code>File\New Project…</code>，在<code>iOS Application</code>中选择<code>Sprite Kit Game</code>，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/4.png"></p>

<p>选择<code>Next</code>，并将工程命名为<code>AnimatedBear</code>，把Class Prefix中的内容清除掉，并将Devices选择为<code>iPad</code>，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/5.png"></p>

<p>接着选择<code>Next</code>，将工程保存到磁盘中。</p>

<p>现在编译并运行程序的话，当点击屏幕时，可以看到在屏幕中有一个自动旋转的飞船。如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/6.png"></p>

<p>这样工程架子就准备好了，下面我们去寻找一些熊的动画资源——从这里下载即可：<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/08/BearImages.zip">BearImages Art</a>。如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/7.jpg" alt="熊的示例图片" /></p>

<p>上面下载到的图片有所需要的最大分辨率——iPad retina显示(2X)和non-retina版本(1x)。这些文件的命名方式为bear1..n@2x~ipad和bear1..n~ipad.png。</p>

<p>在这里，构建一个动画，你可以只需要将这些图片直接添加到Sprite Kit工程中即可。不过，还有另外一种更加方便的方法来构建动画——使用纹理图集。</p>

<h3><a id="wltj"></a>纹理图集和熊</h3>

<p>如果之前你没使用过纹理图集，那你可以把它想象为一副很大的图片，其中包括动画中需要使用到的各种图片。这个图集可以看做是一个文件，它指定了每个sprite的边界范围，当在代码中需要使用时，可以将这些sprite取出来。</p>

<p>使用纹理图集是因为Sprite Kit和图形引擎会对其做相应的优化处理。<code>后面这段话暂时不知道什么意思:</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>If you use sprites within a texture atlas properly, rather than making one OpenGL ES draw call per sprite it just makes one per texture atlas sheet.</span></code></pre></td></tr></table></div></figure>


<p>简而言之——使用纹理图集会非常的快，特别是有大量sprite的时候！</p>

<p>Xcode会自动的生成这个纹理图集文件，并指定好每个sprite的边界范围，这样当在代码中需要用到某个sprite的时候，可以方便取出来。这一切都会自动处理，开发者不用亲力为之。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>注意：当纹理图集有问题时(例如错误的图片等)，那么建议clean一下工程(Product\Clean)——这样可以强制让纹理图集重新构建。</span></code></pre></td></tr></table></div></figure>


<p>为纹理图集创建一个文件夹，并将图片文件放置到该文件夹中，然后在文件夹名称尾部添加<code>.atlas</code>。这样Xcode就能识别出.atlas扩展名，进而自动的将图片合并为一个纹理图集。</p>

<p>之前下载的图片资源中有一个名为<code>BearImages.atlas</code>的文件夹，里面包含了各种分辨率的图片(是其它两个文件夹中的图片合集)。</p>

<p>将名为<code>BearImages.atlas</code>的文件夹拖拽到程序中，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/8.png" alt="" /></p>

<p>当释放鼠标时，会看到如下图片中的对话框：是关于如何添加到工程中的。确保选中这三项：<code>Copy items into destination group’s folder</code>, <code>Create groups for any added folder</code>, 和 <code>the AnimatedBear</code>，然后点击<code>Finish</code>：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/9.png" alt="" /></p>

<p>在Xcode中展开这个文件夹<code>BearImages.atlas</code>，会看到如下内容：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/10.png" alt="" /></p>

<p>下面，是时候让熊动起来了！</p>

<h3><a id="jddh"></a>一个简单的动画</h3>

<p>这里我们先把熊显示在屏幕中间，并开启永久循环动画。</p>

<p>此处主要都是在<code>MyScene.m</code>中写代码。打开这个文件，并用下面的代码替换之：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;AVFoundation/AVFoundation.h&gt;</span>
</span><span class='line'><span class="cp">#import &quot;MyScene.h&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">MyScene</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">SKSpriteNode</span> <span class="o">*</span><span class="n">_bear</span><span class="p">;</span>
</span><span class='line'>    <span class="n">NSArray</span> <span class="o">*</span><span class="n">_bearWalkingFrames</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nl">initWithSize:</span><span class="p">(</span><span class="n">CGSize</span><span class="p">)</span><span class="n">size</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="nl">initWithSize:</span><span class="n">size</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* Setup your scene here */</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">self</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKColor</span> <span class="n">blackColor</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// TODO...</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">update:</span><span class="p">(</span><span class="n">CFTimeInterval</span><span class="p">)</span><span class="n">currentTime</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* Called before each frame is rendered */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码很简单，只是定义了几个稍后会用到的变量。编译并运行一下，确保没有错误——会看到屏幕是黑色的。</p>

<p>接下来要让熊动起来，有5步需要处理，我们就来看看吧。</p>

<p>记得将下面的代码添加到<code>initWithSize</code>方法的<code>TODO</code>位置。</p>

<p><code>1) 构建一个用于保存行走帧(walking frame)</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">walkFrames</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>2) 加载纹理图集</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">SKTextureAtlas</span> <span class="o">*</span><span class="n">bearAnimatedAtlas</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKTextureAtlas</span> <span class="nl">atlasNamed:</span><span class="s">@&quot;BearImages&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码会从程序bundle的数据区中创建一个图集。Sprite Kit会根据设备的寻找对应分辨率的图片文件，在iPad retina上会使用BearImages@2x~ipad.png。</p>

<p><code>3) 构建帧列表</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">numImages</span> <span class="o">=</span> <span class="n">bearAnimatedAtlas</span><span class="p">.</span><span class="n">textureNames</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">numImages</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSString</span> <span class="o">*</span><span class="n">textureName</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span><span class="s">@&quot;bear%d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="n">SKTexture</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="p">[</span><span class="n">bearAnimatedAtlas</span> <span class="nl">textureNamed:</span><span class="n">textureName</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">walkFrames</span> <span class="nl">addObject:</span><span class="n">temp</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">_bearWalkingFrames</span> <span class="o">=</span> <span class="n">walkFrames</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码根据图片名称从图集中循环获取到一个帧列表(这些图片的命名为bear1.png->bear8.png)，注意到<code>numImages</code>这个变量了吗？它为啥要除以2呢？</p>

<p>这是因为：纹理图集包含了所有分辨率的图片文件(non-retina和retina)。共有16个文件，每种分辨率有8个文件。要想加载某种分辨率的图片，就需要除以2。这样通过名称和计数器，就能获取到正确的分辨率图片。</p>

<p><code>4) 创建sprite，并将其位置设置为屏幕中间，然后将其添加到场景中</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">SKTexture</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">_bearWalkingFrames</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="n">_bear</span> <span class="o">=</span> <span class="p">[</span><span class="n">SKSpriteNode</span> <span class="nl">spriteNodeWithTexture:</span><span class="n">temp</span><span class="p">];</span>
</span><span class='line'><span class="n">_bear</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">CGRectGetMidX</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">),</span> <span class="n">CGRectGetMidY</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">frame</span><span class="p">));</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">addChild:</span><span class="n">_bear</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span> <span class="n">walkingBear</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>利用帧列表的第一帧构建一个sprite，然后将其放置到屏幕正中间。最后调用walkingBear方法，让熊开始走动。</p>

<p><code>5) 在initWithSize方法后面添加一个新的方法walkingBear</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">walkingBear</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">//This is our general runAction method to make our bear walk.</span>
</span><span class='line'>    <span class="p">[</span><span class="n">_bear</span> <span class="nl">runAction:</span><span class="p">[</span><span class="n">SKAction</span> <span class="nl">repeatActionForever:</span>
</span><span class='line'>                      <span class="p">[</span><span class="n">SKAction</span> <span class="nl">animateWithTextures:</span><span class="n">_bearWalkingFrames</span>
</span><span class='line'>                                       <span class="nl">timePerFrame:</span><span class="mf">0.1f</span>
</span><span class='line'>                                             <span class="nl">resize:</span><span class="n">NO</span>
</span><span class='line'>                                            <span class="nl">restore:</span><span class="n">YES</span><span class="p">]]</span> <span class="nl">withKey:</span><span class="s">@&quot;walkingInPlaceBear&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的这个action会以0.1秒的间隔开始播放各帧。如果你的代码再次调用这个方法使动画重新开始的话，<code>walkingInPlaceBear</code>这个key会强制移除动画。这对于确保动画不相互干扰非常重要。<code>withKey</code>参数还提供了一个钟方法对动画进行检查，来判断其是否通过名称运行的。</p>

<p>这个action是永久重复的，内部的actionan <code>imateWithTextures</code>会按顺序动画播放帧列表中的图片。</p>

<p><code>完工!</code></p>

<p>现在编译并运行程序，一切正常的话，会在屏幕中看到一个会动的熊，如下图所示：</p>

<p><img src="http://BeyondVincent.github.io/images/2013/10/11.png" alt="" /></p>

<p>……Sprite Kit教程：动画和纹理图集 1 结束……</p>
]]></content>
  </entry>
  
</feed>
